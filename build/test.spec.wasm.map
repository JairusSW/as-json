{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/shared/typeinfo.ts","~lib/rt/itcms.ts","~lib/wasi_internal.ts","~lib/bindings/wasi_snapshot_preview1.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/util/number.ts","~lib/shared/runtime.ts","~lib/util/sort.ts","~lib/string.ts","~lib/util/error.ts","~lib/rt.ts","~lib/arraybuffer.ts","~lib/util/hash.ts","~lib/map.ts","~lib/as-test/assembly/coverage.ts","assembly/__tests__/test.spec.ts","assembly/index.ts","assembly/serialize/string.ts","assembly/chars.ts","assembly/sink.ts","assembly/util.ts","assembly/serialize/bool.ts","assembly/serialize/integer.ts","assembly/serialize/float.ts","assembly/serialize/object.ts","assembly/serialize/date.ts","assembly/serialize/array.ts","assembly/serialize/map.ts","assembly/deserialize/bool.ts","assembly/deserialize/array.ts","assembly/deserialize/array/array.ts","assembly/deserialize/array/bool.ts","assembly/deserialize/array/float.ts","assembly/deserialize/float.ts","assembly/deserialize/array/integer.ts","assembly/deserialize/integer.ts","assembly/deserialize/array/map.ts","assembly/deserialize/array/object.ts","assembly/deserialize/array/string.ts","assembly/deserialize/string.ts","assembly/deserialize/object.ts","assembly/deserialize/map.ts","assembly/deserialize/date.ts","~lib/as-variant/assembly/index.ts","~lib/@hypercubed/as-mpz/assembly/index.ts","~lib/builtins.ts","~lib/number.ts","~lib/staticarray.ts","assembly/serialize/mpz.ts","assembly/deserialize/mpz.ts","~lib/table-as/assembly/index.ts","~lib/table-as/assembly/types.ts","~lib/as-test/assembly/index.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","assembly/__tests__/types.ts","~lib/as-test/assembly/src/node.ts","~lib/as-test/assembly/src/expectation.ts","~lib/as-test/assembly/src/group.ts","~lib/array.ts","~lib/util/casemap.ts","~lib/math.ts","~lib/memory.ts","~lib/util/memory.ts","~lib/as-rainbow/assembly/index.ts","~lib/wasi_process.ts","~lib/wasi_console.ts","~lib/wasi_performance.ts","~lib/as-test/assembly/util.ts","~lib/function.ts"],"names":[],"mappings":"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,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,E,KACA,G,KACA,G,KACA,G,KACA,G,KACA,G,KACA,G,KACA,G,KACA,G,KACA,G,KACA,G,KACA,G,KACA,G,KACA,G,MA5EsB,IAAP,EACM,IAAP,EACM,IAAP,EACW,IAAP,EACU,IAAP,EACM,IAAP,EACC,IAAP,EACS,IAAP,EACI,IAAP,EACS,IAAP,EACK,IAAP,EACW,IAAP,EACI,IAAP,EACa,IAAP,EACO,IAAP,EACK,IAAP,EACI,IAAP,EACY,IAAP,EACD,IAAP,EACS,IAAP,EACO,IAAP,EACO,IAAP,EACM,IAAP,EACc,IAAP,EACA,IAAP,EACQ,IAAP,EACY,IAAP,EACC,IAAP,EACQ,IAAP,EACI,IAAP,EACW,IAAP,EACM,IAAP,EACM,IAAP,EACQ,IAAP,EACO,IAAP,EACS,IAAP,EACQ,IAAP,EACU,IAAP,EACG,IAAP,EACQ,IAAP,EACS,IAAP,EACE,IAAP,EACQ,IAAP,EACM,IAAP,EACO,IAAP,EACQ,IAAP,EACM,IAAP,EACQ,IAAP,EACM,IAAP,EACO,IAAP,EACY,IAAP,EACE,IAAP,EACO,IAAP,EACS,IAAP,EACM,IAAP,EACS,IAAP,EACa,IAAP,EACA,IAAP,EACM,IAAP,EACM,IAAP,EACM,IAAP,EACW,IAAP,EACQ,IAAP,EACE,IAAP,EACO,IAAP,EACQ,IAAP,EACgB,IAAP,EACE,IAAP,EACG,IAAP,EACM,IAAP,EACQ,IAAP,EACM,IAAP,EACQ,IAAP,EACU,IAAP,EACK,IAAP,EACK,IAAP,EACa,IAAP,EAElB,IAAP,OMjXiB,EAAb,EACa,EAAmC,EAAyB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E,gKAAvD,GArJI,G,KA0BO,E,YAAU,G,OAAS,E,KA2HvB,A,EAAU,E,cAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,cAAO,EAAP,GjDzIxB,EiDyIwB,E,gKAAvD,GA3HI,G,c3CyHJ,G,AACY,E,EAAe,E,EAAmB,I,K2CpJnC,E,YAAU,G,OAAU,E,KAqJxB,A,EAAU,E,cAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,cAAO,EAAP,GjDzIxB,EiDyIwB,E,gKAAvD,GArJI,G,KA0BO,E,YAAU,G,OAAS,E,KA2HvB,A,EAAU,E,cAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,cAAO,EAAP,GjDzIxB,EiDyIwB,E,gKAAvD,GA3HI,G,c3C0HJ,G,AACY,E,EAAe,E,EAAmB,I,K2CrJnC,E,YAAU,G,OAAU,E,KAqJxB,A,EAAU,E,cAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,cAAO,EAAP,GjDzIxB,EiDyIwB,E,iKAAvD,GArJI,G,MA0BO,E,YAAU,G,QAAS,E,MA2HvB,A,EAAU,E,cAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,cAAO,EAAP,GjDzIxB,EiDyIwB,E,iKAAvD,GA3HI,G,c3C2HJ,G,AACY,E,EAAe,E,EAAmB,I,M2CtJnC,E,YAAU,G,QAAU,E,MAqJxB,A,EAAU,E,cAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,cAAO,EAAP,GjDzIxB,EiDyIwB,E,iKAAvD,GArJI,G,MA0BO,E,YAAU,G,QAAS,E,MA2HvB,A,EAAU,E,cAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,cAAO,EAAP,GjDzIxB,EiDyIwB,E,iKAAvD,GA3HI,G,c3C4HJ,G,AACY,E,EAAc,I,M2CxHf,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,cAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,cAAO,EAAP,GjDzIxB,EiDyIwB,E,iKAAvD,GAtHI,G,c3CwHJ,G,AACI,E,cAAA,GAAJ,E,AACgB,E,EAAqB,I,M2C1B1B,E,YAAU,G,QAAW,E,MAsBzB,A,EAAU,E,eAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,eAAO,EAAP,GjDzIxB,EiDyIwB,E,yKAAvD,GAtBI,G,e3C0B+C,I,eAAnC,G,eAAyC,E,EAAc,I,M2C1H5D,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,eAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,eAAO,EAAP,GjDzIxB,EiDyIwB,E,yKAAvD,GAtHI,G,e3C0HY,G,cAAgF,I,cAAhF,G,cAAZ,I,AAEW,E,cAAA,GAAf,EACa,EAAb,EACY,EAAZ,EACmB,EAAnB,E,EACwB,G,MACV,GAAd,GACa,EAAR,E,EAAW,E,AAAI,E,cAAA,GAAJ,C,EACR,EAAJ,E,IAAyB,E,GAAA,I,EACD,E,cAAO,EAAjB,G,MACd,E,cAAA,GACa,EAAR,E,EAAW,E,AAAI,E,cAAA,G,cAAA,GAAJ,C,IACkB,E,cAAA,G,cAAc,EAAxB,G,MACJ,E,cAAA,GAAhB,EACA,E,GAAA,EACI,EAAW,EAAX,CAAJ,E,AACI,E,cAAA,E,cAAA,G,GAAA,IACO,EAAW,EAAX,CAAJ,E,AACH,E,cAAgB,EAAhB,G,AACA,E,cAAA,E,cAAA,G,GAAA,GACA,E,GAAA,IATkC,E,GAAA,E,IAYtC,E,cAAA,GAAiB,EAAjB,CAAJ,E,AACI,E,cAAgB,EAAhB,G,AACY,E,EAAsB,I,M2C9D/B,E,YAAU,G,QAAW,E,MAgCzB,A,EAAU,E,eAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,eAAO,EAAP,GjDzIxB,EiDyIwB,E,yKAAvD,GAhCI,G,e3C8DkD,I,eAAlC,G,eAAwC,E,EAAc,E,eAAA,G,M2CpJ/D,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,eAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,eAAO,EAAP,GjDzIxB,EiDyIwB,E,yKAAvD,GAtHI,G,e3CoJgB,G,cAA2E,I,cAA3E,G,cAAZ,IAEA,E,GAAA,E,EACY,E,EAAc,I,M2C9GvB,E,YAAU,G,QAAU,E,MA6ExB,A,EAAU,E,eAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,eAAO,EAAP,GjDzIxB,EiDyIwB,E,yKAAvD,GA7EI,G,e3C8G0C,I,eAA1B,G,cAAgC,E,EAAc,E,eAAA,G,M2CvJvD,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,E,SAAc,E,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GAtHI,G,e3CuJgB,G,cAAmE,I,cAAnE,G,SACZ,E,cAAqB,G,uBACT,G,cAAZ,I,EAGW,E,cAAA,G,OACX,GAAJ,E,AACQ,G,cAAA,GAAJ,E,EAA+B,G,cAAA,G,UAAA,E,oCAAZ,I,AACf,G,cAAA,GAAJ,E,EAAmB,E,gBAAqB,G,cAAA,G,UAAA,E,+CAGxC,EAAJ,E,IAAwB,E,GAAA,IAhCO,E,GAAA,E,IAmC/B,EAAJ,E,AACgB,E,EAAY,I,O2C5PjB,E,YAAU,G,SAAU,G,OA4MxB,A,EAAU,G,cAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,cAAO,EAAP,GjDzIxB,EiDyIwB,E,qKAAvD,GA5MI,G,c3C4PA,G,AACY,E,cAAZ,I,AAIA,E,cAAA,K,AAAoB,G,cAAA,I,GAAxB,E,AACgB,E,EAAc,I,O2C5KnB,E,YAAU,G,SAAS,G,OAsHvB,A,EAAU,G,cAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,cAAO,EAAP,GjDzIxB,EiDyIwB,E,qKAAvD,GAtHI,G,c3C4KA,G,EACe,G,cAAA,G,SAEW,A,kDACtB,G,aAGS,EAAR,G,EAAW,G,AAAI,G,cAAA,GAAJ,C,IACY,G,cAAO,GAAjB,G,SACD,G,cAAA,G,SACK,G,eAAA,G,eAAa,G,eAAb,G,eAAmB,G,eAAA,GNzMd,EMyMc,E,eAAnB,G,cAA2C,G,eAA3C,G,cAAiD,G,cAAA,GNzM5C,EMyM4C,E,cAAjD,G,SACL,G,cAAA,G,SACA,G,cAAA,E,OACb,G,cAAW,A,wCAAC,E,EAAoB,G,O2C/K7B,E,YAAU,G,SAAS,G,OA4GvB,A,EAAU,G,cAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,cAAO,EAAP,GjDzIxB,EiDyIwB,E,yKAAvD,GA5GI,G,Q3C+KgD,G,QAAM,I,cAAM,G,eAAN,G,uBAAlD,CAN+B,G,GAAA,G,IAQvB,E,EAA0B,G,eFpLgB,EEoL5B,G,O2C3LnB,E,YAAU,G,SAAS,G,OAsHvB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GAtHI,G,c3C2LgD,I,cAApC,G,cAAZ,I,AAGQ,E,EAAc,I,O2C9Lf,E,YAAU,G,SAAS,G,OAsHvB,A,EAAU,G,cAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,cAAO,EAAP,GjDzIxB,EiDyIwB,E,qKAAvD,GAtHI,G,c3C8LJ,GACW,GAAoB,GAApB,CAAX,G,AACY,E,EAAe,I,O2CrMhB,E,YAAU,G,SAAS,G,OA2HvB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GA3HI,G,e3CqM2C,IAAS,E,EAAe,E,EAAY,ENnNpD,EMmNoD,E,eAAoB,I,eAApB,G,O2CtRxE,E,YAAU,G,SAAU,G,OA4MxB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GA5MI,G,OAiFO,E,YAAU,G,SAAS,G,OA2HvB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GA3HI,I3CqMiH,E,EAAe,E,EAAc,I,O2CjRvI,E,YAAU,G,SAAU,G,OAuMxB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GAvMI,G,OA4EO,E,YAAU,G,SAAS,G,OA2HvB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GA3HI,I,e3CqMQ,G,eAAsJ,I,eAAtJ,G,eAA6J,ENnN1I,EMmN0I,E,eAA7J,G,cAAiL,I,cAAjL,G,cAAZ,G,AACY,E,EAAe,I,O2CtMhB,E,YAAU,G,SAAS,G,OA2HvB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GA3HI,G,e3CsM2C,IAAe,E,EAAe,E,EAAY,ENpN1D,EMoN0D,E,eAA0B,I,eAA1B,G,O2CvR9E,E,YAAU,G,SAAU,G,OA4MxB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GA5MI,G,OAiFO,E,YAAU,G,SAAS,G,OA2HvB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GA3HI,I3CsM6H,E,EAAe,E,EAAc,I,O2ClRnJ,E,YAAU,G,SAAU,G,OAuMxB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GAvMI,G,OA4EO,E,YAAU,G,SAAS,G,OA2HvB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GA3HI,I,e3CsMQ,G,eAAkK,I,eAAlK,G,eAAyK,ENpNtJ,EMoNsJ,E,eAAzK,G,cAA4L,I,cAA5L,G,cAAZ,G,AACI,E,cAAA,GAAJ,E,AAAkC,E,EAAe,I,O2CvMtC,E,YAAU,G,SAAS,G,OA2HvB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GA3HI,G,e3CuMiE,G,eAAA,KAAkB,E,EAAe,E,EAAY,G,eAAA,GNrNnF,EMqNmF,E,eAA6B,I,eAA7B,G,O2CxRvG,E,YAAU,G,SAAU,G,OA4MxB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GA5MI,G,OAiFO,E,YAAU,G,SAAS,G,OA2HvB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GA3HI,I3CuMyJ,E,EAAe,E,EAAc,I,O2CnR/K,E,YAAU,G,SAAU,G,OAuMxB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GAvMI,G,OA4EO,E,YAAU,G,SAAS,G,OA2HvB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GA3HI,I,e3CuM8B,G,eAAwK,I,eAAxK,G,eAA+K,GNrNlL,EMqNkL,E,eAA/K,G,cAAuM,I,cAAvM,G,cAAZ,I,AACV,E,EAAe,I,O2CxMhB,E,YAAU,G,SAAS,G,OA2HvB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GA3HI,G,c3CwM0C,I,cAAlC,G,cAAZ,G,AACY,E,EAAe,I,O2CzMhB,E,YAAU,G,SAAS,G,OA2HvB,A,EAAU,G,eAAO,EAAP,GjDzIc,EiDyId,E,SAAwB,G,SAAc,G,eAAO,EAAP,GjDzIxB,EiDyIwB,E,6KAAvD,GA3HI,G,c3CyMqD,GAAX,G,cAAlC,G,cAAZ,GACI,EAAJ,EACiB,EAAb,I,2tN+ChQQ,G,OACA,G,KAEJ,EAAR,EAEA,EAAO,E,AAAQ,E,WAAA,E,EAAa,E,WAAA,E,OAAjB,CAAJ,C,IACW,E,WAAY,EAAZ,G,OACA,E,WAAa,EAAb,G,KACV,EAAJ,E,AACQ,E,WAAS,E,WAAT,GAAJ,E,EACI,E,WAAS,E,EAAgB,E,KJ8F1B,E,YAAU,G,OAAU,E,KAwExB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAxEI,G,qBI7FQ,E,WAAS,E,EAAc,E,KJwFxB,E,YAAU,G,OAAU,E,KA6ExB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GA7EI,G,sBItFQ,E,WAAS,E,qBACT,E,WAAS,E,qBAGT,E,WAAS,E,WAAT,GAAJ,E,EACI,E,WAAS,E,EAAgB,E,KJsF1B,E,YAAU,G,OAAU,E,KAwExB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAxEI,G,qBIrFQ,E,WAAS,E,EAAc,E,KJgFxB,E,YAAU,G,OAAU,E,KA6ExB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GA7EI,G,sBI9EQ,E,WAAS,E,qBACT,E,WAAS,E,qBAjBsB,E,GAAA,E,IAsBtC,EAAD,CAAJ,EACI,EAAO,E,AAAI,E,WAAA,EAAJ,C,IACH,E,WAAS,E,EAAc,E,WAAY,EAAZ,G,MJsEpB,E,YAAU,G,QAAU,E,MA6ExB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GA7EI,G,mBIvEwB,E,GAAA,E,IAGxB,EAAO,E,AAAI,E,WAAA,EAAJ,C,IAAuB,E,WAAS,E,EAAc,E,WAAa,EAAb,G,MJoE9C,E,YAAU,G,QAAU,E,MA6ExB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GA7EI,G,mBIpEyB,E,GAAA,E,KAGtB,A,0BACG,E,2BACC,E,4BAFX,O,qBX0PS,E,WAAA,GAAD,G,AAAc,E,WAAA,GAAiB,EAAjB,E,GAAlB,EAAsD,E,YAAP,E,IAElC,E,WAAA,G,OAAA,E,GAAwB,E,WAAA,G,WAAV,I,SACb,E,WAAA,G,OAAA,E,GAAiC,EAAR,G,WAAV,I,KAEzB,E,WAAA,GAAJ,E,AACQ,E,WAAA,GAAiB,EAAjB,CAAJ,EAA0C,E,YAAP,E,EAClB,E,WAAM,E,WAAO,EAAlB,G,KACL,E,EAAY,I,KOhUhB,E,YAAU,G,OAAU,E,KA4MxB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GA5MI,G,WPgU2C,I,WAAhC,G,WAAuC,E,EAAiB,A,EAAK,E,EAAc,I,KO1O/E,E,YAAU,G,OAAS,E,KAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAtHI,G,OP0O0G,E,WAAA,G,WAAA,G,OAA0B,E,EAAc,I,WAAQ,E,WAAA,G,WAAR,G,WAAkB,I,WAAlB,G,KO1O3I,E,YAAU,G,OAAS,E,KAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAtHI,G,QP0OgL,E,EAAc,I,MO1OvL,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QP0OkN,E,WAAA,G,WAAA,G,iNOrO3M,E,YAAU,G,QAAS,E,MAiHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAjHI,G,WPqOW,G,YAAP,E,AAGA,E,WAAQ,E,WAAR,GAAJ,EAA0B,E,YAAP,E,EAEF,E,WAAM,E,WW1SkC,EX0S7C,G,MAEL,E,EAAY,I,MOvUZ,E,YAAU,G,QAAU,E,MA4MxB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GA5MI,G,WPuUuC,I,WAAhC,G,WAAuC,E,EAAiB,A,EAAK,E,EAAc,I,MOjP3E,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiPsG,E,WAAA,G,WAAA,G,QAA0B,E,EAAc,I,WAAO,E,WAAA,G,WAAP,G,WAAiB,I,WAAjB,G,MOjPvI,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiP2K,E,EAAc,I,MOjPlL,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiP6M,E,WAAA,G,WAAA,G,iNO5OtM,E,YAAU,G,QAAS,E,MAiHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAjHI,G,WP4OO,G,YAAP,O,qBAfK,E,WAAA,GAAD,G,AAAc,E,WAAA,GAAiB,EAAjB,E,GAAlB,EAAsD,E,YAAP,E,IAElC,E,WAAA,G,OAAA,E,GAAwB,E,WAAA,GAAV,I,SACb,E,WAAA,G,OAAA,E,GAAiC,EAAR,GAAV,I,KAEzB,E,WAAA,GAAJ,E,AACQ,E,WAAA,GAAiB,EAAjB,CAAJ,EAA0C,E,YAAP,E,EAClB,E,WAAM,E,WAAO,EAAlB,G,KACL,E,EAAY,I,KOhUhB,E,YAAU,G,OAAU,E,KA4MxB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GA5MI,G,WPgU2C,I,WAAhC,G,WAAuC,E,EAAiB,A,EAAK,E,EAAc,I,KO1O/E,E,YAAU,G,OAAS,E,KAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAtHI,G,OP0O0G,E,WAAA,G,WAAA,G,OAA0B,E,EAAc,I,WAAQ,E,WAAA,G,WAAR,G,WAAkB,I,WAAlB,G,KO1O3I,E,YAAU,G,OAAS,E,KAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAtHI,G,QP0OgL,E,EAAc,I,MO1OvL,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QP0OkN,E,WAAA,G,WAAA,G,iNOrO3M,E,YAAU,G,QAAS,E,MAiHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAjHI,G,WPqOW,G,YAAP,E,AAGA,E,WAAQ,E,WAAR,GAAJ,EAA0B,E,YAAP,E,EAEF,E,WAAM,E,WW1SkC,EX0S7C,G,MAEL,E,EAAY,I,MOvUZ,E,YAAU,G,QAAU,E,MA4MxB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GA5MI,G,WPuUuC,I,WAAhC,G,WAAuC,E,EAAiB,A,EAAK,E,EAAc,I,MOjP3E,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiPsG,E,WAAA,G,WAAA,G,QAA0B,E,EAAc,I,WAAO,E,WAAA,G,WAAP,G,WAAiB,I,WAAjB,G,MOjPvI,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiP2K,E,EAAc,I,MOjPlL,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiP6M,E,WAAA,G,WAAA,G,iNO5OtM,E,YAAU,G,QAAS,E,MAiHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAjHI,G,WP4OO,G,YAAP,O,qBAfK,E,WAAA,GAAD,G,AAAc,E,WAAA,GAAiB,EAAjB,E,GAAlB,EAAsD,E,YAAP,E,IAElC,E,WAAA,G,OAAA,E,GAAwB,E,WAAA,GAAV,I,SACb,E,WAAA,G,OAAA,E,GAAiC,EAAR,GAAV,I,KAEzB,E,WAAA,GAAJ,E,AACQ,E,WAAA,GAAiB,EAAjB,CAAJ,EAA0C,E,YAAP,E,EAClB,E,WAAM,E,WAAO,EAAlB,G,KACL,E,EAAY,I,KOhUhB,E,YAAU,G,OAAU,E,KA4MxB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GA5MI,G,WPgU2C,I,WAAhC,G,WAAuC,E,EAAiB,A,EAAK,E,EAAc,I,KO1O/E,E,YAAU,G,OAAS,E,KAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAtHI,G,OP0O0G,E,WAAA,G,WAAA,G,OAA0B,E,EAAc,I,WAAQ,E,WAAA,G,WAAR,G,WAAkB,I,WAAlB,G,KO1O3I,E,YAAU,G,OAAS,E,KAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAtHI,G,QP0OgL,E,EAAc,I,MO1OvL,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QP0OkN,E,WAAA,G,WAAA,G,iNOrO3M,E,YAAU,G,QAAS,E,MAiHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAjHI,G,WPqOW,G,YAAP,E,AAGA,E,WAAQ,E,WAAR,GAAJ,EAA0B,E,YAAP,E,EAEF,E,WAAM,E,WW1SkC,EX0S7C,G,MAEL,E,EAAY,I,MOvUZ,E,YAAU,G,QAAU,E,MA4MxB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GA5MI,G,WPuUuC,I,WAAhC,G,WAAuC,E,EAAiB,A,EAAK,E,EAAc,I,MOjP3E,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiPsG,E,WAAA,G,WAAA,G,QAA0B,E,EAAc,I,WAAO,E,WAAA,G,WAAP,G,WAAiB,I,WAAjB,G,MOjPvI,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiP2K,E,EAAc,I,MOjPlL,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiP6M,E,WAAA,G,WAAA,G,iNO5OtM,E,YAAU,G,QAAS,E,MAiHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAjHI,G,WP4OO,G,YAAP,O,qBAfK,E,WAAA,GAAD,G,AAAc,E,WAAA,GAAiB,EAAjB,E,GAAlB,EAAsD,E,YAAP,E,IAElC,E,WAAA,G,OAAA,E,GAAwB,E,WAAA,GAAV,I,SACb,E,WAAA,G,OAAA,E,GAAiC,EAAR,GAAV,I,KAEzB,E,WAAA,GAAJ,E,AACQ,E,WAAA,GAAiB,EAAjB,CAAJ,EAA0C,E,YAAP,E,EAClB,E,WAAM,E,WAAO,EAAlB,G,KACL,E,EAAY,I,KOhUhB,E,YAAU,G,OAAU,E,KA4MxB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GA5MI,G,WPgU2C,I,WAAhC,G,WAAuC,E,EAAiB,A,EAAK,E,EAAc,I,KO1O/E,E,YAAU,G,OAAS,E,KAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAtHI,G,OP0O0G,E,WAAA,G,WAAA,G,OAA0B,E,EAAc,I,WAAQ,E,WAAA,G,WAAR,G,WAAkB,I,WAAlB,G,KO1O3I,E,YAAU,G,OAAS,E,KAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAtHI,G,QP0OgL,E,EAAc,I,MO1OvL,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QP0OkN,E,WAAA,G,WAAA,G,iNOrO3M,E,YAAU,G,QAAS,E,MAiHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAjHI,G,WPqOW,G,YAAP,E,AAGA,E,WAAQ,E,WAAR,GAAJ,EAA0B,E,YAAP,E,EAEF,E,WAAM,E,WW1SkC,EX0S7C,G,MAEL,E,EAAY,I,MOvUZ,E,YAAU,G,QAAU,E,MA4MxB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GA5MI,G,WPuUuC,I,WAAhC,G,WAAuC,E,EAAiB,A,EAAK,E,EAAc,I,MOjP3E,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiPsG,E,WAAA,G,WAAA,G,QAA0B,E,EAAc,I,WAAO,E,WAAA,G,WAAP,G,WAAiB,I,WAAjB,G,MOjPvI,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiP2K,E,EAAc,I,MOjPlL,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiP6M,E,WAAA,G,WAAA,G,iNO5OtM,E,YAAU,G,QAAS,E,MAiHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAjHI,G,WP4OO,G,YAAP,O,qBAfK,E,WAAA,GAAD,G,AAAc,E,WAAA,GAAiB,EAAjB,E,GAAlB,EAAsD,E,YAAP,E,IAElC,E,WAAA,G,OAAA,E,GAAwB,E,WAAA,GAAV,I,SACb,E,WAAA,G,OAAA,E,GAAiC,EAAR,GAAV,I,KAEzB,E,WAAA,GAAJ,E,AACQ,E,WAAA,GAAiB,EAAjB,CAAJ,EAA0C,E,YAAP,E,EAClB,E,WAAM,E,WAAO,EAAlB,G,KACL,E,EAAY,I,KOhUhB,E,YAAU,G,OAAU,E,KA4MxB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GA5MI,G,WPgU2C,I,WAAhC,G,WAAuC,E,EAAiB,A,EAAK,E,EAAc,I,KO1O/E,E,YAAU,G,OAAS,E,KAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAtHI,G,OP0O0G,E,WAAA,G,WAAA,G,OAA0B,E,EAAc,I,WAAQ,E,WAAA,G,WAAR,G,WAAkB,I,WAAlB,G,KO1O3I,E,YAAU,G,OAAS,E,KAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAtHI,G,QP0OgL,E,EAAc,I,MO1OvL,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QP0OkN,E,WAAA,G,WAAA,G,iNOrO3M,E,YAAU,G,QAAS,E,MAiHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAjHI,G,WPqOW,G,YAAP,E,AAGA,E,WAAQ,E,WAAR,GAAJ,EAA0B,E,YAAP,E,EAEF,E,WAAM,E,WW1SkC,EX0S7C,G,MAEL,E,EAAY,I,MOvUZ,E,YAAU,G,QAAU,E,MA4MxB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GA5MI,G,WPuUuC,I,WAAhC,G,WAAuC,E,EAAiB,A,EAAK,E,EAAc,I,MOjP3E,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiPsG,E,WAAA,G,WAAA,G,QAA0B,E,EAAc,I,WAAO,E,WAAA,G,WAAP,G,WAAiB,I,WAAjB,G,MOjPvI,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiP2K,E,EAAc,I,MOjPlL,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiP6M,E,WAAA,G,WAAA,G,iNO5OtM,E,YAAU,G,QAAS,E,MAiHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAjHI,G,WP4OO,G,YAAP,O,qBAfK,E,WAAA,GAAD,G,AAAc,E,WAAA,GAAiB,EAAjB,E,GAAlB,EAAsD,E,YAAP,E,IAElC,E,WAAA,G,OAAA,E,GAAwB,E,WAAA,GAAV,I,SACb,E,WAAA,G,OAAA,E,GAAiC,EAAR,GAAV,I,KAEzB,E,WAAA,GAAJ,E,AACQ,E,WAAA,GAAiB,EAAjB,CAAJ,EAA0C,E,YAAP,E,EAClB,E,WAAM,E,WAAO,EAAlB,G,KACL,E,EAAY,I,KOhUhB,E,YAAU,G,OAAU,E,KA4MxB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GA5MI,G,WPgU2C,I,WAAhC,G,WAAuC,E,EAAiB,A,EAAK,E,EAAc,I,KO1O/E,E,YAAU,G,OAAS,E,KAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAtHI,G,OP0O0G,E,WAAA,G,WAAA,G,OAA0B,E,EAAc,I,WAAQ,E,WAAA,G,WAAR,G,WAAkB,I,WAAlB,G,KO1O3I,E,YAAU,G,OAAS,E,KAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAtHI,G,QP0OgL,E,EAAc,I,MO1OvL,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QP0OkN,E,WAAA,G,WAAA,G,iNOrO3M,E,YAAU,G,QAAS,E,MAiHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAjHI,G,WPqOW,G,YAAP,E,AAGA,E,WAAQ,E,WAAR,GAAJ,EAA0B,E,YAAP,E,EAEF,E,WAAM,E,WW1SkC,EX0S7C,G,MAEL,E,EAAY,I,MOvUZ,E,YAAU,G,QAAU,E,MA4MxB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GA5MI,G,WPuUuC,I,WAAhC,G,WAAuC,E,EAAiB,A,EAAK,E,EAAc,I,MOjP3E,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiPsG,E,WAAA,G,WAAA,G,QAA0B,E,EAAc,I,WAAO,E,WAAA,G,WAAP,G,WAAiB,I,WAAjB,G,MOjPvI,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiP2K,E,EAAc,I,MOjPlL,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiP6M,E,WAAA,G,WAAA,G,iNO5OtM,E,YAAU,G,QAAS,E,MAiHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAjHI,G,WP4OO,G,YAAP,O,qBAfK,E,WAAA,GAAD,G,AAAc,E,WAAA,GAAiB,EAAjB,E,GAAlB,EAAsD,E,YAAP,E,IAElC,E,WAAA,G,OAAA,E,GAAwB,E,WAAA,GAAV,I,SACb,E,WAAA,G,OAAA,E,GAAiC,EAAR,GAAV,I,KAEzB,E,WAAA,GAAJ,E,AACQ,E,WAAA,GAAiB,EAAjB,CAAJ,EAA0C,E,YAAP,E,EAClB,E,WAAM,E,WAAO,EAAlB,G,KACL,E,EAAY,I,KOhUhB,E,YAAU,G,OAAU,E,KA4MxB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GA5MI,G,WPgU2C,I,WAAhC,G,WAAuC,E,EAAiB,A,EAAK,E,EAAc,I,KO1O/E,E,YAAU,G,OAAS,E,KAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAtHI,G,OP0O0G,E,WAAA,G,WAAA,G,OAA0B,E,EAAc,I,WAAQ,E,WAAA,G,WAAR,G,WAAkB,I,WAAlB,G,KO1O3I,E,YAAU,G,OAAS,E,KAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,OAAwB,E,OAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,wIAAvD,GAtHI,G,QP0OgL,E,EAAc,I,MO1OvL,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QP0OkN,E,WAAA,G,WAAA,G,iNOrO3M,E,YAAU,G,QAAS,E,MAiHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAjHI,G,WPqOW,G,YAAP,E,AAGA,E,WAAQ,E,WAAR,GAAJ,EAA0B,E,YAAP,E,EAEF,E,WAAM,E,WW1SkC,EX0S7C,G,MAEL,E,EAAY,I,MOvUZ,E,YAAU,G,QAAU,E,MA4MxB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GA5MI,G,WPuUuC,I,WAAhC,G,WAAuC,E,EAAiB,A,EAAK,E,EAAc,I,MOjP3E,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiPsG,E,WAAA,G,WAAA,G,QAA0B,E,EAAc,I,WAAO,E,WAAA,G,WAAP,G,WAAiB,I,WAAjB,G,MOjPvI,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiP2K,E,EAAc,I,MOjPlL,E,YAAU,G,QAAS,E,MAsHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAtHI,G,QPiP6M,E,WAAA,G,WAAA,G,iNO5OtM,E,YAAU,G,QAAS,E,MAiHvB,A,EAAU,E,WAAO,EAAP,GjDzIc,EiDyId,E,QAAwB,E,QAAc,E,WAAO,EAAP,GjDzIxB,EiDyIwB,E,yIAAvD,GAjHI,G,WP4OO,G,YAAP,O,iB3ExGsB,E,WAAlB,EAAiC,EAAzC,E,AACgC,E,WAAlB,EAAd,EACI,E,CAAkC,AAC1B,EAAV,EACU,E,AAAa,E,WAAP,EAA4B,EAxLzC,EAAP,GAwLoB,CAA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","sourceRoot":"./test.spec","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n//  Memory manager block layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                            MM info                              -4\n// >ptr\n//                               ...                              \n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n//  Garbage collector object layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                      Memory manager block                       -20\n// \n//                             GC info                             -16\n// \n//                             GC info                             -12\n// \n//                             RT id                               -8\n// \n//                             RT size                             -4\n// >ptr\n//                               ...                              \n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n//  Block size interpretation (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//  |                    FL                        SB = SL + AL    usize\n// \n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n//  Block layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//             \n//                           size                             LF  info   overhead\n// >ptr           \n//                         if free:  prev                          usize\n//    \n//                         if free: next                          \n//    \n//                              ...                                   >= 0\n//    \n//                         if free: back                          \n//  >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n//  Root layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//           \n//         0        |           flMap                            S \n//       \n//                            slMap[0] S                             \n//      \n//                            slMap[1]                               \n//   u32 \n//                            slMap[22]                              \n//     usize\n//                             head[0]                             \n//       \n//                               ...                               \n//       \n//                            head[367]                            \n//       \n//                              tail                               \n//    SIZE   \n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export let ROOT: Root = changetype<Root>(0); // unsafe initializion below\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    removeBlock(root, right);\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\n    right = GETRIGHT(block);\n    rightInfo = right.mmInfo;\n    // 'back' is set below\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    removeBlock(root, left);\n    block = left;\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\n    // 'back' is set below\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  let head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  let prev = block.prev;\n  let next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\nfunction roundSize(size: usize): usize {\n  const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n  const inv: usize = sizeof<usize>() * 8 - 1;\n  const invRound = inv - SL_BITS;\n  return size < halfMaxSize\n    ? size + (1 << (invRound - clz<usize>(size))) - 1\n    : size;\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const requestSize = roundSize(size);\n    fl = sizeof<usize>() * 8 - 1 - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  let slMap = GETSL(root, fl) & (~0 << sl);\n  let head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  let remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, endU64: u64): bool {\n  let end = <usize>endU64;\n  if (DEBUG) assert(<u64>start <= endU64); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  let tail = GETTAIL(root);\n  let tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  let size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  let leftSize = size - 2 * BLOCK_OVERHEAD;\n  let left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  if (size >= SB_SIZE) {\n    size = roundSize(size);\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  let pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  let pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <u64>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  let rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  let pagesBefore = memory.size();\n  let pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  let root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  let memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <u64>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, <u64>memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, block);\n  prepareBlock(root, block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let blockInfo = block.mmInfo;\n  let blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  let newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  let block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n","// This file is shared with the compiler and must remain portable\n\n//  Typeinfo interpretation \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//   __rtti_base\n//                              count                             \n//  \n//                       Typeinfo#flags [id=0]                     id < count\n// \n//                               ...                              \n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \"./common\";\nimport { onvisit, oncollect, oninterrupt, onyield } from \"./rtrace\";\nimport { TypeinfoFlags } from \"../shared/typeinfo\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\n// Adapted from Bach Le's gc, see: https://github.com/bullno1/ugc\n\n//  Colors \n//  Color        Meaning                                         \n// \n//  WHITE*       Unprocessed                                     \n//  BLACK*       Processed                                       \n//  GRAY         Processed with unprocessed children             \n//  TRANSPARENT  Manually pinned (always reachable)              \n// \n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy let white = 0;\n// @ts-ignore: decorator\n@inline const gray = 2;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy let total: usize = 0;\n\n/** Currently transitioning from SWEEP to MARK state. */\n// @ts-ignore: decorator\n@inline const STATE_IDLE = 0;\n/** Currently marking reachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_MARK = 1;\n/** Currently sweeping unreachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_SWEEP = 2;\n/** Current collector state. */\n// @ts-ignore: decorator\n@lazy let state = STATE_IDLE;\n\n// @ts-ignore: decorator\n@lazy let fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let iter: Object = changetype<Object>(0); // unsafe initializion below\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n//  Managed object layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                       Memory manager block                     \n// \n//                               next                          C  = nextWithColor\n// \n//                               prev                             \n// \n//                               rtId                             \n// \n//                               rtSize                           \n// >ptr\n//                                ...                             \n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Tests if this object is pointerfree. */\n  get isPointerfree(): bool {\n    let rtId = this.rtId;\n    // 0: Object, 1: ArrayBuffer, 2: String\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    let next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    let prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this == iter) iter = assert(this.prev);\n    this.unlink();\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\n  }\n}\n\n/** Visits all objects considered to be program roots. */\nfunction visitRoots(cookie: u32): void {\n  __visit_globals(cookie);\n  let pn = pinSpace;\n  let iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\n    iter = iter.next;\n  }\n}\n\n/** Visits all objects on the stack. */\nfunction visitStack(cookie: u32): void {\n  let ptr = __stack_pointer;\n  while (ptr < __heap_base) {\n    __visit(load<usize>(ptr), cookie);\n    ptr += sizeof<usize>();\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): usize {\n  // Magic constants responsible for pause times. Obtained experimentally\n  // using the compiler compiling itself. 2048 budget pro run by default.\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\n  let obj: Object;\n  switch (state) {\n    case STATE_IDLE: {\n      state = STATE_MARK;\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      iter = toSpace;\n      return visitCount * MARKCOST;\n    }\n    case STATE_MARK: {\n      let black = i32(!white);\n      obj = iter.next;\n      while (obj != toSpace) {\n        iter = obj;\n        if (obj.color != black) { // skip already-blacks (pointerfree)\n          obj.color = black;\n          visitCount = 0;\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          return visitCount * MARKCOST;\n        }\n        obj = obj.next;\n      }\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      obj = iter.next;\n      if (obj == toSpace) {\n        visitStack(VISIT_SCAN);\n        obj = iter.next;\n        while (obj != toSpace) {\n          if (obj.color != black) {\n            obj.color = black;\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          }\n          obj = obj.next;\n        }\n        let from = fromSpace;\n        fromSpace = toSpace;\n        toSpace = from;\n        white = black;\n        iter = from.next;\n        state = STATE_SWEEP;\n      }\n      return visitCount * MARKCOST;\n    }\n    case STATE_SWEEP: {\n      obj = iter;\n      if (obj != toSpace) {\n        iter = obj.next;\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\n        free(obj);\n        return SWEEPCOST;\n      }\n      toSpace.nextWithColor = changetype<usize>(toSpace);\n      toSpace.prev = toSpace;\n      state = STATE_IDLE;\n      break;\n    }\n  }\n  return 0;\n}\n\n/** Frees an object. */\nfunction free(obj: Object): void {\n  if (changetype<usize>(obj) < __heap_base) {\n    obj.nextWithColor = 0; // may become linked again\n    obj.prev = changetype<Object>(0);\n  } else {\n    total -= obj.size;\n    if (isDefined(__finalize)) {\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\n    }\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  if (total >= threshold) interrupt();\n  let obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white); // inits next/prev\n  total += obj.size;\n  let ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\n  // may be visited before being fully initialized, so must fill\n  memory.fill(ptr, 0, size);\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  let oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  // Update object size if its block is large enough\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\n    oldObj.rtSize = <u32>size;\n    return oldPtr;\n  }\n  // If not the same object anymore, we have to move it move it due to the\n  // shadow stack potentially still referencing the old object\n  let newPtr = __new(size, oldObj.rtId);\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // Write barrier is unnecessary if non-incremental\n  if (!childPtr) return;\n  if (DEBUG) assert(parentPtr);\n  let child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\n  if (child.color == white) {\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\n    let parentColor = parent.color;\n    if (parentColor == i32(!white)) {\n      // Maintain the invariant that no black object may point to a white object.\n      if (expectMultiple) {\n        // Move the barrier \"backward\". Suitable for containers receiving multiple stores.\n        // Avoids a barrier for subsequent objects stored into the same container.\n        parent.makeGray();\n      } else {\n        // Move the barrier \"forward\". Suitable for objects receiving isolated stores.\n        child.makeGray();\n      }\n    } else if (parentColor == transparent && state == STATE_MARK) {\n      // Pinned objects are considered 'black' during the mark phase.\n      child.makeGray();\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let visitCount = 0;\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.makeGray();\n    ++visitCount;\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  if (state == STATE_MARK) {\n    // We may be right at the point after marking roots for the second time and\n    // entering the sweep phase, in which case the object would be missed if it\n    // is not only pinned but also a root. Make sure it isn't missed.\n    obj.makeGray();\n  } else {\n    obj.unlink();\n    obj.linkTo(fromSpace, white);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC (full) at\", 1, total);\n  if (state > STATE_IDLE) {\n    // finish current cycle\n    while (state != STATE_IDLE) step();\n  }\n  // perform a full cycle\n  step();\n  while (state != STATE_IDLE) step();\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n  if (TRACE) trace(\"GC (full) done at cur/max\", 2, total, memory.size() << 16);\n  if (RTRACE || PROFILE) oncollect(total);\n}\n\n// Garbage collector automation\n\n/** How often to interrupt. The default of 1024 means \"interrupt each 1024 bytes allocated\". */\n// @ts-ignore: decorator\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\n/** How long to interrupt. The default of 200% means \"run at double the speed of allocations\". */\n// @ts-ignore: decorator\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\n/** How long to idle. The default of 200% means \"wait for memory to double before kicking in again\". */\n// @ts-ignore: decorator\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\n\n/** Threshold of memory used by objects to exceed before interrupting again. */\n// @ts-ignore: decorator\n@lazy let threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\n\n/** Performs a reasonable amount of incremental GC steps. */\nfunction interrupt(): void {\n  if (PROFILE) oninterrupt(total);\n  if (TRACE) trace(\"GC (auto) at\", 1, total);\n  let budget: isize = GRANULARITY * STEPFACTOR / 100;\n  do {\n    budget -= step();\n    if (state == STATE_IDLE) {\n      if (TRACE) trace(\" GC (auto) done at cur/max\", 2, total, memory.size() << 16);\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n      if (PROFILE) onyield(total);\n      return;\n    }\n  } while (budget > 0);\n  if (TRACE) trace(\" GC (auto) ongoing at\", 1, total);\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\n  if (PROFILE) onyield(total);\n}\n","import {\r\n  proc_exit,\r\n  fd_write,\r\n  iovec,\r\n  random_get\r\n} from \"./bindings/wasi_snapshot_preview1\";\r\n\r\n// A WASI-wide reusable temporary buffer to store and work with out values. Must\r\n// be large enough to fit any operation it is used in, i.e. process/writeString.\r\n// @ts-ignore: decorator\r\n@lazy export const tempbuf = memory.data(4 * sizeof<usize>());\r\n\r\nimport {\r\n  MAX_DOUBLE_LENGTH,\r\n  decimalCount32,\r\n  dtoa_buffered\r\n} from \"util/number\";\r\n\r\nexport function wasi_abort(\r\n  message: string | null = null,\r\n  fileName: string | null = null,\r\n  lineNumber: u32 = 0,\r\n  columnNumber: u32 = 0\r\n): void {\r\n  // 0: iov.buf\r\n  // 4: iov.buf_len\r\n  // 8: len\r\n  // 12: buf...\r\n  const iovPtr: usize = 0;\r\n  const lenPtr: usize = iovPtr + offsetof<iovec>();\r\n  const bufPtr: usize = lenPtr + sizeof<usize>();\r\n  changetype<iovec>(iovPtr).buf = bufPtr;\r\n  var ptr = bufPtr;\r\n  store<u64>(ptr, 0x203A74726F6261); ptr += 7; // 'abort: '\r\n  if (message != null) {\r\n    ptr += String.UTF8.encodeUnsafe(changetype<usize>(message), message.length, ptr);\r\n  }\r\n  store<u32>(ptr, 0x206E6920); ptr += 4; // ' in '\r\n  if (fileName != null) {\r\n    ptr += String.UTF8.encodeUnsafe(changetype<usize>(fileName), fileName.length, ptr);\r\n  }\r\n  store<u8>(ptr++, 0x28); // (\r\n  var len = decimalCount32(lineNumber); ptr += len;\r\n  do {\r\n    let t = lineNumber / 10;\r\n    store<u8>(--ptr, 0x30 + lineNumber % 10);\r\n    lineNumber = t;\r\n  } while (lineNumber); ptr += len;\r\n  store<u8>(ptr++, 0x3A); // :\r\n  len = decimalCount32(columnNumber); ptr += len;\r\n  do {\r\n    let t = columnNumber / 10;\r\n    store<u8>(--ptr, 0x30 + columnNumber % 10);\r\n    columnNumber = t;\r\n  } while (columnNumber); ptr += len;\r\n  store<u16>(ptr, 0x0A29); ptr += 2; // )\\n\r\n  changetype<iovec>(iovPtr).buf_len = ptr - bufPtr;\r\n  fd_write(2, iovPtr, 1, lenPtr);\r\n  proc_exit(255);\r\n}\r\n\r\nexport function wasi_trace(\r\n  message: string,\r\n  n: i32 = 0,\r\n  a0: f64 = 0,\r\n  a1: f64 = 0,\r\n  a2: f64 = 0,\r\n  a3: f64 = 0,\r\n  a4: f64 = 0\r\n): void {\r\n  // 0: iov.buf\r\n  // 4: iov.buf_len\r\n  // 8: len\r\n  // 12: buf...\r\n  var iovPtr = __alloc(offsetof<iovec>() + sizeof<usize>() + 1 + <usize>(max(String.UTF8.byteLength(message), MAX_DOUBLE_LENGTH << 1)));\r\n  var lenPtr = iovPtr + offsetof<iovec>();\r\n  var bufPtr = lenPtr + sizeof<usize>();\r\n  changetype<iovec>(iovPtr).buf = bufPtr;\r\n  store<u64>(bufPtr, 0x203A6563617274); // 'trace: '\r\n  changetype<iovec>(iovPtr).buf_len = 7;\r\n  fd_write(2, iovPtr, 1, lenPtr);\r\n  changetype<iovec>(iovPtr).buf_len = String.UTF8.encodeUnsafe(changetype<usize>(message), message.length, bufPtr);\r\n  fd_write(2, iovPtr, 1, lenPtr);\r\n  if (n) {\r\n    store<u8>(bufPtr++, 0x20); // space\r\n    changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a0), bufPtr);\r\n    fd_write(2, iovPtr, 1, lenPtr);\r\n    if (n > 1) {\r\n      changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a1), bufPtr);\r\n      fd_write(2, iovPtr, 1, lenPtr);\r\n      if (n > 2) {\r\n        changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a2), bufPtr);\r\n        fd_write(2, iovPtr, 1, lenPtr);\r\n        if (n > 3) {\r\n          changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a3), bufPtr);\r\n          fd_write(2, iovPtr, 1, lenPtr);\r\n          if (n > 4) {\r\n            changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a4), bufPtr);\r\n            fd_write(2, iovPtr, 1, lenPtr);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    --bufPtr;\r\n  }\r\n  store<u8>(bufPtr, 0x0A); // \\n\r\n  changetype<iovec>(iovPtr).buf_len = 1;\r\n  fd_write(2, iovPtr, 1, lenPtr);\r\n  __free(iovPtr);\r\n}\r\n\r\nexport function wasi_seed(): f64 {\r\n  var rand: u64;\r\n  do {\r\n    random_get(tempbuf, 8);\r\n    rand = load<u64>(tempbuf);\r\n  } while (!rand);\r\n  return reinterpret<f64>(rand);\r\n}\r\n","// Phase: wasi_snapshot_preview1\r\n// See: https://github.com/WebAssembly/WASI/tree/main/phases/snapshot/witx\r\n\r\n// helper types to be more explicit\r\ntype char = u8;\r\ntype ptr<T> = usize; // all pointers are usize'd\r\ntype struct<T> = T;  // structs are references already in AS\r\n\r\n/** Read command-line argument data. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function args_get(\r\n  /** Input: Pointer to a buffer to write the argument pointers. */\r\n  argv: ptr<ptr<char>>,\r\n  /** Input: Pointer to a buffer to write the argument string data. */\r\n  argv_buf: ptr<char>\r\n): errno;\r\n\r\n/** Return command-line argument data sizes. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function args_sizes_get(\r\n  /** Output: Number of arguments. */\r\n  argc: ptr<usize>,\r\n  /** Output: Size of the argument string data. */\r\n  argv_buf_size: ptr<usize>\r\n): errno;\r\n\r\n/** Return the resolution of a clock. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function clock_res_get(\r\n  /** Input: The clock for which to return the resolution. */\r\n  clock: clockid,\r\n  /** Output: The resolution of the clock. */\r\n  resolution: ptr<timestamp>\r\n): errno;\r\n\r\n/** Return the time value of a clock. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function clock_time_get(\r\n  /** Input: Cock for which to return the time. */\r\n  clock: clockid,\r\n  /** Input: Maximum lag (exclusive) that the returned time value may have, compared to its actual value. */\r\n  precision: timestamp,\r\n  /** Output: Time value of the clock. */\r\n  time: ptr<timestamp>\r\n): errno;\r\n\r\n/** Read environment variable data. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function environ_get(\r\n  /** Input: Pointer to a buffer to write the environment variable pointers. */\r\n  environ: ptr<usize>,\r\n  /** Input: Pointer to a buffer to write the environment variable string data. */\r\n  environ_buf: usize\r\n): errno;\r\n\r\n/** Return command-line argument data sizes. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function environ_sizes_get(\r\n  /** Output: The number of environment variables. */\r\n  environ_count: ptr<usize>,\r\n  /** Output: The size of the environment variable string data. */\r\n  environ_buf_size: ptr<usize>\r\n): errno;\r\n\r\n/** Provide file advisory information on a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_advise(\r\n  /** Input: The file descriptor for the file for which to provide file advisory information. */\r\n  fd: fd,\r\n  /** Input: The offset within the file to which the advisory applies. */\r\n  offset: filesize,\r\n  /** Input: The length of the region to which the advisory applies. */\r\n  len: filesize,\r\n  /** Input: The advice. */\r\n  advice: advice\r\n): errno;\r\n\r\n/** Provide file advisory information on a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_allocate(\r\n  /** Input: The file descriptor for the file in which to allocate space. */\r\n  fd: fd,\r\n  /** Input: The offset at which to start the allocation. */\r\n  offset: filesize,\r\n  /** Input: The length of the area that is allocated. */\r\n  len: filesize\r\n): errno;\r\n\r\n/** Close a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_close(\r\n  /** Input: The file descriptor to close. */\r\n  fd: fd\r\n): errno;\r\n\r\n/** Synchronize the data of a file to disk. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_datasync(\r\n  /** Input: The file descriptor of the file to synchronize to disk. */\r\n  fd: fd\r\n): errno;\r\n\r\n/** Get the attributes of a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_fdstat_get(\r\n  /** Input: The file descriptor to inspect. */\r\n  fd: fd,\r\n  /** Input: The buffer where the file descriptor's attributes are stored. */\r\n  buf: struct<fdstat>\r\n): errno;\r\n\r\n/** Adjust the flags associated with a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_fdstat_set_flags(\r\n  /** Input: The file descriptor to operate on. */\r\n  fd: fd,\r\n  /** Input: The desired values of the file descriptor flags. */\r\n  flags: fdflags\r\n): errno;\r\n\r\n/** Adjust the rights associated with a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_fdstat_set_rights(\r\n  /** Input: The file descriptor to operate on. */\r\n  fd: fd,\r\n  /** Input: The desired rights of the file descriptor. */\r\n  fs_rights_base: rights,\r\n  /** Input: The desired rights of the file descriptor. */\r\n  fs_rights_inheriting: rights\r\n): errno;\r\n\r\n/** Return the attributes of an open file. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_filestat_get(\r\n  /** Input: The file descriptor to inspect. */\r\n  fd: fd,\r\n  /** Input: The buffer where the file's attributes are stored. */\r\n  buf: struct<filestat>\r\n): errno;\r\n\r\n/** Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_filestat_set_size(\r\n  /** Input: A file descriptor for the file to adjust. */\r\n  fd: fd,\r\n  /** Input: The desired file size. */\r\n  size: filesize\r\n): errno;\r\n\r\n/** Adjust the timestamps of an open file or directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_filestat_set_times(\r\n  /** Input: The file descriptor to operate on. */\r\n  fd: fd,\r\n  /** Input: The desired values of the data access timestamp. */\r\n  st_atim: timestamp,\r\n  /** Input: The desired values of the data modification timestamp. */\r\n  st_mtim: timestamp,\r\n  /** Input: A bitmask indicating which timestamps to adjust. */\r\n  fstflags: fstflags\r\n): errno;\r\n\r\n/** Read from a file descriptor, without using and updating the file descriptor's offset. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_pread(\r\n  /** Input: The file descriptor from which to read data. */\r\n  fd: fd,\r\n  /** Input: List of scatter/gather vectors in which to store data. */\r\n  iovs: ptr<struct<iovec>>,\r\n  /** Input: Length of the list of scatter/gather vectors in which to store data. */\r\n  iovs_len: usize,\r\n  /** Input: The offset within the file at which to read. */\r\n  offset: filesize,\r\n  /** Output: The number of bytes read. */\r\n  nread: ptr<usize>\r\n): errno;\r\n\r\n/** Return a description of the given preopened file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_prestat_get(\r\n  /** Input: The file descriptor about which to retrieve information. */\r\n  fd: fd,\r\n  /** Input: The buffer where the description is stored. */\r\n  buf: struct<prestat>\r\n): errno;\r\n\r\n/** Return a description of the given preopened file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_prestat_dir_name(\r\n  /** Input: The file descriptor about which to retrieve information. */\r\n  fd: fd,\r\n  /** Input: Buffer into which to write the preopened directory name. */\r\n  path: ptr<char>,\r\n  /** Input: Length of the buffer into which to write the preopened directory name. */\r\n  path_len: usize\r\n): errno;\r\n\r\n/** Write to a file descriptor, without using and updating the file descriptor's offset. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_pwrite(\r\n  /** Input: The file descriptor to which to write data. */\r\n  fd: fd,\r\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\r\n  iovs: ptr<struct<iovec>>,\r\n  /** Input: Length of the list of scatter/gather vectors from which to retrieve data. */\r\n  iovs_len: usize,\r\n  /** Input: The offset within the file at which to write. */\r\n  offset: filesize,\r\n  /** Output: The number of bytes written. */\r\n  nwritten: ptr<usize>\r\n): errno;\r\n\r\n/** Read from a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_read(\r\n  /** Input: The file descriptor from which to read data. */\r\n  fd: fd,\r\n  /** Input: List of scatter/gather vectors to which to store data. */\r\n  iovs: ptr<struct<iovec>>,\r\n  /** Input: Length of the list of scatter/gather vectors to which to store data. */\r\n  iovs_len: usize,\r\n  /** Output: The number of bytes read. */\r\n  nread: ptr<usize>\r\n): errno;\r\n\r\n/** Read directory entries from a directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_readdir(\r\n  /** Input: Directory from which to read the directory entries. */\r\n  fd: fd,\r\n  /** Input: Buffer where directory entries are stored. */\r\n  buf: ptr<struct<dirent>>,\r\n  /** Input: Length of the buffer where directory entries are stored. */\r\n  buf_len: usize,\r\n  /** Input: Location within the directory to start reading. */\r\n  cookie: dircookie,\r\n  /** Output: Number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached. */\r\n  buf_used: ptr<usize>\r\n): errno;\r\n\r\n/** Atomically replace a file descriptor by renumbering another file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_renumber(\r\n  /** Input: The file descriptor to renumber. */\r\n  from: fd,\r\n  /** Input: The file descriptor to overwrite. */\r\n  to: fd\r\n): errno;\r\n\r\n/** Move the offset of a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_seek(\r\n  /** Input: The file descriptor to operate on. */\r\n  fd: fd,\r\n  /** Input: The number of bytes to move. */\r\n  offset: filedelta,\r\n  /** Input: The base from which the offset is relative. */\r\n  whence: whence,\r\n  /** Output: The new offset of the file descriptor, relative to the start of the file. */\r\n  newoffset: ptr<filesize>\r\n): errno;\r\n\r\n/** Synchronize the data and metadata of a file to disk. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_sync(\r\n  /** Input: The file descriptor of the file containing the data and metadata to synchronize to disk. */\r\n  fd: fd\r\n): errno;\r\n\r\n/** Return the current offset of a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_tell(\r\n  /** Input: The file descriptor to inspect. */\r\n  fd: fd,\r\n  /** Output: The current offset of the file descriptor, relative to the start of the file. */\r\n  newoffset: ptr<filesize>\r\n): errno;\r\n\r\n/** Write to a file descriptor. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function fd_write(\r\n  /** Input: The file descriptor to which to write data. */\r\n  fd: fd,\r\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\r\n  iovs: ptr<struct<iovec>>,\r\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\r\n  iovs_len: usize,\r\n  /** Output: The number of bytes written. */\r\n  nwritten: ptr<usize>\r\n): errno;\r\n\r\n/* Create a directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_create_directory(\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  fd: fd,\r\n  /** Input: The path at which to create the directory. */\r\n  path: ptr<char>,\r\n  /** Input: The path at which to create the directory. */\r\n  path_len: usize\r\n): errno;\r\n\r\n/** Return the attributes of a file or directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_filestat_get(\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  fd: fd,\r\n  /** Input: Flags determining the method of how the path is resolved. */\r\n  flags: lookupflags,\r\n  /** Input: The path of the file or directory to inspect. */\r\n  path: ptr<char>,\r\n  /** Input: The path of the file or directory to inspect. */\r\n  path_len: usize,\r\n  /** Input: The buffer where the file's attributes are stored. */\r\n  buf: struct<filestat>\r\n): errno;\r\n\r\n/** Adjust the timestamps of a file or directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_filestat_set_times(\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  fd: fd,\r\n  /** Input: Flags determining the method of how the path is resolved. */\r\n  flags: lookupflags,\r\n  /** Input: The path of the file or directory to operate on. */\r\n  path: ptr<char>,\r\n  /** Input: The path of the file or directory to operate on. */\r\n  path_len: usize,\r\n  /** Input: The desired values of the data access timestamp. */\r\n  st_atim: timestamp,\r\n  /** Input: The desired values of the data modification timestamp. */\r\n  st_mtim: timestamp,\r\n  /** Input: A bitmask indicating which timestamps to adjust. */\r\n  fstflags: fstflags\r\n): errno;\r\n\r\n/** Create a hard link. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_link(\r\n  /** Input: The working directory at which the resolution of the old path starts. */\r\n  old_fd: fd,\r\n  /** Input: Flags determining the method of how the path is resolved. */\r\n  old_flags: lookupflags,\r\n  /** Input: The source path from which to link. */\r\n  old_path: ptr<char>,\r\n  /** Input: The source path from which to link. */\r\n  old_path_len: usize,\r\n  /** Input: The working directory at which the resolution of the new path starts. */\r\n  new_fd: fd,\r\n  /** Input: The destination path at which to create the hard link. */\r\n  new_path: ptr<char>,\r\n  /** Input: The length of the destination path at which to create the hard link. */\r\n  new_path_len: usize\r\n): errno;\r\n\r\n/** Open a file or directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_open(\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  dirfd: fd,\r\n  /** Input: Flags determining the method of how the path is resolved. */\r\n  dirflags: lookupflags,\r\n  /** Input: The path of the file or directory to open. */\r\n  path: ptr<char>,\r\n  /** Input: The length of the path of the file or directory to open. */\r\n  path_len: usize,\r\n  /** Input: The method by which to open the file. */\r\n  oflags: oflags,\r\n  /** Input: The initial base rights that apply to operations using the file descriptor itself. */\r\n  fs_rights_base: rights,\r\n  /** Input: The initial inheriting rights that apply to file descriptors derived from it. */\r\n  fs_rights_inheriting: rights,\r\n  /** Input: The initial flags of the file descriptor. */\r\n  fs_flags: fdflags,\r\n  /** Output: The file descriptor of the file that has been opened. */\r\n  fd: ptr<fd>\r\n): errno;\r\n\r\n/** Read the contents of a symbolic link. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_readlink(\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  fd: fd,\r\n  /** Input: The path of the symbolic link from which to read. */\r\n  path: ptr<char>,\r\n  /** Input: The length of the path of the symbolic link from which to read. */\r\n  path_len: usize,\r\n  /** Input: The buffer to which to write the contents of the symbolic link. */\r\n  buf: ptr<char>,\r\n  /** Input: The length of the buffer to which to write the contents of the symbolic link. */\r\n  buf_len: usize,\r\n  /** Output: The number of bytes placed in the buffer. */\r\n  buf_used: ptr<usize>\r\n): errno;\r\n\r\n/** Remove a directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_remove_directory(\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  fd: fd,\r\n  /** Input: The path to a directory to remove. */\r\n  path: ptr<char>,\r\n  /** Input: The length of the path to a directory to remove. */\r\n  path_len: usize\r\n): errno;\r\n\r\n/** Rename a file or directory. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_rename(\r\n  /** Input: The working directory at which the resolution of the old path starts. */\r\n  old_fd: fd,\r\n  /** Input: The source path of the file or directory to rename. */\r\n  old_path: ptr<char>,\r\n  /** Input: The length of the source path of the file or directory to rename. */\r\n  old_path_len: usize,\r\n  /** Input: The working directory at which the resolution of the new path starts. */\r\n  new_fd: fd,\r\n  /** Input: The destination path to which to rename the file or directory. */\r\n  new_path: ptr<char>,\r\n  /** Input: The length of the destination path to which to rename the file or directory. */\r\n  new_path_len: usize\r\n): errno;\r\n\r\n/** Create a symbolic link. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_symlink(\r\n  /** Input: The contents of the symbolic link. */\r\n  old_path: ptr<char>,\r\n  /** Input: The length of the contents of the symbolic link. */\r\n  old_path_len: usize,\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  fd: fd,\r\n  /** Input: The destination path at which to create the symbolic link. */\r\n  new_path: ptr<char>,\r\n  /** Input: The length of the destination path at which to create the symbolic link. */\r\n  new_path_len: usize\r\n): errno;\r\n\r\n/** Unlink a file. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function path_unlink_file(\r\n  /** Input: The working directory at which the resolution of the path starts. */\r\n  fd: fd,\r\n  /** Input: The path to a file to unlink. */\r\n  path: ptr<char>,\r\n  /** Input: The length of the path to a file to unlink. */\r\n  path_len: usize\r\n): errno;\r\n\r\n/** Concurrently poll for the occurrence of a set of events. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function poll_oneoff(\r\n  /** Input: The events to which to subscribe. */\r\n  in_: ptr<struct<subscription>>,\r\n  /** Input: The events that have occurred. */\r\n  out: ptr<struct<event>>,\r\n  /** Input: Both the number of subscriptions and events. */\r\n  nsubscriptions: usize,\r\n  /** Output: The number of events stored. */\r\n  nevents: ptr<usize>\r\n): errno;\r\n\r\n/** Terminate the process normally. An exit code of 0 indicates successful termination of the program. The meanings of other values is dependent on the environment. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function proc_exit(\r\n  /** Input: The exit code returned by the process. */\r\n  rval: u32\r\n): void;\r\n\r\n/** Send a signal to the process of the calling thread. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function proc_raise(\r\n  /** Input: The signal condition to trigger. */\r\n  sig: signal\r\n): errno;\r\n\r\n/** Write high-quality random data into a buffer. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function random_get(\r\n  /** Input: The buffer to fill with random data. */\r\n  buf: usize,\r\n  /** Input: The length of the buffer to fill with random data. */\r\n  buf_len: usize\r\n): errno;\r\n\r\n/** Temporarily yield execution of the calling thread. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function sched_yield(): errno;\r\n\r\n/** Receive a message from a socket. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function sock_recv(\r\n  /** Input: The socket on which to receive data. */\r\n  sock: fd,\r\n  /** Input: List of scatter/gather vectors to which to store data. */\r\n  ri_data: ptr<struct<iovec>>,\r\n  /** Input: The length of the list of scatter/gather vectors to which to store data. */\r\n  ri_data_len: usize,\r\n  /** Input: Message flags. */\r\n  ri_flags: riflags,\r\n  /** Output: Number of bytes stored in `ri_data`. */\r\n  ro_datalen: ptr<usize>,\r\n  /** Output: Message flags. */\r\n  ro_flags: ptr<roflags>\r\n): errno;\r\n\r\n/** Send a message on a socket. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function sock_send(\r\n  /** Input: The socket on which to send data. */\r\n  sock: fd,\r\n  /** Input: List of scatter/gather vectors to which to retrieve data */\r\n  si_data: ptr<struct<iovec>>,\r\n  /** Input: The length of the list of scatter/gather vectors to which to retrieve data */\r\n  si_data_len: usize,\r\n  /** Input: Message flags. */\r\n  si_flags: siflags,\r\n  /** Output: Number of bytes transmitted. */\r\n  so_datalen: ptr<usize>\r\n): errno;\r\n\r\n/** Shut down socket send and receive channels. */\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport declare function sock_shutdown(\r\n  /** Input: The socket on which to shutdown channels. */\r\n  sock: fd,\r\n  /** Input: Which channels on the socket to shut down. */\r\n  how: sdflags\r\n): errno;\r\n\r\n// === Types ======================================================================================\r\n\r\n/** File or memory access pattern advisory information. */\r\nexport namespace advice {\r\n  /** The application has no advice to give on its behavior with respect to the specified data. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NORMAL: advice = 0;\r\n  /** The application expects to access the specified data sequentially from lower offsets to higher offsets. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SEQUENTIAL : advice = 1;\r\n  /** The application expects to access the specified data in a random order. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const RANDOM: advice = 2;\r\n  /** The application expects to access the specified data in the near future. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const WILLNEED: advice = 3;\r\n  /** The application expects that it will not access the specified data in the near future. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DONTNEED: advice = 4;\r\n  /** The application expects to access the specified data once and then not reuse it thereafter. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOREUSE: advice = 5;\r\n}\r\nexport type advice = u8;\r\n\r\n/** Identifiers for clocks. */\r\nexport namespace clockid {\r\n  /** The clock measuring real time. Time value zero corresponds with 1970-01-01T00:00:00Z. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const REALTIME: clockid = 0;\r\n  /** The store-wide monotonic clock. Absolute value has no meaning. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const MONOTONIC: clockid = 1;\r\n  /** The CPU-time clock associated with the current process. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PROCESS_CPUTIME_ID: clockid = 2;\r\n  /** The CPU-time clock associated with the current thread. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const THREAD_CPUTIME_ID: clockid = 3;\r\n}\r\nexport type clockid = u32;\r\n\r\n/** Identifier for a device containing a file system. Can be used in combination with `inode` to uniquely identify a file or directory in the filesystem. */\r\nexport type device = u64;\r\n\r\n/** A reference to the offset of a directory entry. The value 0 signifies the start of the directory. */\r\nexport type dircookie = u64;\r\n\r\n/** A directory entry. */\r\n@unmanaged export class dirent {\r\n  /** The offset of the next directory entry stored in this directory. */\r\n  next: dircookie;\r\n  /** The serial number of the file referred to by this directory entry. */\r\n  ino: inode;\r\n  /** The length of the name of the directory entry. */\r\n  namlen: u32;\r\n  /** The type of the file referred to by this directory entry. */\r\n  type: filetype;\r\n  private __padding0: u16;\r\n}\r\n\r\n/** Error codes returned by functions. */\r\nexport namespace errno {\r\n  /** No error occurred. System call completed successfully. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SUCCESS: errno = 0;\r\n  /** Argument list too long. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TOOBIG: errno = 1;\r\n  /** Permission denied. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ACCES: errno = 2;\r\n  /** Address in use. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ADDRINUSE: errno = 3;\r\n  /** Address not available. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ADDRNOTAVAIL: errno = 4;\r\n  /** Address family not supported. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const AFNOSUPPORT: errno = 5;\r\n  /** Resource unavailable, or operation would block. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const AGAIN: errno = 6;\r\n  /** Connection already in progress. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ALREADY: errno = 7;\r\n  /** Bad file descriptor. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const BADF: errno = 8;\r\n  /** Bad message. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const BADMSG: errno = 9;\r\n  /** Device or resource busy. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const BUSY: errno = 10;\r\n  /** Operation canceled. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CANCELED: errno = 11;\r\n  /** No child processes. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CHILD: errno = 12;\r\n  /** Connection aborted. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CONNABORTED: errno = 13;\r\n  /** Connection refused. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CONNREFUSED: errno = 14;\r\n  /** Connection reset. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CONNRESET: errno = 15;\r\n  /** Resource deadlock would occur. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DEADLK: errno = 16;\r\n  /** Destination address required. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DESTADDRREQ: errno = 17;\r\n  /** Mathematics argument out of domain of function. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DOM: errno = 18;\r\n  /** Reserved. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DQUOT: errno = 19;\r\n  /** File exists. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const EXIST: errno = 20;\r\n  /** Bad address. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FAULT: errno = 21;\r\n  /** File too large. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FBIG: errno = 22;\r\n  /** Host is unreachable. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const HOSTUNREACH: errno = 23;\r\n  /** Identifier removed. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const IDRM: errno = 24;\r\n  /** Illegal byte sequence. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ILSEQ: errno = 25;\r\n  /** Operation in progress. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const INPROGRESS: errno = 26;\r\n  /** Interrupted function. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const INTR: errno = 27;\r\n  /** Invalid argument. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const INVAL: errno = 28;\r\n  /** I/O error. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const IO: errno = 29;\r\n  /** Socket is connected. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ISCONN: errno = 30;\r\n  /** Is a directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ISDIR: errno = 31;\r\n  /** Too many levels of symbolic links. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const LOOP: errno = 32;\r\n  /** File descriptor value too large. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const MFILE: errno = 33;\r\n  /** Too many links. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const MLINK: errno = 34;\r\n  /** Message too large. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const MSGSIZE: errno = 35;\r\n  /** Reserved. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const MULTIHOP: errno = 36;\r\n  /** Filename too long. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NAMETOOLONG: errno = 37;\r\n  /** Network is down. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NETDOWN: errno = 38;\r\n  /** Connection aborted by network. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NETRESET: errno = 39;\r\n  /** Network unreachable. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NETUNREACH: errno = 40;\r\n  /** Too many files open in system. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NFILE: errno = 41;\r\n  /** No buffer space available. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOBUFS: errno = 42;\r\n  /** No such device. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NODEV: errno = 43;\r\n  /** No such file or directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOENT: errno = 44;\r\n  /** Executable file format error. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOEXEC: errno = 45;\r\n  /** No locks available. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOLCK: errno = 46;\r\n  /** Reserved. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOLINK: errno = 47;\r\n  /** Not enough space. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOMEM: errno = 48;\r\n  /** No message of the desired type. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOMSG: errno = 49;\r\n  /** Protocol not available. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOPROTOOPT: errno = 50;\r\n  /** No space left on device. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOSPC: errno = 51;\r\n  /** Function not supported. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOSYS: errno = 52;\r\n  /** The socket is not connected. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTCONN: errno = 53;\r\n  /** Not a directory or a symbolic link to a directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTDIR: errno = 54;\r\n  /** Directory not empty. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTEMPTY: errno = 55;\r\n  /** State not recoverable. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTRECOVERABLE: errno = 56;\r\n  /** Not a socket. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTSOCK: errno = 57;\r\n  /** Not supported, or operation not supported on socket. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTSUP: errno = 58;\r\n  /** Inappropriate I/O control operation. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTTY: errno = 59;\r\n  /** No such device or address. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NXIO: errno = 60;\r\n  /** Value too large to be stored in data type. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const OVERFLOW: errno = 61;\r\n  /** Previous owner died. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const OWNERDEAD: errno = 62;\r\n  /** Operation not permitted. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PERM: errno = 63;\r\n  /** Broken pipe. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PIPE: errno = 64;\r\n  /** Protocol error. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PROTO: errno = 65;\r\n  /** Protocol not supported. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PROTONOSUPPORT: errno = 66;\r\n  /** Protocol wrong type for socket. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PROTOTYPE: errno = 67;\r\n  /** Result too large. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const RANGE: errno = 68;\r\n  /** Read-only file system. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ROFS: errno = 69;\r\n  /** Invalid seek. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SPIPE: errno = 70;\r\n  /** No such process. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SRCH: errno = 71;\r\n  /** Reserved. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const STALE: errno = 72;\r\n  /** Connection timed out. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TIMEDOUT: errno = 73;\r\n  /** Text file busy. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TXTBSY: errno = 74;\r\n  /** Cross-device link. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const XDEV: errno = 75;\r\n  /** Extension: Capabilities insufficient. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NOTCAPABLE: errno = 76;\r\n}\r\nexport type errno = u16;\r\n\r\n/** Translates an error code to a string. */\r\nexport function errnoToString(err: errno): string {\r\n  switch (err) {\r\n    case errno.SUCCESS: return \"SUCCESS\";\r\n    case errno.TOOBIG: return \"TOOBIG\";\r\n    case errno.ACCES: return \"ACCES\";\r\n    case errno.ADDRINUSE: return \"ADDRINUSE\";\r\n    case errno.ADDRNOTAVAIL: return \"ADDRNOTAVAIL\";\r\n    case errno.AFNOSUPPORT: return \"AFNOSUPPORT\";\r\n    case errno.AGAIN: return \"AGAIN\";\r\n    case errno.ALREADY: return \"ALREADY\";\r\n    case errno.BADF: return \"BADF\";\r\n    case errno.BADMSG: return \"BADMSG\";\r\n    case errno.BUSY: return \"BUSY\";\r\n    case errno.CANCELED: return \"CANCELED\";\r\n    case errno.CHILD: return \"CHILD\";\r\n    case errno.CONNABORTED: return \"CONNABORTED\";\r\n    case errno.CONNREFUSED: return \"CONNREFUSED\";\r\n    case errno.CONNRESET: return \"CONNRESET\";\r\n    case errno.DEADLK: return \"DEADLK\";\r\n    case errno.DESTADDRREQ: return \"DESTADDRREQ\";\r\n    case errno.DOM: return \"DOM\";\r\n    case errno.DQUOT: return \"DQUOT\";\r\n    case errno.EXIST: return \"EXIST\";\r\n    case errno.FAULT: return \"FAULT\";\r\n    case errno.FBIG: return \"FBIG\";\r\n    case errno.HOSTUNREACH: return \"HOSTUNREACH\";\r\n    case errno.IDRM: return \"IDRM\";\r\n    case errno.ILSEQ: return \"ILSEQ\";\r\n    case errno.INPROGRESS: return \"INPROGRESS\";\r\n    case errno.INTR: return \"INTR\";\r\n    case errno.INVAL: return \"INVAL\";\r\n    case errno.IO: return \"IO\";\r\n    case errno.ISCONN: return \"ISCONN\";\r\n    case errno.ISDIR: return \"ISDIR\";\r\n    case errno.LOOP: return \"LOOP\";\r\n    case errno.MFILE: return \"MFILE\";\r\n    case errno.MLINK: return \"MLINK\";\r\n    case errno.MSGSIZE: return \"MSGSIZE\";\r\n    case errno.MULTIHOP: return \"MULTIHOP\";\r\n    case errno.NAMETOOLONG: return \"NAMETOOLONG\";\r\n    case errno.NETDOWN: return \"NETDOWN\";\r\n    case errno.NETRESET: return \"NETRESET\";\r\n    case errno.NETUNREACH: return \"NETUNREACH\";\r\n    case errno.NFILE: return \"NFILE\";\r\n    case errno.NOBUFS: return \"NOBUFS\";\r\n    case errno.NODEV: return \"NODEV\";\r\n    case errno.NOENT: return \"NOENT\";\r\n    case errno.NOEXEC: return \"NOEXEC\";\r\n    case errno.NOLCK: return \"NOLCK\";\r\n    case errno.NOLINK: return \"NOLINK\";\r\n    case errno.NOMEM: return \"NOMEM\";\r\n    case errno.NOMSG: return \"NOMSG\";\r\n    case errno.NOPROTOOPT: return \"NOPROTOOPT\";\r\n    case errno.NOSPC: return \"NOSPC\";\r\n    case errno.NOSYS: return \"NOSYS\";\r\n    case errno.NOTCONN: return \"NOTCONN\";\r\n    case errno.NOTDIR: return \"NOTDIR\";\r\n    case errno.NOTEMPTY: return \"NOTEMPTY\";\r\n    case errno.NOTRECOVERABLE: return \"NOTRECOVERABLE\";\r\n    case errno.NOTSOCK: return \"NOTSOCK\";\r\n    case errno.NOTSUP: return \"NOTSUP\";\r\n    case errno.NOTTY: return \"NOTTY\";\r\n    case errno.NXIO: return \"NXIO\";\r\n    case errno.OVERFLOW: return \"OVERFLOW\";\r\n    case errno.OWNERDEAD: return \"OWNERDEAD\";\r\n    case errno.PERM: return \"PERM\";\r\n    case errno.PIPE: return \"PIPE\";\r\n    case errno.PROTO: return \"PROTO\";\r\n    case errno.PROTONOSUPPORT: return \"PROTONOSUPPORT\";\r\n    case errno.PROTOTYPE: return \"PROTOTYPE\";\r\n    case errno.RANGE: return \"RANGE\";\r\n    case errno.ROFS: return \"ROFS\";\r\n    case errno.SPIPE: return \"SPIPE\";\r\n    case errno.SRCH: return \"SRCH\";\r\n    case errno.STALE: return \"STALE\";\r\n    case errno.TIMEDOUT: return \"TIMEDOUT\";\r\n    case errno.TXTBSY: return \"TXTBSY\";\r\n    case errno.XDEV: return \"XDEV\";\r\n    case errno.NOTCAPABLE: return \"NOTCAPABLE\";\r\n  }\r\n  return \"UNKNOWN\";\r\n}\r\n\r\n@unmanaged abstract class $event { // size=16/32\r\n  /** User-provided value that got attached to `subscription#userdata`. */\r\n  userdata: userdata;\r\n  /** If non-zero, an error that occurred while processing the subscription request. */\r\n  error: errno;\r\n  /** The type of the event that occurred. */\r\n  type: eventtype;\r\n\r\n  private __padding0: u16;\r\n}\r\n\r\n/** An event that occurred. */\r\n@unmanaged export abstract class event extends $event {\r\n  private __padding1: u64;\r\n  private __padding2: u64;\r\n}\r\n\r\n/** An event that occurred when type is `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\r\n@unmanaged export class event_fd_readwrite extends $event {\r\n  /* The number of bytes available for reading or writing. */\r\n  nbytes: filesize;\r\n  /* The state of the file descriptor. */\r\n  flags: eventrwflags;\r\n\r\n  private __padding1: u32;\r\n}\r\n\r\n/** The state of the file descriptor subscribed to with `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\r\nexport namespace eventrwflags {\r\n  /** The peer of this socket has closed or disconnected. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const HANGUP: eventrwflags = 1;\r\n}\r\nexport type eventrwflags = u16;\r\n\r\n/** Type of a subscription to an event or its occurrence. */\r\nexport namespace eventtype {\r\n  /** The time value of clock has reached the timestamp. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CLOCK: eventtype = 0;\r\n  /** File descriptor has data available for reading. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_READ: eventtype = 1;\r\n  /** File descriptor has capacity available for writing */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_WRITE: eventtype = 2;\r\n}\r\nexport type eventtype = u8;\r\n\r\n/** Exit code generated by a process when exiting. */\r\nexport type exitcode = u32;\r\n\r\n/** A file descriptor number. */\r\nexport type fd = u32;\r\n\r\n/** File descriptor flags. */\r\nexport namespace fdflags {\r\n  /** Append mode: Data written to the file is always appended to the file's end. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const APPEND: fdflags = 1;\r\n  /** Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DSYNC: fdflags = 2;\r\n  /** Non-blocking mode. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const NONBLOCK: fdflags = 4;\r\n  /** Synchronized read I/O operations. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const RSYNC: fdflags = 8;\r\n  /** Write according to synchronized I/O file integrity completion. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SYNC: fdflags = 16;\r\n}\r\nexport type fdflags = u16;\r\n\r\n/** File descriptor attributes. */\r\n@unmanaged export class fdstat {\r\n  /** File type. */\r\n  filetype: filetype;\r\n  /** File descriptor flags. */\r\n  flags: fdflags;\r\n  /** Rights that apply to this file descriptor. */\r\n  rights_base: rights;\r\n  /** Maximum set of rights that may be installed on new file descriptors that are created through this file descriptor, e.g., through `path_open`. */\r\n  rights_inheriting: rights;\r\n}\r\n\r\n/** Relative offset within a file. */\r\nexport type filedelta = i64;\r\n\r\n/** Non-negative file size or length of a region within a file. */\r\nexport type filesize = u64;\r\n\r\n/** File attributes. */\r\n@unmanaged export class filestat {\r\n  /** Device ID of device containing the file. */\r\n  dev: device;\r\n  /** File serial number. */\r\n  ino: inode;\r\n  /** File type. */\r\n  filetype: filetype;\r\n  /** Number of hard links to the file. */\r\n  nlink: linkcount;\r\n  /** For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link. */\r\n  size: filesize;\r\n  /** Last data access timestamp. */\r\n  atim: timestamp;\r\n  /** Last data modification timestamp. */\r\n  mtim: timestamp;\r\n  /** Last file status change timestamp. */\r\n  ctim: timestamp;\r\n}\r\n\r\n/** The type of a file descriptor or file. */\r\nexport namespace filetype {\r\n  /** The type of the file descriptor or file is unknown or is different from any of the other types specified. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const UNKNOWN: filetype = 0;\r\n  /** The file descriptor or file refers to a block device inode. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const BLOCK_DEVICE: filetype = 1;\r\n  /** The file descriptor or file refers to a character device inode. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CHARACTER_DEVICE: filetype = 2;\r\n  /** The file descriptor or file refers to a directory inode. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DIRECTORY: filetype = 3;\r\n  /** The file descriptor or file refers to a regular file inode. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const REGULAR_FILE: filetype = 4;\r\n  /** The file descriptor or file refers to a datagram socket. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SOCKET_DGRAM: filetype = 5;\r\n  /** The file descriptor or file refers to a byte-stream socket. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SOCKET_STREAM: filetype = 6;\r\n  /** The file refers to a symbolic link inode. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SYMBOLIC_LINK: filetype = 7;\r\n}\r\nexport type filetype = u8;\r\n\r\n/** Which file time attributes to adjust. */\r\nexport namespace fstflags {\r\n  /** Adjust the last data access timestamp to the value stored in `filestat#st_atim`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SET_ATIM: fstflags = 1;\r\n  /** Adjust the last data access timestamp to the time of clock `clockid.REALTIME`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SET_ATIM_NOW: fstflags = 2;\r\n  /** Adjust the last data modification timestamp to the value stored in `filestat#st_mtim`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SET_MTIM: fstflags = 4;\r\n  /** Adjust the last data modification timestamp to the time of clock `clockid.REALTIME`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SET_MTIM_NOW: fstflags = 8;\r\n}\r\nexport type fstflags = u16;\r\n\r\n/** File serial number that is unique within its file system. */\r\nexport type inode = u64;\r\n\r\n/** A region of memory for scatter/gather reads. */\r\n@unmanaged export class iovec {\r\n  /** The address of the buffer to be filled. */\r\n  buf: usize;\r\n  /** The length of the buffer to be filled. */\r\n  buf_len: usize;\r\n}\r\n\r\n/** Number of hard links to an inode. */\r\nexport type linkcount = u64;\r\n\r\n/** Flags determining the method of how paths are resolved. */\r\nexport namespace lookupflags {\r\n  /** As long as the resolved path corresponds to a symbolic link, it is expanded. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SYMLINK_FOLLOW: lookupflags = 1;\r\n}\r\nexport type lookupflags = u32;\r\n\r\n/** Open flags. */\r\nexport namespace oflags {\r\n  /** Create file if it does not exist. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CREAT: oflags = 1;\r\n  /** Fail if not a directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DIRECTORY: oflags = 2;\r\n  /** Fail if file already exists. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const EXCL: oflags = 4;\r\n  /** Truncate file to size 0. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TRUNC: oflags = 8;\r\n}\r\nexport type oflags = u16;\r\n\r\n/** Identifiers for preopened capabilities. */\r\nexport namespace preopentype {\r\n  /** A pre-opened directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DIR: preopentype = 0;\r\n}\r\nexport type preopentype = u8;\r\n\r\n@unmanaged abstract class $prestat { // WASM32: size=1/8, WASM64: size=1/16\r\n  /* The type of the pre-opened capability. */\r\n  type: preopentype;\r\n}\r\n\r\n/* Information about a pre-opened capability. */\r\n@unmanaged export abstract class prestat extends $prestat {\r\n  private __padding0: usize;\r\n}\r\n\r\n/** The contents of a $prestat when type is `preopentype.DIR`. */\r\n@unmanaged export class prestat_dir extends $prestat {\r\n  /** The length of the directory name for use with `fd_prestat_dir_name`. */\r\n  name_len: usize;\r\n}\r\n\r\n/** Flags provided to `sock_recv`. */\r\nexport namespace riflags {\r\n  /** Returns the message without removing it from the socket's receive queue. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PEEK: riflags = 1;\r\n  /** On byte-stream sockets, block until the full amount of data can be returned. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const WAITALL: riflags = 2;\r\n}\r\nexport type riflags = u16;\r\n\r\n/** File descriptor rights, determining which actions may be performed. */\r\nexport namespace rights {\r\n  /** The right to invoke `fd_datasync`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_DATASYNC: rights = 1;\r\n  /** The right to invoke `fd_read` and `sock_recv`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_READ: rights = 2;\r\n  /** The right to invoke `fd_seek`. This flag implies `rights.FD_TELL`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_SEEK: rights = 4;\r\n  /** The right to invoke `fd_fdstat_set_flags`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_FDSTAT_SET_FLAGS: rights = 8;\r\n  /** The right to invoke `fd_sync`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_SYNC: rights = 16;\r\n  /** The right to invoke `fd_seek` in such a way that the file offset remains unaltered (i.e., `whence.CUR` with offset zero), or to invoke `fd_tell`). */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_TELL: rights = 32;\r\n  /** The right to invoke `fd_write` and `sock_send`. If `rights.FD_SEEK` is set, includes the right to invoke `fd_pwrite`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_WRITE: rights = 64;\r\n  /** The right to invoke `fd_advise`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_ADVISE: rights = 128;\r\n  /** The right to invoke `fd_allocate`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_ALLOCATE: rights = 256;\r\n  /** The right to invoke `path_create_directory`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_CREATE_DIRECTORY: rights = 512;\r\n  /** If `rights.PATH_OPEN` is set, the right to invoke `path_open` with `oflags.CREAT`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_CREATE_FILE: rights = 1024;\r\n  /** The right to invoke `path_link` with the file descriptor as the source directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_LINK_SOURCE: rights = 2048;\r\n  /** The right to invoke `path_link` with the file descriptor as the target directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_LINK_TARGET: rights = 4096;\r\n  /** The right to invoke `path_open`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_OPEN: rights = 8192;\r\n  /** The right to invoke `fd_readdir`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_READDIR: rights = 16384;\r\n  /** The right to invoke `path_readlink`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_READLINK: rights = 32768;\r\n  /** The right to invoke `path_rename` with the file descriptor as the source directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_RENAME_SOURCE: rights = 65536;\r\n  /** The right to invoke `path_rename` with the file descriptor as the target directory. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_RENAME_TARGET: rights = 131072;\r\n  /** The right to invoke `path_filestat_get`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_FILESTAT_GET: rights = 262144;\r\n  /** The right to change a file's size (there is no `path_filestat_set_size`). If `rights.PATH_OPEN` is set, includes the right to invoke `path_open` with `oflags.TRUNC`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_FILESTAT_SET_SIZE: rights = 524288;\r\n  /** The right to invoke `path_filestat_set_times`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_FILESTAT_SET_TIMES: rights = 1048576;\r\n  /** The right to invoke `fd_filestat_get`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_FILESTAT_GET: rights = 2097152;\r\n  /** The right to invoke `fd_filestat_set_size`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_FILESTAT_SET_SIZE: rights = 4194304;\r\n  /** The right to invoke `fd_filestat_set_times`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FD_FILESTAT_SET_TIMES: rights = 8388608;\r\n  /** The right to invoke `path_symlink`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const RIGHT_PATH_SYMLINK: rights = 16777216;\r\n  /** The right to invoke `path_remove_directory`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_REMOVE_DIRECTORY: rights = 33554432;\r\n  /** The right to invoke `path_unlink_file`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PATH_UNLINK_FILE: rights = 67108864;\r\n  /** If `rights.FD_READ` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_READ`. If `rights.FD_WRITE` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_WRITE`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const POLL_FD_READWRITE: rights = 134217728;\r\n  /** The right to invoke `sock_shutdown`. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SOCK_SHUTDOWN: rights = 268435456;\r\n}\r\nexport type rights = u64;\r\n\r\n/** Flags returned by `sock_recv`. */\r\nexport namespace roflags {\r\n  /** Message data has been truncated. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const DATA_TRUNCATED: roflags = 1;\r\n}\r\nexport type roflags = u16;\r\n\r\n/** Which channels on a socket to shut down. */\r\nexport namespace sdflags {\r\n  /** Disables further receive operations. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const RD: sdflags = 1;\r\n  /** Disables further send operations. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const WR: sdflags = 2;\r\n}\r\nexport type sdflags = u8;\r\n\r\n/** Flags provided to `sock_send`. */\r\nexport namespace siflags {\r\n  // As there are currently no flags defined, it must be set to zero.\r\n}\r\nexport type siflags = u16;\r\n\r\n/** Signal condition. */\r\nexport namespace signal {\r\n  /** Hangup. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const HUP: signal = 1;\r\n  /** Terminate interrupt signal. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const INT: signal = 2;\r\n  /** Terminal quit signal. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const QUIT: signal = 3;\r\n  /** Illegal instruction. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ILL: signal = 4;\r\n  /** Trace/breakpoint trap. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TRAP: signal = 5;\r\n  /** Process abort signal. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ABRT: signal = 6;\r\n  /** Access to an undefined portion of a memory object. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const BUS: signal = 7;\r\n  /** Erroneous arithmetic operation. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const FPE: signal = 8;\r\n  /** Kill. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const KILL: signal = 9;\r\n  /** User-defined signal 1. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const USR1: signal = 10;\r\n  /** Invalid memory reference. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SEGV: signal = 11;\r\n  /** User-defined signal 2. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const USR2: signal = 12;\r\n  /** Write on a pipe with no one to read it. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PIPE: signal = 13;\r\n  /** Alarm clock. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ALRM: signal = 14;\r\n  /** Termination signal. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TERM: signal = 15;\r\n  /** Child process terminated, stopped, or continued. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CHLD: signal = 16;\r\n  /** Continue executing, if stopped. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CONT: signal = 17;\r\n  /** Stop executing. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const STOP: signal = 18;\r\n  /** Terminal stop signal. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TSTP: signal = 19;\r\n  /** Background process attempting read. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TTIN: signal = 20;\r\n  /** Background process attempting write. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const TTOU: signal = 21;\r\n  /** High bandwidth data is available at a socket. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const URG: signal = 22;\r\n  /** CPU time limit exceeded. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const XCPU: signal = 23;\r\n  /** File size limit exceeded. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const XFSZ: signal = 24;\r\n  /** Virtual timer expired. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const VTALRM: signal = 25;\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PROF: signal = 26;\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const WINCH: signal = 27;\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const POLL: signal = 28;\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const PWR: signal = 29;\r\n  /** Bad system call. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SYS: signal = 30;\r\n}\r\nexport type signal = u8;\r\n\r\n/** Flags determining how to interpret the timestamp provided in `subscription_t::u.clock.timeout. */\r\nexport namespace subclockflags {\r\n  /** If set, treat the timestamp provided in `clocksubscription` as an absolute timestamp. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const ABSTIME: subclockflags = 1;\r\n}\r\nexport type subclockflags = u16;\r\n\r\n@unmanaged abstract class $subscription { // size=16/48\r\n  /** User-provided value that is attached to the subscription. */\r\n  userdata: userdata;\r\n  /** The type of the event to which to subscribe. */\r\n  type: eventtype;\r\n\r\n  private __padding0: u32;\r\n}\r\n\r\n/** Subscription to an event. */\r\n@unmanaged export abstract class subscription extends $subscription {\r\n  private __padding1: u64;\r\n  private __padding2: u64;\r\n  private __padding3: u64;\r\n  private __padding4: u64;\r\n}\r\n\r\n/* Subscription to an event of type `eventtype.CLOCK`.**/\r\n@unmanaged export class subscription_clock extends $subscription {\r\n  /** The clock against which to compare the timestamp. */\r\n  clock_id: clockid;\r\n  /** The absolute or relative timestamp. */\r\n  timeout: timestamp;\r\n  /** The amount of time that the implementation may wait additionally to coalesce with other events. */\r\n  precision: timestamp;\r\n  /** Flags specifying whether the timeout is absolute or relative. */\r\n  flags: subclockflags;\r\n\r\n  private __padding1: u32;\r\n}\r\n\r\n/* Subscription to an event of type `eventtype.FD_READ` or `eventtype.FD_WRITE`.**/\r\n@unmanaged export class subscription_fd_readwrite extends $subscription {\r\n  /** The file descriptor on which to wait for it to become ready for reading or writing. */\r\n  file_descriptor: fd;\r\n\r\n  private __padding1: u64;\r\n  private __padding2: u64;\r\n  private __padding3: u64;\r\n}\r\n\r\n/** Timestamp in nanoseconds. */\r\nexport type timestamp = u64;\r\n\r\n/** User-provided value that may be attached to objects that is retained when extracted from the implementation. */\r\nexport type userdata = u64;\r\n\r\n/** The position relative to which to set the offset of the file descriptor. */\r\nexport namespace whence {\r\n  /** Seek relative to start-of-file. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const SET: whence = 0;\r\n  /** Seek relative to current position. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const CUR: whence = 1;\r\n  /** Seek relative to end-of-file. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export const END: whence = 2;\r\n}\r\n\r\nexport type whence = u8;\r\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  let kd = xd + shift;\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  let z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  let kd = <f64>(z + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = z - (kd - shift);\n  let s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFDEFEC65B963019, // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  0x3FF571ED4AAF883D, 0xBFDB0B6832D4FCA4, // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  0x3FF49539F0F010B0, 0xBFD7418B0A1FB77B, // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  0x3FF3C995B0B80385, 0xBFD39DE91A6DCF7B, // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  0x3FF30D190C8864A5, 0xBFD01D9BF3F2B631, // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  0x3FF25E227B0B8EA0, 0xBFC97C1D1B3B7AF0, // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  0x3FF1BB4A4A1A343F, 0xBFC2F9E393AF3C9F, // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  0x3FF12358F08AE5BA, 0xBFB960CBBF788D5C, // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  0x3FF0953F419900A7, 0xBFAA6F9DB6475FCE, // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0x0,\n  0x3FEE608CFD9A47AC, 0x3FB338CA9F24F53D, // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  0x3FECA4B31F026AA0, 0x3FC476A9543891BA, // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  0x3FEB2036576AFCE6, 0x3FCE840B4AC4E4D2, // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  0x3FE9C2D163A1AA2D, 0x3FD40645F0C6651C, // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  0x3FE886E6037841ED, 0x3FD88E9C2C1B9FF8, // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  0x3FE767DCF5534862, 0x3FDCE0A44EB17BCC  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  let top  = tmp & 0xFF800000;\n  let iz   = ux - top;\n  let k    = <i32>tmp >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y  = A1 * r + A2;\n  let p  = A3 * r + y0;\n  let r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFD57BF7808CAADE, // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  0x3FF571ED4AAF883D, 0xBFD2BEF0A7C06DDB, // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  0x3FF49539F0F010B0, 0xBFD01EAE7F513A67, // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  0x3FF3C995B0B80385, 0xBFCB31D8A68224E9, // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  0x3FF30D190C8864A5, 0xBFC6574F0AC07758, // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  0x3FF25E227B0B8EA0, 0xBFC1AA2BC79C8100, // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  0x3FF1BB4A4A1A343F, 0xBFBA4E76CE8C0E5E, // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  0x3FF12358F08AE5BA, 0xBFB1973C5A611CCC, // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  0x3FF0953F419900A7, 0xBFA252F438E10C1E, // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0,\n  0x3FEE608CFD9A47AC, 0x3FAAA5AA5DF25984, // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  0x3FECA4B31F026AA0, 0x3FBC5E53AA362EB4, // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  0x3FEB2036576AFCE6, 0x3FC526E57720DB08, // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  0x3FE9C2D163A1AA2D, 0x3FCBC2860D224770, // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  0x3FE886E6037841ED, 0x3FD1058BC8A07EE1, // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  0x3FE767DCF5534862, 0x3FD4043057B6EE09  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ux - 0x3F330000;\n  let i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  let k   = <i32>tmp >> 23;\n  let iz  = ux - (tmp & 0x1FF << 23);\n\n  let invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  let z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  let r = z * invc - 1;\n  let y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  let r2 = r * r;\n  let y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  let e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = usize((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  let top  = tmp & 0xFF800000;\n  let uz   = ux - top;\n  let k    = <i32>top >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y = A0 * r + A1;\n  let p = A2 * r + A3;\n  let q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  let kd = <f64>(xd + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  let signBias: u32 = 0;\n  let ix = reinterpret<u32>(x);\n  let iy = reinterpret<u32>(y);\n  let ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return <i32>iy < 0 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (<i32>ix < 0) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  let logx = log2f_inline(ix);\n  let ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  let scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  let y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) {\n        return 1.0 + x;\n      } else {\n        return select<f64>(0, Infinity, <i64>ux < 0);\n      }\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  let z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // let kd = z + shift;\n  // let ki = reinterpret<u64>(kd) >> 16;\n  // let kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  let kd = z + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  let r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  let scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  let y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7ff;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (<i64>ux >= 0) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  let kd = x + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  let r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<u64>([\n  //     invc       ,        logc\n  0x3FF724286BB1ACF8, 0xBFE1095FEECDB000,\n  0x3FF6E1F766D2CCA1, 0xBFE08494BD76D000,\n  0x3FF6A13D0E30D48A, 0xBFE00143AEE8F800,\n  0x3FF661EC32D06C85, 0xBFDEFEC5360B4000,\n  0x3FF623FA951198F8, 0xBFDDFDD91AB7E000,\n  0x3FF5E75BA4CF026C, 0xBFDCFFAE0CC79000,\n  0x3FF5AC055A214FB8, 0xBFDC043811FDA000,\n  0x3FF571ED0F166E1E, 0xBFDB0B67323AE000,\n  0x3FF53909590BF835, 0xBFDA152F5A2DB000,\n  0x3FF5014FED61ADDD, 0xBFD9217F5AF86000,\n  0x3FF4CAB88E487BD0, 0xBFD8304DB0719000,\n  0x3FF49539B4334FEE, 0xBFD74189F9A9E000,\n  0x3FF460CBDFAFD569, 0xBFD6552BB5199000,\n  0x3FF42D664EE4B953, 0xBFD56B23A29B1000,\n  0x3FF3FB01111DD8A6, 0xBFD483650F5FA000,\n  0x3FF3C995B70C5836, 0xBFD39DE937F6A000,\n  0x3FF3991C4AB6FD4A, 0xBFD2BAA1538D6000,\n  0x3FF3698E0CE099B5, 0xBFD1D98340CA4000,\n  0x3FF33AE48213E7B2, 0xBFD0FA853A40E000,\n  0x3FF30D191985BDB1, 0xBFD01D9C32E73000,\n  0x3FF2E025CAB271D7, 0xBFCE857DA2FA6000,\n  0x3FF2B404CF13CD82, 0xBFCCD3C8633D8000,\n  0x3FF288B02C7CCB50, 0xBFCB26034C14A000,\n  0x3FF25E2263944DE5, 0xBFC97C1C2F4FE000,\n  0x3FF234563D8615B1, 0xBFC7D6023F800000,\n  0x3FF20B46E33EAF38, 0xBFC633A71A05E000,\n  0x3FF1E2EEFDCDA3DD, 0xBFC494F5E9570000,\n  0x3FF1BB4A580B3930, 0xBFC2F9E424E0A000,\n  0x3FF19453847F2200, 0xBFC162595AFDC000,\n  0x3FF16E06C0D5D73C, 0xBFBF9C9A75BD8000,\n  0x3FF1485F47B7E4C2, 0xBFBC7B575BF9C000,\n  0x3FF12358AD0085D1, 0xBFB960C60FF48000,\n  0x3FF0FEF00F532227, 0xBFB64CE247B60000,\n  0x3FF0DB2077D03A8F, 0xBFB33F78B2014000,\n  0x3FF0B7E6D65980D9, 0xBFB0387D1A42C000,\n  0x3FF0953EFE7B408D, 0xBFAA6F9208B50000,\n  0x3FF07325CAC53B83, 0xBFA47A954F770000,\n  0x3FF05197E40D1B5C, 0xBF9D23A8C50C0000,\n  0x3FF03091C1208EA2, 0xBF916A2629780000,\n  0x3FF0101025B37E21, 0xBF7720F8D8E80000,\n  0x3FEFC07EF9CAA76B, 0x3F86FE53B1500000,\n  0x3FEF4465D3F6F184, 0x3FA11CCCE10F8000,\n  0x3FEECC079F84107F, 0x3FAC4DFC8C8B8000,\n  0x3FEE573A99975AE8, 0x3FB3AA321E574000,\n  0x3FEDE5D6F0BD3DE6, 0x3FB918A0D08B8000,\n  0x3FED77B681FF38B3, 0x3FBE72E9DA044000,\n  0x3FED0CB5724DE943, 0x3FC1DCD2507F6000,\n  0x3FECA4B2DC0E7563, 0x3FC476AB03DEA000,\n  0x3FEC3F8EE8D6CB51, 0x3FC7074377E22000,\n  0x3FEBDD2B4F020C4C, 0x3FC98EDE8BA94000,\n  0x3FEB7D6C006015CA, 0x3FCC0DB86AD2E000,\n  0x3FEB20366E2E338F, 0x3FCE840AAFCEE000,\n  0x3FEAC57026295039, 0x3FD0790AB4678000,\n  0x3FEA6D01BC2731DD, 0x3FD1AC056801C000,\n  0x3FEA16D3BC3FF18B, 0x3FD2DB11D4FEE000,\n  0x3FE9C2D14967FEAD, 0x3FD406464EC58000,\n  0x3FE970E4F47C9902, 0x3FD52DBE093AF000,\n  0x3FE920FB3982BCF2, 0x3FD651902050D000,\n  0x3FE8D30187F759F1, 0x3FD771D2CDEAF000,\n  0x3FE886E5EBB9F66D, 0x3FD88E9C857D9000,\n  0x3FE83C97B658B994, 0x3FD9A80155E16000,\n  0x3FE7F405FFC61022, 0x3FDABE186ED3D000,\n  0x3FE7AD22181415CA, 0x3FDBD0F2AEA0E000,\n  0x3FE767DCF99EFF8C, 0x3FDCE0A43DBF4000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE6200012B90A8E, 0x3C8904AB0644B605,\n  0x3FE66000045734A6, 0x3C61FF9BEA62F7A9,\n  0x3FE69FFFC325F2C5, 0x3C827ECFCB3C90BA,\n  0x3FE6E00038B95A04, 0x3C88FF8856739326,\n  0x3FE71FFFE09994E3, 0x3C8AFD40275F82B1,\n  0x3FE7600015590E10, 0xBC72FD75B4238341,\n  0x3FE7A00012655BD5, 0x3C7808E67C242B76,\n  0x3FE7E0003259E9A6, 0xBC6208E426F622B7,\n  0x3FE81FFFEDB4B2D2, 0xBC8402461EA5C92F,\n  0x3FE860002DFAFCC3, 0x3C6DF7F4A2F29A1F,\n  0x3FE89FFFF78C6B50, 0xBC8E0453094995FD,\n  0x3FE8E00039671566, 0xBC8A04F3BEC77B45,\n  0x3FE91FFFE2BF1745, 0xBC77FA34400E203C,\n  0x3FE95FFFCC5C9FD1, 0xBC76FF8005A0695D,\n  0x3FE9A0003BBA4767, 0x3C70F8C4C4EC7E03,\n  0x3FE9DFFFE7B92DA5, 0x3C8E7FD9478C4602,\n  0x3FEA1FFFD72EFDAF, 0xBC6A0C554DCDAE7E,\n  0x3FEA5FFFDE04FF95, 0x3C867DA98CE9B26B,\n  0x3FEA9FFFCA5E8D2B, 0xBC8284C9B54C13DE,\n  0x3FEADFFFDDAD03EA, 0x3C5812C8EA602E3C,\n  0x3FEB1FFFF10D3D4D, 0xBC8EFADDAD27789C,\n  0x3FEB5FFFCE21165A, 0x3C53CB1719C61237,\n  0x3FEB9FFFD950E674, 0x3C73F7D94194CE00,\n  0x3FEBE000139CA8AF, 0x3C750AC4215D9BC0,\n  0x3FEC20005B46DF99, 0x3C6BEEA653E9C1C9,\n  0x3FEC600040B9F7AE, 0xBC7C079F274A70D6,\n  0x3FECA0006255FD8A, 0xBC7A0B4076E84C1F,\n  0x3FECDFFFD94C095D, 0x3C88F933F99AB5D7,\n  0x3FED1FFFF975D6CF, 0xBC582C08665FE1BE,\n  0x3FED5FFFA2561C93, 0xBC7B04289BD295F3,\n  0x3FED9FFF9D228B0C, 0x3C870251340FA236,\n  0x3FEDE00065BC7E16, 0xBC75011E16A4D80C,\n  0x3FEE200002F64791, 0x3C89802F09EF62E0,\n  0x3FEE600057D7A6D8, 0xBC7E0B75580CF7FA,\n  0x3FEEA00027EDC00C, 0xBC8C848309459811,\n  0x3FEEE0006CF5CB7C, 0xBC8F8027951576F4,\n  0x3FEF2000782B7DCC, 0xBC8F81D97274538F,\n  0x3FEF6000260C450A, 0xBC4071002727FFDC,\n  0x3FEF9FFFE88CD533, 0xBC581BDCE1FDA8B0,\n  0x3FEFDFFFD50F8689, 0x3C87F91ACB918E6E,\n  0x3FF0200004292367, 0x3C9B7FF365324681,\n  0x3FF05FFFE3E3D668, 0x3C86FA08DDAE957B,\n  0x3FF0A0000A85A757, 0xBC57E2DE80D3FB91,\n  0x3FF0E0001A5F3FCC, 0xBC91823305C5F014,\n  0x3FF11FFFF8AFBAF5, 0xBC8BFABB6680BAC2,\n  0x3FF15FFFE54D91AD, 0xBC9D7F121737E7EF,\n  0x3FF1A00011AC36E1, 0x3C9C000A0516F5FF,\n  0x3FF1E00019C84248, 0xBC9082FBE4DA5DA0,\n  0x3FF220000FFE5E6E, 0xBC88FDD04C9CFB43,\n  0x3FF26000269FD891, 0x3C8CFE2A7994D182,\n  0x3FF2A00029A6E6DA, 0xBC700273715E8BC5,\n  0x3FF2DFFFE0293E39, 0x3C9B7C39DAB2A6F9,\n  0x3FF31FFFF7DCF082, 0x3C7DF1336EDC5254,\n  0x3FF35FFFF05A8B60, 0xBC9E03564CCD31EB,\n  0x3FF3A0002E0EAECC, 0x3C75F0E74BD3A477,\n  0x3FF3E000043BB236, 0x3C9C7DCB149D8833,\n  0x3FF4200002D187FF, 0x3C7E08AFCF2D3D28,\n  0x3FF460000D387CB1, 0x3C820837856599A6,\n  0x3FF4A00004569F89, 0xBC89FA5C904FBCD2,\n  0x3FF4E000043543F3, 0xBC781125ED175329,\n  0x3FF51FFFCC027F0F, 0x3C9883D8847754DC,\n  0x3FF55FFFFD87B36F, 0xBC8709E731D02807,\n  0x3FF59FFFF21DF7BA, 0x3C87F79F68727B02,\n  0x3FF5DFFFEBFC3481, 0xBC9180902E30E93E\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & 0xFFF0000000000000);\n\n  let invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n  let kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  let chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  let clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  let r   = (z - chi - clo) * invc;\n  let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  let rlo = r - rhi;\n  let t1  = rhi * InvLn2hi;\n  let t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  let t3 = kd + logc;\n  let hi = t3 + t1;\n  let lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  let p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<u64>([\n  //      invc      ,        logc\n  0x3FF734F0C3E0DE9F, 0xBFD7CC7F79E69000,\n  0x3FF713786A2CE91F, 0xBFD76FEEC20D0000,\n  0x3FF6F26008FAB5A0, 0xBFD713E31351E000,\n  0x3FF6D1A61F138C7D, 0xBFD6B85B38287800,\n  0x3FF6B1490BC5B4D1, 0xBFD65D5590807800,\n  0x3FF69147332F0CBA, 0xBFD602D076180000,\n  0x3FF6719F18224223, 0xBFD5A8CA86909000,\n  0x3FF6524F99A51ED9, 0xBFD54F4356035000,\n  0x3FF63356AA8F24C4, 0xBFD4F637C36B4000,\n  0x3FF614B36B9DDC14, 0xBFD49DA7FDA85000,\n  0x3FF5F66452C65C4C, 0xBFD445923989A800,\n  0x3FF5D867B5912C4F, 0xBFD3EDF439B0B800,\n  0x3FF5BABCCB5B90DE, 0xBFD396CE448F7000,\n  0x3FF59D61F2D91A78, 0xBFD3401E17BDA000,\n  0x3FF5805612465687, 0xBFD2E9E2EF468000,\n  0x3FF56397CEE76BD3, 0xBFD2941B3830E000,\n  0x3FF54725E2A77F93, 0xBFD23EC58CDA8800,\n  0x3FF52AFF42064583, 0xBFD1E9E129279000,\n  0x3FF50F22DBB2BDDF, 0xBFD1956D2B48F800,\n  0x3FF4F38F4734DED7, 0xBFD141679AB9F800,\n  0x3FF4D843CFDE2840, 0xBFD0EDD094EF9800,\n  0x3FF4BD3EC078A3C8, 0xBFD09AA518DB1000,\n  0x3FF4A27FC3E0258A, 0xBFD047E65263B800,\n  0x3FF4880524D48434, 0xBFCFEB224586F000,\n  0x3FF46DCE1B192D0B, 0xBFCF474A7517B000,\n  0x3FF453D9D3391854, 0xBFCEA4443D103000,\n  0x3FF43A2744B4845A, 0xBFCE020D44E9B000,\n  0x3FF420B54115F8FB, 0xBFCD60A22977F000,\n  0x3FF40782DA3EF4B1, 0xBFCCC00104959000,\n  0x3FF3EE8F5D57FE8F, 0xBFCC202956891000,\n  0x3FF3D5D9A00B4CE9, 0xBFCB81178D811000,\n  0x3FF3BD60C010C12B, 0xBFCAE2C9CCD3D000,\n  0x3FF3A5242B75DAB8, 0xBFCA45402E129000,\n  0x3FF38D22CD9FD002, 0xBFC9A877681DF000,\n  0x3FF3755BC5847A1C, 0xBFC90C6D69483000,\n  0x3FF35DCE49AD36E2, 0xBFC87120A645C000,\n  0x3FF34679984DD440, 0xBFC7D68FB4143000,\n  0x3FF32F5CCEFFCB24, 0xBFC73CB83C627000,\n  0x3FF3187775A10D49, 0xBFC6A39A9B376000,\n  0x3FF301C8373E3990, 0xBFC60B3154B7A000,\n  0x3FF2EB4EBB95F841, 0xBFC5737D76243000,\n  0x3FF2D50A0219A9D1, 0xBFC4DC7B8FC23000,\n  0x3FF2BEF9A8B7FD2A, 0xBFC4462C51D20000,\n  0x3FF2A91C7A0C1BAB, 0xBFC3B08ABC830000,\n  0x3FF293726014B530, 0xBFC31B996B490000,\n  0x3FF27DFA5757A1F5, 0xBFC2875490A44000,\n  0x3FF268B39B1D3BBF, 0xBFC1F3B9F879A000,\n  0x3FF2539D838FF5BD, 0xBFC160C8252CA000,\n  0x3FF23EB7AAC9083B, 0xBFC0CE7F57F72000,\n  0x3FF22A012BA940B6, 0xBFC03CDC49FEA000,\n  0x3FF2157996CC4132, 0xBFBF57BDBC4B8000,\n  0x3FF201201DD2FC9B, 0xBFBE370896404000,\n  0x3FF1ECF4494D480B, 0xBFBD17983EF94000,\n  0x3FF1D8F5528F6569, 0xBFBBF9674ED8A000,\n  0x3FF1C52311577E7C, 0xBFBADC79202F6000,\n  0x3FF1B17C74CB26E9, 0xBFB9C0C3E7288000,\n  0x3FF19E010C2C1AB6, 0xBFB8A646B372C000,\n  0x3FF18AB07BB670BD, 0xBFB78D01B3AC0000,\n  0x3FF1778A25EFBCB6, 0xBFB674F145380000,\n  0x3FF1648D354C31DA, 0xBFB55E0E6D878000,\n  0x3FF151B990275FDD, 0xBFB4485CDEA1E000,\n  0x3FF13F0EA432D24C, 0xBFB333D94D6AA000,\n  0x3FF12C8B7210F9DA, 0xBFB22079F8C56000,\n  0x3FF11A3028ECB531, 0xBFB10E4698622000,\n  0x3FF107FBDA8434AF, 0xBFAFFA6C6AD20000,\n  0x3FF0F5EE0F4E6BB3, 0xBFADDA8D4A774000,\n  0x3FF0E4065D2A9FCE, 0xBFABBCECE4850000,\n  0x3FF0D244632CA521, 0xBFA9A1894012C000,\n  0x3FF0C0A77CE2981A, 0xBFA788583302C000,\n  0x3FF0AF2F83C636D1, 0xBFA5715E67D68000,\n  0x3FF09DDB98A01339, 0xBFA35C8A49658000,\n  0x3FF08CABAF52E7DF, 0xBFA149E364154000,\n  0x3FF07B9F2F4E28FB, 0xBF9E72C082EB8000,\n  0x3FF06AB58C358F19, 0xBF9A55F152528000,\n  0x3FF059EEA5ECF92C, 0xBF963D62CF818000,\n  0x3FF04949CDD12C90, 0xBF9228FB8CAA0000,\n  0x3FF038C6C6F0ADA9, 0xBF8C317B20F90000,\n  0x3FF02865137932A9, 0xBF8419355DAA0000,\n  0x3FF0182427EA7348, 0xBF781203C2EC0000,\n  0x3FF008040614B195, 0xBF60040979240000,\n  0x3FEFE01FF726FA1A, 0x3F6FEFF384900000,\n  0x3FEFA11CC261EA74, 0x3F87DC41353D0000,\n  0x3FEF6310B081992E, 0x3F93CEA3C4C28000,\n  0x3FEF25F63CEEADCD, 0x3F9B9FC114890000,\n  0x3FEEE9C8039113E7, 0x3FA1B0D8CE110000,\n  0x3FEEAE8078CBB1AB, 0x3FA58A5BD001C000,\n  0x3FEE741AA29D0C9B, 0x3FA95C8340D88000,\n  0x3FEE3A91830A99B5, 0x3FAD276AEF578000,\n  0x3FEE01E009609A56, 0x3FB07598E598C000,\n  0x3FEDCA01E577BB98, 0x3FB253F5E30D2000,\n  0x3FED92F20B7C9103, 0x3FB42EDD8B380000,\n  0x3FED5CAC66FB5CCE, 0x3FB606598757C000,\n  0x3FED272CAA5EDE9D, 0x3FB7DA76356A0000,\n  0x3FECF26E3E6B2CCD, 0x3FB9AB434E1C6000,\n  0x3FECBE6DA2A77902, 0x3FBB78C7BB0D6000,\n  0x3FEC8B266D37086D, 0x3FBD431332E72000,\n  0x3FEC5894BD5D5804, 0x3FBF0A3171DE6000,\n  0x3FEC26B533BB9F8C, 0x3FC067152B914000,\n  0x3FEBF583EEECE73F, 0x3FC147858292B000,\n  0x3FEBC4FD75DB96C1, 0x3FC2266ECDCA3000,\n  0x3FEB951E0C864A28, 0x3FC303D7A6C55000,\n  0x3FEB65E2C5EF3E2C, 0x3FC3DFC33C331000,\n  0x3FEB374867C9888B, 0x3FC4BA366B7A8000,\n  0x3FEB094B211D304A, 0x3FC5933928D1F000,\n  0x3FEADBE885F2EF7E, 0x3FC66ACD2418F000,\n  0x3FEAAF1D31603DA2, 0x3FC740F8EC669000,\n  0x3FEA82E63FD358A7, 0x3FC815C0F51AF000,\n  0x3FEA5740EF09738B, 0x3FC8E92954F68000,\n  0x3FEA2C2A90AB4B27, 0x3FC9BB3602F84000,\n  0x3FEA01A01393F2D1, 0x3FCA8BED1C2C0000,\n  0x3FE9D79F24DB3C1B, 0x3FCB5B515C01D000,\n  0x3FE9AE2505C7B190, 0x3FCC2967CCBCC000,\n  0x3FE9852EF297CE2F, 0x3FCCF635D5486000,\n  0x3FE95CBAEEA44B75, 0x3FCDC1BD3446C000,\n  0x3FE934C69DE74838, 0x3FCE8C01B8CFE000,\n  0x3FE90D4F2F6752E6, 0x3FCF5509C0179000,\n  0x3FE8E6528EFFD79D, 0x3FD00E6C121FB800,\n  0x3FE8BFCE9FCC007C, 0x3FD071B80E93D000,\n  0x3FE899C0DABEC30E, 0x3FD0D46B9E867000,\n  0x3FE87427AA2317FB, 0x3FD13687334BD000,\n  0x3FE84F00ACB39A08, 0x3FD1980D67234800,\n  0x3FE82A49E8653E55, 0x3FD1F8FFE0CC8000,\n  0x3FE8060195F40260, 0x3FD2595FD7636800,\n  0x3FE7E22563E0A329, 0x3FD2B9300914A800,\n  0x3FE7BEB377DCB5AD, 0x3FD3187210436000,\n  0x3FE79BAA679725C2, 0x3FD377266DEC1800,\n  0x3FE77907F2170657, 0x3FD3D54FFBAF3000,\n  0x3FE756CADBD6130C, 0x3FD432EEE32FE000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE61000014FB66B, 0x3C7E026C91425B3C,\n  0x3FE63000034DB495, 0x3C8DBFEA48005D41,\n  0x3FE650000D94D478, 0x3C8E7FA786D6A5B7,\n  0x3FE67000074E6FAD, 0x3C61FCEA6B54254C,\n  0x3FE68FFFFEDF0FAE, 0xBC7C7E274C590EFD,\n  0x3FE6B0000763C5BC, 0xBC8AC16848DCDA01,\n  0x3FE6D0001E5CC1F6, 0x3C833F1C9D499311,\n  0x3FE6EFFFEB05F63E, 0xBC7E80041AE22D53,\n  0x3FE710000E869780, 0x3C7BFF6671097952,\n  0x3FE72FFFFC67E912, 0x3C8C00E226BD8724,\n  0x3FE74FFFDF81116A, 0xBC6E02916EF101D2,\n  0x3FE770000F679C90, 0xBC67FC71CD549C74,\n  0x3FE78FFFFA7EC835, 0x3C81BEC19EF50483,\n  0x3FE7AFFFFE20C2E6, 0xBC707E1729CC6465,\n  0x3FE7CFFFED3FC900, 0xBC808072087B8B1C,\n  0x3FE7EFFFE9261A76, 0x3C8DC0286D9DF9AE,\n  0x3FE81000049CA3E8, 0x3C897FD251E54C33,\n  0x3FE8300017932C8F, 0xBC8AFEE9B630F381,\n  0x3FE850000633739C, 0x3C89BFBF6B6535BC,\n  0x3FE87000204289C6, 0xBC8BBF65F3117B75,\n  0x3FE88FFFEBF57904, 0xBC89006EA23DCB57,\n  0x3FE8B00022BC04DF, 0xBC7D00DF38E04B0A,\n  0x3FE8CFFFE50C1B8A, 0xBC88007146FF9F05,\n  0x3FE8EFFFFC918E43, 0x3C83817BD07A7038,\n  0x3FE910001EFA5FC7, 0x3C893E9176DFB403,\n  0x3FE9300013467BB9, 0x3C7F804E4B980276,\n  0x3FE94FFFE6EE076F, 0xBC8F7EF0D9FF622E,\n  0x3FE96FFFDE3C12D1, 0xBC7082AA962638BA,\n  0x3FE98FFFF4458A0D, 0xBC87801B9164A8EF,\n  0x3FE9AFFFDD982E3E, 0xBC8740E08A5A9337,\n  0x3FE9CFFFED49FB66, 0x3C3FCE08C19BE000,\n  0x3FE9F00020F19C51, 0xBC8A3FAA27885B0A,\n  0x3FEA10001145B006, 0x3C74FF489958DA56,\n  0x3FEA300007BBF6FA, 0x3C8CBEAB8A2B6D18,\n  0x3FEA500010971D79, 0x3C88FECADD787930,\n  0x3FEA70001DF52E48, 0xBC8F41763DD8ABDB,\n  0x3FEA90001C593352, 0xBC8EBF0284C27612,\n  0x3FEAB0002A4F3E4B, 0xBC69FD043CFF3F5F,\n  0x3FEACFFFD7AE1ED1, 0xBC823EE7129070B4,\n  0x3FEAEFFFEE510478, 0x3C6A063EE00EDEA3,\n  0x3FEB0FFFDB650D5B, 0x3C5A06C8381F0AB9,\n  0x3FEB2FFFFEAACA57, 0xBC79011E74233C1D,\n  0x3FEB4FFFD995BADC, 0xBC79FF1068862A9F,\n  0x3FEB7000249E659C, 0x3C8AFF45D0864F3E,\n  0x3FEB8FFFF9871640, 0x3C7CFE7796C2C3F9,\n  0x3FEBAFFFD204CB4F, 0xBC63FF27EEF22BC4,\n  0x3FEBCFFFD2415C45, 0xBC6CFFB7EE3BEA21,\n  0x3FEBEFFFF86309DF, 0xBC814103972E0B5C,\n  0x3FEC0FFFE1B57653, 0x3C8BC16494B76A19,\n  0x3FEC2FFFF1FA57E3, 0xBC64FEEF8D30C6ED,\n  0x3FEC4FFFDCBFE424, 0xBC843F68BCEC4775,\n  0x3FEC6FFFED54B9F7, 0x3C847EA3F053E0EC,\n  0x3FEC8FFFEB998FD5, 0x3C7383068DF992F1,\n  0x3FECB0002125219A, 0xBC68FD8E64180E04,\n  0x3FECCFFFDD94469C, 0x3C8E7EBE1CC7EA72,\n  0x3FECEFFFEAFDC476, 0x3C8EBE39AD9F88FE,\n  0x3FED1000169AF82B, 0x3C757D91A8B95A71,\n  0x3FED30000D0FF71D, 0x3C89C1906970C7DA,\n  0x3FED4FFFEA790FC4, 0xBC580E37C558FE0C,\n  0x3FED70002EDC87E5, 0xBC7F80D64DC10F44,\n  0x3FED900021DC82AA, 0xBC747C8F94FD5C5C,\n  0x3FEDAFFFD86B0283, 0x3C8C7F1DC521617E,\n  0x3FEDD000296C4739, 0x3C88019EB2FFB153,\n  0x3FEDEFFFE54490F5, 0x3C6E00D2C652CC89,\n  0x3FEE0FFFCDABF694, 0xBC7F8340202D69D2,\n  0x3FEE2FFFDB52C8DD, 0x3C7B00C1CA1B0864,\n  0x3FEE4FFFF24216EF, 0x3C72FFA8B094AB51,\n  0x3FEE6FFFE88A5E11, 0xBC57F673B1EFBE59,\n  0x3FEE9000119EFF0D, 0xBC84808D5E0BC801,\n  0x3FEEAFFFDFA51744, 0x3C780006D54320B5,\n  0x3FEED0001A127FA1, 0xBC5002F860565C92,\n  0x3FEEF00007BABCC4, 0xBC8540445D35E611,\n  0x3FEF0FFFF57A8D02, 0xBC4FFB3139EF9105,\n  0x3FEF30001EE58AC7, 0x3C8A81ACF2731155,\n  0x3FEF4FFFF5823494, 0x3C8A3F41D4D7C743,\n  0x3FEF6FFFFCA94C6B, 0xBC6202F41C987875,\n  0x3FEF8FFFE1F9C441, 0x3C777DD1F477E74B,\n  0x3FEFAFFFD2E0E37E, 0xBC6F01199A7CA331,\n  0x3FEFD0001C77E49E, 0x3C7181EE4BCEACB1,\n  0x3FEFEFFFF7E0C331, 0xBC6E05370170875A,\n  0x3FF00FFFF465606E, 0xBC8A7EAD491C0ADA,\n  0x3FF02FFFF3867A58, 0xBC977F69C3FCB2E0,\n  0x3FF04FFFFDFC0D17, 0x3C97BFFE34CB945B,\n  0x3FF0700003CD4D82, 0x3C820083C0E456CB,\n  0x3FF08FFFF9F2CBE8, 0xBC6DFFDFBE37751A,\n  0x3FF0B000010CDA65, 0xBC913F7FAEE626EB,\n  0x3FF0D00001A4D338, 0x3C807DFA79489FF7,\n  0x3FF0EFFFFADAFDFD, 0xBC77040570D66BC0,\n  0x3FF110000BBAFD96, 0x3C8E80D4846D0B62,\n  0x3FF12FFFFAE5F45D, 0x3C9DBFFA64FD36EF,\n  0x3FF150000DD59AD9, 0x3C9A0077701250AE,\n  0x3FF170000F21559A, 0x3C8DFDF9E2E3DEEE,\n  0x3FF18FFFFC275426, 0x3C910030DC3B7273,\n  0x3FF1B000123D3C59, 0x3C997F7980030188,\n  0x3FF1CFFFF8299EB7, 0xBC65F932AB9F8C67,\n  0x3FF1EFFFF48AD400, 0x3C937FBF9DA75BEB,\n  0x3FF210000C8B86A4, 0x3C9F806B91FD5B22,\n  0x3FF2300003854303, 0x3C93FFC2EB9FBF33,\n  0x3FF24FFFFFBCF684, 0x3C7601E77E2E2E72,\n  0x3FF26FFFF52921D9, 0x3C7FFCBB767F0C61,\n  0x3FF2900014933A3C, 0xBC7202CA3C02412B,\n  0x3FF2B00014556313, 0xBC92808233F21F02,\n  0x3FF2CFFFEBFE523B, 0xBC88FF7E384FDCF2,\n  0x3FF2F0000BB8AD96, 0xBC85FF51503041C5,\n  0x3FF30FFFFB7AE2AF, 0xBC810071885E289D,\n  0x3FF32FFFFEAC5F7F, 0xBC91FF5D3FB7B715,\n  0x3FF350000CA66756, 0x3C957F82228B82BD,\n  0x3FF3700011FBF721, 0x3C8000BAC40DD5CC,\n  0x3FF38FFFF9592FB9, 0xBC943F9D2DB2A751,\n  0x3FF3B00004DDD242, 0x3C857F6B707638E1,\n  0x3FF3CFFFF5B2C957, 0x3C7A023A10BF1231,\n  0x3FF3EFFFEAB0B418, 0x3C987F6D66B152B0,\n  0x3FF410001532AFF4, 0x3C67F8375F198524,\n  0x3FF4300017478B29, 0x3C8301E672DC5143,\n  0x3FF44FFFE795B463, 0x3C89FF69B8B2895A,\n  0x3FF46FFFE80475E0, 0xBC95C0B19BC2F254,\n  0x3FF48FFFEF6FC1E7, 0x3C9B4009F23A2A72,\n  0x3FF4AFFFE5BEA704, 0xBC94FFB7BF0D7D45,\n  0x3FF4D000171027DE, 0xBC99C06471DC6A3D,\n  0x3FF4F0000FF03EE2, 0x3C977F890B85531C,\n  0x3FF5100012DC4BD1, 0x3C6004657166A436,\n  0x3FF530001605277A, 0xBC96BFCECE233209,\n  0x3FF54FFFECDB704C, 0xBC8902720505A1D7,\n  0x3FF56FFFEF5F54A9, 0x3C9BBFE60EC96412,\n  0x3FF5900017E61012, 0x3C887EC581AFEF90,\n  0x3FF5B00003C93E92, 0xBC9F41080ABF0CC0,\n  0x3FF5D0001D4919BC, 0xBC98812AFB254729,\n  0x3FF5EFFFE7B87A89, 0xBC947EB780ED6904\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  let invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  let r = (z - chi - clo) * invc;\n  // #endif\n  let kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  let w  = kd * Ln2hi + logc;\n  let hi = w + r;\n  let lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<u64>([\n  //      invc      ,pad,       logc       ,       logctail\n  0x3FF6A00000000000, 0, 0xBFD62C82F2B9C800, 0x3CFAB42428375680,\n  0x3FF6800000000000, 0, 0xBFD5D1BDBF580800, 0xBD1CA508D8E0F720,\n  0x3FF6600000000000, 0, 0xBFD5767717455800, 0xBD2362A4D5B6506D,\n  0x3FF6400000000000, 0, 0xBFD51AAD872DF800, 0xBCE684E49EB067D5,\n  0x3FF6200000000000, 0, 0xBFD4BE5F95777800, 0xBD041B6993293EE0,\n  0x3FF6000000000000, 0, 0xBFD4618BC21C6000, 0x3D13D82F484C84CC,\n  0x3FF5E00000000000, 0, 0xBFD404308686A800, 0x3CDC42F3ED820B3A,\n  0x3FF5C00000000000, 0, 0xBFD3A64C55694800, 0x3D20B1C686519460,\n  0x3FF5A00000000000, 0, 0xBFD347DD9A988000, 0x3D25594DD4C58092,\n  0x3FF5800000000000, 0, 0xBFD2E8E2BAE12000, 0x3D267B1E99B72BD8,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5400000000000, 0, 0xBFD22941FBCF7800, 0xBD165A242853DA76,\n  0x3FF5200000000000, 0, 0xBFD1C898C1699800, 0xBD1FAFBC68E75404,\n  0x3FF5000000000000, 0, 0xBFD1675CABABA800, 0x3D1F1FC63382A8F0,\n  0x3FF4E00000000000, 0, 0xBFD1058BF9AE4800, 0xBD26A8C4FD055A66,\n  0x3FF4C00000000000, 0, 0xBFD0A324E2739000, 0xBD0C6BEE7EF4030E,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4800000000000, 0, 0xBFCFB9186D5E4000, 0x3D0D572AAB993C87,\n  0x3FF4600000000000, 0, 0xBFCEF0ADCBDC6000, 0x3D2B26B79C86AF24,\n  0x3FF4400000000000, 0, 0xBFCE27076E2AF000, 0xBD172F4F543FFF10,\n  0x3FF4200000000000, 0, 0xBFCD5C216B4FC000, 0x3D21BA91BBCA681B,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF3E00000000000, 0, 0xBFCBC286742D9000, 0x3D194EB0318BB78F,\n  0x3FF3C00000000000, 0, 0xBFCAF3C94E80C000, 0x3CBA4E633FCD9066,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3800000000000, 0, 0xBFC9525A9CF45000, 0xBD2AD1D904C1D4E3,\n  0x3FF3600000000000, 0, 0xBFC87FA06520D000, 0x3D2BBDBF7FDBFA09,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3200000000000, 0, 0xBFC6D60FE719D000, 0xBD10E46AA3B2E266,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF2E00000000000, 0, 0xBFC526E5E3A1B000, 0xBD20DE8B90075B8F,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2A00000000000, 0, 0xBFC371FC201E9000, 0x3CF178864D27543A,\n  0x3FF2800000000000, 0, 0xBFC29552F81FF000, 0xBD248D301771C408,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2200000000000, 0, 0xBFBFEC9131DBE000, 0xBD2575545CA333F2,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF1E00000000000, 0, 0xBFBC5E548F5BC000, 0xBD1D0C57585FBE06,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1800000000000, 0, 0xBFB6F0D28AE56000, 0xBD269737C93373DA,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1200000000000, 0, 0xBFB16536EEA38000, 0x3D147C5E768FA309,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0600000000000, 0, 0xBF97B91B07D58000, 0xBD288D5493FAA639,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FEFC00000000000, 0, 0x3F80101575890000, 0xBD10C76B999D2BE8,\n  0x3FEF800000000000, 0, 0x3F90205658938000, 0xBD23DC5B06E2F7D2,\n  0x3FEF400000000000, 0, 0x3F98492528C90000, 0xBD2AA0BA325A0C34,\n  0x3FEF000000000000, 0, 0x3FA0415D89E74000, 0x3D0111C05CF1D753,\n  0x3FEEC00000000000, 0, 0x3FA466AED42E0000, 0xBD2C167375BDFD28,\n  0x3FEE800000000000, 0, 0x3FA894AA149FC000, 0xBD197995D05A267D,\n  0x3FEE400000000000, 0, 0x3FACCB73CDDDC000, 0xBD1A68F247D82807,\n  0x3FEE200000000000, 0, 0x3FAEEA31C006C000, 0xBD0E113E4FC93B7B,\n  0x3FEDE00000000000, 0, 0x3FB1973BD1466000, 0xBD25325D560D9E9B,\n  0x3FEDA00000000000, 0, 0x3FB3BDF5A7D1E000, 0x3D2CC85EA5DB4ED7,\n  0x3FED600000000000, 0, 0x3FB5E95A4D97A000, 0xBD2C69063C5D1D1E,\n  0x3FED400000000000, 0, 0x3FB700D30AEAC000, 0x3CEC1E8DA99DED32,\n  0x3FED000000000000, 0, 0x3FB9335E5D594000, 0x3D23115C3ABD47DA,\n  0x3FECC00000000000, 0, 0x3FBB6AC88DAD6000, 0xBD1390802BF768E5,\n  0x3FECA00000000000, 0, 0x3FBC885801BC4000, 0x3D2646D1C65AACD3,\n  0x3FEC600000000000, 0, 0x3FBEC739830A2000, 0xBD2DC068AFE645E0,\n  0x3FEC400000000000, 0, 0x3FBFE89139DBE000, 0xBD2534D64FA10AFD,\n  0x3FEC000000000000, 0, 0x3FC1178E8227E000, 0x3D21EF78CE2D07F2,\n  0x3FEBE00000000000, 0, 0x3FC1AA2B7E23F000, 0x3D2CA78E44389934,\n  0x3FEBA00000000000, 0, 0x3FC2D1610C868000, 0x3D039D6CCB81B4A1,\n  0x3FEB800000000000, 0, 0x3FC365FCB0159000, 0x3CC62FA8234B7289,\n  0x3FEB400000000000, 0, 0x3FC4913D8333B000, 0x3D25837954FDB678,\n  0x3FEB200000000000, 0, 0x3FC527E5E4A1B000, 0x3D2633E8E5697DC7,\n  0x3FEAE00000000000, 0, 0x3FC6574EBE8C1000, 0x3D19CF8B2C3C2E78,\n  0x3FEAC00000000000, 0, 0x3FC6F0128B757000, 0xBD25118DE59C21E1,\n  0x3FEAA00000000000, 0, 0x3FC7898D85445000, 0xBD1C661070914305,\n  0x3FEA600000000000, 0, 0x3FC8BEAFEB390000, 0xBD073D54AAE92CD1,\n  0x3FEA400000000000, 0, 0x3FC95A5ADCF70000, 0x3D07F22858A0FF6F,\n  0x3FEA000000000000, 0, 0x3FCA93ED3C8AE000, 0xBD28724350562169,\n  0x3FE9E00000000000, 0, 0x3FCB31D8575BD000, 0xBD0C358D4EACE1AA,\n  0x3FE9C00000000000, 0, 0x3FCBD087383BE000, 0xBD2D4BC4595412B6,\n  0x3FE9A00000000000, 0, 0x3FCC6FFBC6F01000, 0xBCF1EC72C5962BD2,\n  0x3FE9600000000000, 0, 0x3FCDB13DB0D49000, 0xBD2AFF2AF715B035,\n  0x3FE9400000000000, 0, 0x3FCE530EFFE71000, 0x3CC212276041F430,\n  0x3FE9200000000000, 0, 0x3FCEF5ADE4DD0000, 0xBCCA211565BB8E11,\n  0x3FE9000000000000, 0, 0x3FCF991C6CB3B000, 0x3D1BCBECCA0CDF30,\n  0x3FE8C00000000000, 0, 0x3FD07138604D5800, 0x3CF89CDB16ED4E91,\n  0x3FE8A00000000000, 0, 0x3FD0C42D67616000, 0x3D27188B163CEAE9,\n  0x3FE8800000000000, 0, 0x3FD1178E8227E800, 0xBD2C210E63A5F01C,\n  0x3FE8600000000000, 0, 0x3FD16B5CCBACF800, 0x3D2B9ACDF7A51681,\n  0x3FE8400000000000, 0, 0x3FD1BF99635A6800, 0x3D2CA6ED5147BDB7,\n  0x3FE8200000000000, 0, 0x3FD214456D0EB800, 0x3D0A87DEBA46BAEA,\n  0x3FE7E00000000000, 0, 0x3FD2BEF07CDC9000, 0x3D2A9CFA4A5004F4,\n  0x3FE7C00000000000, 0, 0x3FD314F1E1D36000, 0xBD28E27AD3213CB8,\n  0x3FE7A00000000000, 0, 0x3FD36B6776BE1000, 0x3D116ECDB0F177C8,\n  0x3FE7800000000000, 0, 0x3FD3C25277333000, 0x3D183B54B606BD5C,\n  0x3FE7600000000000, 0, 0x3FD419B423D5E800, 0x3D08E436EC90E09D,\n  0x3FE7400000000000, 0, 0x3FD4718DC271C800, 0xBD2F27CE0967D675,\n  0x3FE7200000000000, 0, 0x3FD4C9E09E173000, 0xBD2E20891B0AD8A4,\n  0x3FE7000000000000, 0, 0x3FD522AE0738A000, 0x3D2EBE708164C759,\n  0x3FE6E00000000000, 0, 0x3FD57BF753C8D000, 0x3D1FADEDEE5D40EF,\n  0x3FE6C00000000000, 0, 0x3FD5D5BDDF596000, 0xBD0A0B2A08A465DC\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  let e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy let log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ix - 0x3fE6955500000000;\n  let i   = usize((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  let k   = <i64>tmp >> 52;\n  let iz  = ix - (tmp & u64(0xFFF) << 52);\n  let z   = reinterpret<f64>(iz);\n  let kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  let invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  let logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  let logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  let zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  let zlo = z - zhi;\n  let rhi = zhi * invc - 1.0;\n  let rlo = zlo * invc;\n  let r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  let t1  = kd * Ln2hi + logc;\n  let t2  = t1 + r;\n  let lo1 = kd * Ln2lo + logctail;\n  let lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let ar  = A0 * r; // A[0] = -0.5\n  let ar2 = r * ar;\n  let ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  let arhi  = A0  * rhi;\n  let arhi2 = rhi * arhi;\n  let hi    = t2  + arhi2;\n  let lo3   = rlo * (ar + arhi);\n  let lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  let p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  let lo = lo1 + lo2 + lo3 + lo4 + p;\n  let y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let abstop: u32;\n  let ki: u64, top: u64, sbits: u64;\n  let idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  let kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  let ux = reinterpret<u64>(x);\n  abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return <i64>ux < 0\n        ? uflow(sign_bias)\n        : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = usize((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let sign_bias: u32 = 0;\n  let ix = reinterpret<u64>(x);\n  let iy = reinterpret<u64>(y);\n  let topx = ix >> 52;\n  let topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return <i64>iy < 0 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (<i64>ix < 0) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  let hi = log_inline(ix);\n  let lo = log_tail;\n  let ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  let yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  let ylo = y - yhi;\n  let lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  let llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import {\n  itoa32,\n  utoa32,\n  itoa64,\n  utoa64,\n  dtoa,\n  itoa_buffered,\n  dtoa_buffered,\n  MAX_DOUBLE_LENGTH\n} from \"./number\";\n\nimport {\n  ipow32\n} from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  u = 0x75,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  let found = false;\n  let pos = index;\n  let minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  let maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  let c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  let ptr1 = changetype<usize>(str1) + (index1 << 1);\n  let ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  let len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  let ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  let code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  let sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  let num: T = 0;\n  let initial = len - 1;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (initial == len) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  let len = str.length;\n  if (!len) return NaN;\n\n  let ptr  = changetype<usize>(str);\n  let code = <u32>load<u16>(ptr);\n\n  let sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  let savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0.0 * sign;\n  const capacity = 19; // int(64 * 0.3010)\n  let pointed = false;\n  let consumed = 0;\n  let position = 0;\n  let x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0.0 * sign;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function strtob(str: string): bool {\n  let size: usize = str.length << 1;\n  let offset: usize = 0;\n  if (size > 8) {\n    // try trim end whitespaces first\n    while (size && isSpace(load<u16>(changetype<usize>(str) + size - 2))) size -= 2;\n    if (size > 8) {\n      // trim start whitespaces\n      while (offset < size && isSpace(load<u16>(changetype<usize>(str) + offset))) offset += 2;\n      size -= offset;\n    }\n  }\n  if (size != 8) return false;\n  // \"true\" represents as \\00\\e\\00\\u\\00\\e\\00\\t (00 65 00 75 00 72 00 74)\n  return load<u64>(changetype<usize>(str) + offset) == 0x0065_0075_0072_0074;\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  let sepLen = separator.length;\n  let valueLen = 5; // max possible length of element len(\"false\")\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  let sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  let sepLen = separator.length;\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  let estLen = 0;\n  let value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) estLen += value.length;\n  }\n  let offset = 0;\n  let sepLen = separator.length;\n  let result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (changetype<usize>(value) != 0) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  let value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value != null ? value.toString() : \"\";\n  }\n  let result = \"\";\n  let sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value != null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value != null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  let significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  let shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  let b = <u64>ipow32(5, -exp);\n  let q = significand / b;\n  let r = significand % b;\n  let s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  let shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  let sign = 1, magnitude = 0;\n  let code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy let __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  let low  = (a & 0xFFFFFFFF) * b;\n  let high = (a >> 32) * b + (low >> 32);\n  let overflow = <u32>(high >> 32);\n  let space = clz(overflow);\n  let revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  let b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  let base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = (value >>> 31) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out) + sign, value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = u32(value >>> 63) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out) + sign, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out) + sign, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy let _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// let _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  let u0 = u & 0xFFFFFFFF;\n  let v0 = v & 0xFFFFFFFF;\n\n  let u1 = u >> 32;\n  let v1 = v >> 32;\n\n  let l = u0 * v0;\n  let t = u1 * v0 + (l >> 32);\n  let w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  let frc = (f << 1) + 1;\n  let exp = e - 1;\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  let lastp = buffer + ((len - 1) << 1);\n  let digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  let dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  let k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  let index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  let uv  = reinterpret<u64>(value);\n  let exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  let sid = uv & 0x000FFFFFFFFFFFFF;\n  let frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let frc_pow = _frc_pow;\n  let exp_pow = _exp_pow;\n\n  let w_frc = umul64f(frc, frc_pow);\n  let w_exp = umul64e(exp, exp_pow);\n\n  let wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  let wp_exp = umul64e(_exp, exp_pow);\n\n  let wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  let delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  let one_exp = -mp_exp;\n  let one_frc = (<u64>1) << one_exp;\n  let mask    = one_frc - 1;\n\n  let wp_w_frc = mp_frc - w_frc;\n\n  let p1 = u32(mp_frc >> one_exp);\n  let p2 = mp_frc & mask;\n\n  let kappa = <i32>decimalCount32(p1);\n  let len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  let sign = k < 0;\n  if (sign) k = -k;\n  let decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  let kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  let sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  let len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  let size = dtoa_core(dtoa_buf, value) << 1;\n  let result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  let sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      if (sizeof<T>() == 1) {\n        if (value == -0x80) {\n          // -0x80  ->  -128\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 1) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 8) << 48\n          );\n          return 4;\n        }\n      }\n      if (sizeof<T>() == 2) {\n        if (value == -0x8000) {\n          // -0x8000  ->  -32768\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 3) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 7) << 48\n          ); // -327\n          store<u32>(buffer + 8,\n            (CharCode._0 + 6) << 0 |\n            (CharCode._0 + 8) << 16\n          ); // 68\n          return 6;\n        }\n      }\n      store<u16>(buffer, CharCode.MINUS);\n      // @ts-ignore\n      value = -value;\n    }\n  }\n  let dest = buffer + (sign << 1);\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  let decimals: u32 = 0;\n  if (sizeof<T>() <= 4) {\n    let val32 = <u32>value;\n    decimals = decimalCount32(val32);\n    utoa32_dec_core(dest, val32, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals = decimalCount32(val32);\n      utoa32_dec_core(dest, val32, decimals);\n    } else {\n      let val64 = <u64>value;\n      decimals = decimalCount64High(val64);\n      utoa64_dec_core(dest, val64, decimals);\n    }\n  }\n  return sign + decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","import { compareImpl } from \"./string\";\n\ntype Comparator<T> = (a: T, b: T) => i32;\n\n// @ts-ignore: decorator\n@lazy @inline const EMPTY = u32.MAX_VALUE;\n// @ts-ignore: decorator\n@inline const INSERTION_SORT_THRESHOLD = 48;\n// @ts-ignore: decorator\n@inline const MIN_RUN_LENGTH = 32;\n\n// @ts-ignore: decorator\n@inline\nfunction log2u(n: u32): u32 {\n  return 31 - clz(n);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): Comparator<T> {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a, b) => i32(a) - i32(b);\n    } else {\n      return (a, b) => i32(a > b) - i32(a < b);\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a, b) => {\n        let ia = reinterpret<i32>(f32(a));\n        let ib = reinterpret<i32>(f32(b));\n        ia ^= ia >> 31 >>> 1;\n        ib ^= ib >> 31 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a, b) => {\n        let ia = reinterpret<i64>(f64(a));\n        let ib = reinterpret<i64>(f64(b));\n        ia ^= ia >> 63 >>> 1;\n        ib ^= ib >> 63 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a, b) => {\n      if (\n        changetype<usize>(a) == changetype<usize>(b) ||\n        changetype<usize>(a) == 0 ||\n        changetype<usize>(b) == 0\n      ) return 0;\n      let alen = changetype<string>(a).length;\n      let blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(\n        changetype<string>(a), 0,\n        changetype<string>(b), 0,\n        <usize>min(alen, blen)\n      );\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a, b) => i32(a > b) - i32(a < b);\n  }\n}\n\n// Power Sort implementation (stable) from paper \"Nearly-Optimal Mergesorts\"\n// https://arxiv.org/pdf/1805.04154.pdf\n// This method usually outperform TimSort.\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\nexport function SORT<T>(\n  ptr: usize,\n  len: i32,\n  comparator: Comparator<T>\n): void {\n  if (len <= INSERTION_SORT_THRESHOLD) {\n    if (len <= 1) return;\n    if (ASC_SHRINK_LEVEL < 1) {\n      switch (len) {\n        case 3: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          a = select<T>(a, b, c);\n          b = load<T>(ptr, 2 << alignof<T>());\n          c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\n        }\n        case 2: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\n          return;\n        }\n      }\n    }\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\n    return;\n  }\n\n  let lgPlus2         = log2u(len) + 2;\n  let lgPlus2Size     = lgPlus2 << alignof<u32>();\n  let leftRunStartBuf = __alloc(lgPlus2Size << 1);\n  let leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\n\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n  }\n\n  let buffer = __alloc(len << alignof<T>());\n\n  let hi   = len - 1;\n  let endA = extendRunRight<T>(ptr, 0, hi, comparator);\n  let lenA = endA + 1;\n\n  if (lenA < MIN_RUN_LENGTH) {\n    endA = min(hi, MIN_RUN_LENGTH - 1);\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\n  }\n\n  let top: u32 = 0, startA = 0;\n  while (endA < hi) {\n    let startB = endA + 1;\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\n    let lenB = endB - startB + 1;\n\n    if (lenB < MIN_RUN_LENGTH) {\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\n    }\n\n    let k = nodePower(0, hi, startA, startB, endB);\n\n    for (let i = top; i > k; --i) {\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n      if (start != EMPTY) {\n        mergeRuns<T>(\n          ptr,\n          start,\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n          endA,\n          buffer,\n          comparator\n        );\n        startA = start;\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n      }\n    }\n\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\n    startA = startB;\n    endA = endB;\n    top = k;\n  }\n\n  for (let i = top; i != 0; --i) {\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n    if (start != EMPTY) {\n      mergeRuns<T>(\n        ptr,\n        start,\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n        hi,\n        buffer,\n        comparator\n      );\n    }\n  }\n  // dealloc aux buffers\n  __free(buffer);\n  __free(leftRunStartBuf);\n}\n\nfunction insertionSort<T>(\n  ptr: usize,\n  left: i32,\n  right: i32,\n  presorted: i32,\n  comparator: Comparator<T>\n): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    // slightly improved original insertion sort\n    for (let i = left + presorted; i <= right; ++i) {\n      let j = i - 1;\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\n      while (j >= left) {\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, b) < 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\n    }\n  } else {\n    // even-odd two-way insertion sort which allow increase minRunLen\n    let range = right - left + 1;\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\n    for (; i <= right; i += 2) {\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\n      let min = b, max = a;\n      if (comparator(a, b) <= 0) {\n        min = a, max = b;\n      }\n      let j = i - 1;\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, max) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, min) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\n    }\n  }\n}\n\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\n  let n: u64 = right - left + 1;\n  let s = startB - (left << 1);\n  let l = startA + s;\n  let r = endB   + s + 1;\n  let a = (<u64>l << 30) / n;\n  let b = (<u64>r << 30) / n;\n  return clz(<u32>(a ^ b));\n}\n\nfunction extendRunRight<T>(\n  ptr: usize,\n  i: i32,\n  right: i32,\n  comparator: Comparator<T>\n): i32 {\n  if (i == right) return i;\n  let j = i;\n  if (comparator(\n    load<T>(ptr + (<usize>  j << alignof<T>())),\n    load<T>(ptr + (<usize>++j << alignof<T>()))\n  ) > 0) {\n    while (\n      j < right &&\n      (comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >>> 31) // < 0\n    ) ++j;\n    // reverse\n    let k = j;\n    while (i < k) {\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\n    }\n  } else {\n    while (\n      j < right &&\n      comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >= 0\n    ) ++j;\n  }\n  return j;\n}\n\n// Merges arr[l..m - 1] and arr[m..r]\nfunction mergeRuns<T>(\n  ptr: usize,\n  l: i32,\n  m: i32,\n  r: i32,\n  buffer: usize,\n  comparator: Comparator<T>\n): void {\n  --m;\n  let i: i32, j: i32, t = r + m;\n  for (i = m + 1; i > l; --i) {\n    store<T>(\n      buffer + (<usize>(i - 1) << alignof<T>()),\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\n    );\n  }\n  for (j = m; j < r; ++j) {\n    store<T>(\n      buffer + (<usize>(t - j) << alignof<T>()),\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\n    );\n  }\n  for (let k = l; k <= r; ++k) {\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\n    if (comparator(a, b) < 0) {\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\n      --j;\n    } else {\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\n      ++i;\n    }\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    let hasSur = surr > 0;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    let length = units.length;\n    let out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    let ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    let hasSur = <u32>code > 0xFFFF;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      // Checks valid code point range\n      assert(<u32>code <= 0x10FFFF);\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = code >>> 10 | 0xD800;\n      store<u32>(changetype<usize>(out), lo | hi << 16);\n    }\n    return out;\n  }\n\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    let len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    let out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    let len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    let first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    let second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    let thisSize: isize = this.length << 1;\n    let otherSize: isize = other.length << 1;\n    let outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    end = min(max(end, 0), this.length);\n    let searchLength = <isize>search.length;\n    let searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return true;\n    if (changetype<usize>(left) == 0 || changetype<usize>(right) == 0) return false;\n    let leftLength = changetype<string>(left).length;\n    if (leftLength != changetype<string>(right).length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return changetype<usize>(str) == 0 || !changetype<string>(str).length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return false;\n    let rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let rightLength = right.length;\n    if (!rightLength) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    let len = <isize>this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    let len = this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (changetype<usize>(other) == changetype<usize>(this)) return 0;\n    let alen = this.length;\n    let blen = other.length;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(this, 0, other, 0, <usize>min(alen, blen));\n    res = res ? res : alen - blen;\n    // normalize to [-1, 1] range\n    return i32(res > 0) - i32(res < 0);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    let len = <isize>this.length;\n    let searchStart = min(max(<isize>start, 0), len);\n    let searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    let intStart: isize = start;\n    let end: isize = length;\n    let len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    let size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len: isize = this.length;\n    let finalStart = min<isize>(max(start, 0), len);\n    let finalEnd = min<isize>(max(end, 0), len);\n    let fromPos = min<isize>(finalStart, finalEnd) << 1;\n    let toPos = max<isize>(finalStart, finalEnd) << 1;\n    let size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    let len = this.length;\n    let size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    let size = <usize>this.length << 1;\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    let originalSize = <usize>this.length << 1;\n    let size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let prependSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let appendSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    let length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    let out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    let len: usize = this.length;\n    let slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    let index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    let thisLen: usize = this.length;\n    let searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    let replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    let prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    let out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (changetype<usize>(separator) == 0) return [ this ];\n    let length: isize = this.length;\n    let sepLen = changetype<string>(separator).length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    let result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    let end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(changetype<string>(separator), start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    let len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // ''\n          //  maps to  but except at the end of a word where it maps to \n          let sigma = 0x03C3; // \n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // \n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    let specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    let specialsLen = SPECIALS_UPPER.length;\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export const enum ErrorMode {\n      WTF8,\n      REPLACE,\n      ERROR\n    }\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      let strOff = changetype<usize>(str);\n      let strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      let bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\n      let strEnd = str + (<usize>len << 1);\n      let bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) return bufOff - buf;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          // D800: 11011 0 0000000000 Lead\n          // DBFF: 11011 0 1111111111\n          // DC00: 11011 1 0000000000 Trail\n          // DFFF: 11011 1 1111111111\n          // F800: 11111 0 0000000000 Mask\n          // FC00: 11111 1 0000000000\n          if ((c1 & 0xF800) == 0xD800) {\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\n              let c2 = <u32>load<u16>(str, 2);\n              if ((c2 & 0xFC00) == 0xDC00) {\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n                let b0 = c1 >> 18 | 240;\n                let b1 = c1 >> 12 & 63 | 128;\n                let b2 = c1 >> 6  & 63 | 128;\n                let b3 = c1       & 63 | 128;\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n                bufOff += 4; str += 4;\n                continue;\n              }\n            }\n            if (errorMode != ErrorMode.WTF8) { // unlikely\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\n              c1 = 0xFFFD;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      let bufOff = buf;\n      let bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      let str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      let strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      let size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      let str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n\nexport class TemplateStringsArray extends Array<string> {\n  readonly raw: string[];\n}\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  let ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  let buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  let bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  let buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  let array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (changetype<usize>(value) == 0) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    let length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    let outSize = <usize>max(end - begin, 0);\n    let out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","export function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\n\n// primes\n// @ts-ignore: decorator\n@inline const XXH32_P1: u32 = 2654435761;\n// @ts-ignore: decorator\n@inline const XXH32_P2: u32 = 2246822519;\n// @ts-ignore: decorator\n@inline const XXH32_P3: u32 = 3266489917;\n// @ts-ignore: decorator\n@inline const XXH32_P4: u32 = 668265263;\n// @ts-ignore: decorator\n@inline const XXH32_P5: u32 = 374761393;\n// @ts-ignore: decorator\n@inline const XXH32_SEED: u32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction hash32(key: u32, len: u32 = 4): u32 {\n  let h: u32 = XXH32_SEED + XXH32_P5 + len;\n  h += key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hash64(key: u64): u32 {\n  let h: u32 = XXH32_SEED + XXH32_P5 + 8;\n  h += <u32>key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h += <u32>(key >> 32) * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction mix(h: u32, key: u32): u32 {\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hashStr(key: string): u32 {\n  if (changetype<usize>(key) == 0) return XXH32_SEED;\n\n  let h: u32 = key.length << 1;\n  let len: usize = h;\n  let pos = changetype<usize>(key);\n\n  if (len >= 16) {\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\n    let s2 = XXH32_SEED + XXH32_P2;\n    let s3 = XXH32_SEED;\n    let s4 = XXH32_SEED - XXH32_P1;\n\n    let end = len + pos - 16;\n    while (pos <= end) {\n      s1 = mix(s1, load<u32>(pos    ));\n      s2 = mix(s2, load<u32>(pos,  4));\n      s3 = mix(s3, load<u32>(pos,  8));\n      s4 = mix(s4, load<u32>(pos, 12));\n      pos += 16;\n    }\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\n  } else {\n    h += XXH32_SEED + XXH32_P5;\n  }\n\n  let end = changetype<usize>(key) + len - 4;\n  while (pos <= end) {\n    h += load<u32>(pos) * XXH32_P3;\n    h = rotl(h, 17) * XXH32_P4;\n    pos += 4;\n  }\n\n  end = changetype<usize>(key) + len;\n  while (pos < end) {\n    h += <u32>load<u8>(pos) * XXH32_P5;\n    h = rotl(h, 11) * XXH32_P1;\n    pos++;\n  }\n\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\nimport { E_KEYNOTFOUND } from \"./util/error\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    let entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) != null;\n  }\n\n  @operator(\"[]\")\n  get(key: K): V {\n    let entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator(\"[]=\")\n  set(key: K, value: V): this {\n    let hashCode = HASH<K>(key);\n    let entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = key;\n      if (isManaged<K>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  delete(key: K): bool {\n    let entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    let halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    let newBucketsCapacity = <i32>(newBucketsMask + 1);\n    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    let oldPtr = changetype<usize>(this.entries);\n    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    let newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let keys = new Array<K>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(keys[length++] = entry.key);\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let values = new Array<V>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(values[length++] = entry.value);\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    let entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","export class CoverPoint {\n    public file: string = \"\";\n    public hash: string = \"\";\n    public line: i32 = 0;\n    public column: i32 = 0;\n    public type!: string;\n    public executed: boolean = false;\n}\n\nexport class Coverage {\n    public hashes: Map<string, CoverPoint> = new Map<string, CoverPoint>();\n    public points: i32 = 0;\n    static SN: Coverage = new Coverage();\n}\n\nexport function __REGISTER(point: CoverPoint): void {\n    Coverage.SN.points++;\n    Coverage.SN.hashes.set(point.hash, point);\n}\n\nexport function __COVER(hash: string): void {\n    if (Coverage.SN.hashes.has(hash)) Coverage.SN.hashes.delete(hash);\n}\n\nexport function __HASHES(): Map<string, CoverPoint> {\n    return Coverage.SN.hashes;\n}\n\nexport function __POINTS(): i32 {\n    return Coverage.SN.points;\n}","import { JSON } from \"..\";\nimport {\n  describe,\n  expect,\n  run\n} from \"as-test/assembly\";\nimport { DerivedObject, Null, ObjWithStrangeKey, ObjectWithFloat, OmitIf, Player, Vec3 } from \"./types\";\nimport { MpZ } from \"@hypercubed/as-mpz\";\n\ndescribe(\"Should serialize strings\", () => {\n\n  expect(\n    JSON.stringify(\"abcdefg\")\n  ).toBe(\"\\\"abcdefg\\\"\");\n\n  expect(\n    JSON.stringify('st\"ring\" w\"\"ith quotes\"')\n  ).toBe('\"st\\\\\"ring\\\\\" w\\\\\"\\\\\"ith quotes\\\\\"\"');\n\n  expect(\n    JSON.stringify('string \\\"with random spa\\nces and \\nnewlines\\n\\n\\n')\n  ).toBe('\"string \\\\\"with random spa\\\\nces and \\\\nnewlines\\\\n\\\\n\\\\n\"');\n\n  expect(\n    JSON.stringify('string with colon : comma , brace [ ] bracket { } and quote \" and other quote \\\\\"')\n  ).toBe('\"string with colon : comma , brace [ ] bracket { } and quote \\\\\" and other quote \\\\\\\\\\\\\"\"')\n\n});\n\ndescribe(\"Should serialize integers\", () => {\n\n  expect(\n    JSON.stringify(0)\n  ).toBe(\"0\");\n\n  expect(\n    JSON.stringify<u32>(100)\n  ).toBe(\"100\");\n\n  expect(\n    JSON.stringify<u64>(101)\n  ).toBe(\"101\");\n\n  expect(\n    JSON.stringify<i32>(-100)\n  ).toBe(\"-100\");\n\n  expect(\n    JSON.stringify<i64>(-101)\n  ).toBe(\"-101\");\n\n});\n\ndescribe(\"Should serialize MpZ (Big Int)\", () => {\n\n  expect(\n    JSON.stringify<MpZ>(MpZ.from(0))\n  ).toBe(\"0\");\n\n  expect(\n    JSON.stringify<MpZ>(MpZ.from(2).pow(512))\n  ).toBe(\"13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084096\");\n\n});\n\ndescribe(\"Should serialize floats\", () => {\n\n  expect(\n    JSON.stringify<f64>(7.23)\n  ).toBe(\"7.23\");\n\n  expect(\n    JSON.stringify<f64>(10e2)\n  ).toBe(\"1000.0\");\n\n  expect(\n    JSON.stringify<f64>(123456e-5)\n  ).toBe(\"1.23456\");\n\n  expect(\n    JSON.stringify<f64>(0.0)\n  ).toBe(\"0.0\");\n\n  expect(\n    JSON.stringify<f64>(-7.23)\n  ).toBe(\"-7.23\");\n\n  expect(\n    JSON.stringify<f64>(1e-6)\n  ).toBe(\"0.000001\");\n\n  expect(\n    JSON.stringify<f64>(1e-7)\n  ).toBe(\"1e-7\");\n\n  expect(\n    JSON.parse<f64>(\"1E-7\")\n  ).toBe(1e-7);\n\n  expect(\n    JSON.stringify<f64>(1e20)\n  ).toBe(\"100000000000000000000.0\");\n\n  expect(\n    JSON.stringify<f64>(1e21)\n  ).toBe(\"1e+21\");\n\n  expect(\n    JSON.parse<f64>(\"1E+21\")\n  ).toBe(1e21);\n\n  expect(\n    JSON.parse<f64>(\"1e21\")\n  ).toBe(1e21);\n\n  expect(\n    JSON.parse<f64>(\"1E21\")\n  ).toBe(1e21);\n\n});\n\ndescribe(\"Should serialize booleans\", () => {\n\n  expect(\n    JSON.stringify<bool>(true)\n  ).toBe(\"true\");\n\n  expect(\n    JSON.stringify<bool>(false)\n  ).toBe(\"false\");\n\n  expect(\n    JSON.stringify<boolean>(true)\n  ).toBe(\"true\");\n\n  expect(\n    JSON.stringify<boolean>(false)\n  ).toBe(\"false\");\n\n});\n\ndescribe(\"Should serialize class inheritance\", () => {\n\n  const obj = new DerivedObject(\"1\", \"2\");\n\n  expect(\n    JSON.stringify(obj)\n  ).toBe(\"{\\\"a\\\":\\\"1\\\",\\\"b\\\":\\\"2\\\"}\");\n\n});\n\ndescribe(\"Should serialize nulls\", () => {\n\n  expect(\n    JSON.stringify<Null>(null)\n  ).toBe(\"null\");\n\n});\n\n\ndescribe(\"Should serialize integer arrays\", () => {\n\n  expect(\n    JSON.stringify<u32[]>([0, 100, 101])\n  ).toBe(\"[0,100,101]\");\n\n  expect(\n    JSON.stringify<u64[]>([0, 100, 101])\n  ).toBe(\"[0,100,101]\");\n\n  expect(\n    JSON.stringify<i32[]>([0, 100, 101, -100, -101])\n  ).toBe(\"[0,100,101,-100,-101]\");\n\n  expect(\n    JSON.stringify<i64[]>([0, 100, 101, -100, -101])\n  ).toBe(\"[0,100,101,-100,-101]\");\n\n});\n\ndescribe(\"Should serialize float arrays\", () => {\n\n  expect(\n    JSON.stringify<f64[]>([7.23, 10e2, 10e2, 123456e-5, 123456e-5, 0.0, 7.23])\n  ).toBe(\"[7.23,1000.0,1000.0,1.23456,1.23456,0.0,7.23]\");\n\n  expect(\n    JSON.stringify<f64[]>([1e21, 1e22, 1e-7, 1e-8, 1e-9])\n  ).toBe(\"[1e+21,1e+22,1e-7,1e-8,1e-9]\");\n\n});\n\ndescribe(\"Should serialize boolean arrays\", () => {\n\n  expect(\n    JSON.stringify<bool[]>([true, false])\n  ).toBe(\"[true,false]\");\n\n  expect(\n    JSON.stringify<boolean[]>([true, false])\n  ).toBe(\"[true,false]\");\n\n});\n\ndescribe(\"Should serialize string arrays\", () => {\n\n  expect(\n    JSON.stringify<string[]>(['string \\\"with random spa\\nces and \\nnewlines\\n\\n\\n'])\n  ).toBe('[\"string \\\\\"with random spa\\\\nces and \\\\nnewlines\\\\n\\\\n\\\\n\"]');\n\n});\n\ndescribe(\"Should serialize nested integer arrays\", () => {\n\n  expect(\n    JSON.stringify<i64[][]>([[100, 101], [-100, -101], [0]])\n  ).toBe(\"[[100,101],[-100,-101],[0]]\");\n\n});\n\ndescribe(\"Should serialize nested float arrays\", () => {\n\n  expect(\n    JSON.stringify<f64[][]>([\n      [7.23],\n      [10e2],\n      [10e2],\n      [123456e-5],\n      [123456e-5],\n      [0.0],\n      [7.23],\n    ])\n  ).toBe(\"[[7.23],[1000.0],[1000.0],[1.23456],[1.23456],[0.0],[7.23]]\");\n\n});\n\ndescribe(\"Should serialize nested boolean arrays\", () => {\n\n  expect(\n    JSON.stringify<bool[][]>([[true], [false]])\n  ).toBe(\"[[true],[false]]\");\n\n  expect(\n    JSON.stringify<boolean[][]>([[true], [false]])\n  ).toBe(\"[[true],[false]]\");\n\n});\n\ndescribe(\"Should serialize object arrays\", () => {\n\n  expect(\n    JSON.stringify<Vec3[]>([\n      {\n        x: 3.4,\n        y: 1.2,\n        z: 8.3,\n      },\n      {\n        x: 3.4,\n        y: -2.1,\n        z: 9.3,\n      },\n    ])\n  ).toBe('[{\"x\":3.4,\"y\":1.2,\"z\":8.3},{\"x\":3.4,\"y\":-2.1,\"z\":9.3}]');\n\n});\n\ndescribe(\"Should serialize objects\", () => {\n\n  expect(\n    JSON.stringify<Vec3>({\n      x: 3.4,\n      y: 1.2,\n      z: 8.3,\n    })\n  ).toBe('{\"x\":3.4,\"y\":1.2,\"z\":8.3}');\n\n  expect(\n    JSON.stringify<Player>({\n      firstName: \"Emmet\",\n      lastName: \"West\",\n      lastActive: [8, 27, 2022],\n      age: 23,\n      pos: {\n        x: 3.4,\n        y: 1.2,\n        z: 8.3,\n      },\n      isVerified: true,\n    })\n  ).toBe('{\"firstName\":\"Emmet\",\"lastName\":\"West\",\"lastActive\":[8,27,2022],\"age\":23,\"pos\":{\"x\":3.4,\"y\":1.2,\"z\":8.3},\"isVerified\":true}');\n\n  expect(\n    JSON.stringify<ObjectWithFloat>({ f: 7.23 })\n  ).toBe('{\"f\":7.23}');\n\n  expect(\n    JSON.stringify<ObjectWithFloat>({ f: 0.000001 })\n  ).toBe('{\"f\":0.000001}');\n\n  expect(\n    JSON.stringify<ObjectWithFloat>({ f: 1e-7 })\n  ).toBe('{\"f\":1e-7}');\n\n  expect(\n    JSON.stringify<ObjectWithFloat>({ f: 1e20 })\n  ).toBe('{\"f\":100000000000000000000.0}');\n\n  expect(\n    JSON.stringify<ObjectWithFloat>({ f: 1e21 })\n  ).toBe('{\"f\":1e+21}');\n\n  expect(\n    JSON.stringify<ObjWithStrangeKey<string>>({ data: \"foo\" })\n  ).toBe('{\"a\\\\\\\\\\\\t\\\\\"\\\\u0002b`c\":\"foo\"}');\n\n});\n\ndescribe(\"Should serialize @omit'ed objects\", () => {\n\n  expect(\n    JSON.stringify(<OmitIf>{\n      y: 1\n    })\n  ).toBe('{\"x\":1,\"y\":1,\"z\":1}');\n\n});\n\ndescribe(\"Should deserialize strings\", () => {\n\n  expect(\n    JSON.parse<string>(\"\\\"abcdefg\\\"\")\n  ).toBe(\"abcdefg\");\n\n  expect(\n    JSON.parse<string>('\"\\\\\"st\\\\\\\\\\\\\"ring\\\\\\\\\\\\\" w\\\\\\\\\\\\\"\\\\\\\\\\\\\"ith quotes\\\\\\\\\\\\\"\\\\\\\"\"')\n  ).toBe('\"st\\\\\"ring\\\\\" w\\\\\"\\\\\"ith quotes\\\\\"\"');\n\n  expect(\n    JSON.parse<string>('\"\\\\\"string \\\\\\\\\\\\\"with random spa\\\\\\\\nces and \\\\\\\\nnewlines\\\\\\\\n\\\\\\\\n\\\\\\\\n\\\\\"\"')\n  ).toBe('\"string \\\\\"with random spa\\\\nces and \\\\nnewlines\\\\n\\\\n\\\\n\"');\n\n  expect(\n    JSON.parse<string>('\"\\\\\"string with colon : comma , brace [ ] bracket { } and quote \\\\\\\\\\\\\" and other quote \\\\\\\\\\\\\\\\\\\\\"\\\\\\\"\"')\n  ).toBe('\"string with colon : comma , brace [ ] bracket { } and quote \\\\\" and other quote \\\\\\\\\"\"');\n\n});\n\ndescribe(\"Should deserialize integers\", () => {\n\n  expect(\n    JSON.parse<i32>(\"0\")\n  ).toBe(<i32>0);\n\n  expect(\n    JSON.parse<u32>(\"100\")\n  ).toBe(<u32>100);\n\n  expect(\n    JSON.parse<u64>(\"101\")\n  ).toBe(<u64>101);\n\n  expect(\n    JSON.parse<i32>(\"-100\")\n  ).toBe(<i32>-100);\n\n  expect(\n    JSON.parse<i64>(\"-101\")\n  ).toBe(<i64>-101);\n\n});\n\ndescribe(\"Should deserialize MpZ (Big Int)\", () => {\n\n  expect(\n    JSON.parse<MpZ>(\"0\").toString()\n  ).toBe(\"0\");\n\n  expect(\n    JSON.parse<MpZ>(\"13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084096\").toString()\n  ).toBe(\"13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084096\");\n\n});\n\ndescribe(\"Should deserialize floats\", () => {\n\n  expect(\n    JSON.parse<f64>(\"7.23\")\n  ).toBe(7.23);\n\n  expect(\n    JSON.parse<f64>(\"1000.0\")\n  ).toBe(1000.0);\n\n  expect(\n    JSON.parse<f64>(\"1.23456\")\n  ).toBe(1.23456);\n\n  expect(\n    JSON.parse<f64>(\"0.0\")\n  ).toBe(0.0);\n\n  expect(\n    JSON.parse<f64>(\"-7.23\")\n  ).toBe(-7.23);\n\n  expect(\n    JSON.parse<f64>(\"0.000001\")\n  ).toBe(0.000001);\n\n  expect(\n    JSON.parse<f64>(\"1e-7\")\n  ).toBe(1e-7);\n\n  expect(\n    JSON.parse<f64>(\"100000000000000000000.0\")\n  ).toBe(1e20);\n\n  expect(\n    JSON.parse<f64>(\"1e+21\")\n  ).toBe(1e21);\n\n});\n\ndescribe(\"Should deserialize booleans\", () => {\n\n  expect(\n    JSON.parse<boolean>(\"true\")\n  ).toBe(true);\n\n  expect(\n    JSON.parse<boolean>(\"false\")\n  ).toBe(false);\n\n});\n\ndescribe(\"Should deserialize class inheritance\", () => {\n\n  const jsonStr = \"{\\\"a\\\":\\\"1\\\",\\\"b\\\":\\\"2\\\"}\";\n  const obj = JSON.parse<DerivedObject>(jsonStr);\n\n  expect(obj instanceof DerivedObject).toBe(true);\n  expect(obj.a).toBe(\"1\");\n  expect(obj.b).toBe(\"2\");\n});\n\ndescribe(\"Should deserialize nulls\", () => {\n\n  expect(\n    JSON.stringify(JSON.parse<Null>(\"null\"))\n  ).toBe(\"null\");\n\n});\n\ndescribe(\"Should deserialize integer arrays\", () => {\n\n  expect(\n    JSON.stringify(JSON.parse<u32[]>(\"[0,100,101]\"))\n  ).toBe(JSON.stringify([0, 100, 101]));\n\n  expect(\n    JSON.stringify(JSON.parse<i32[]>(\"[0,100,101,-100,-101]\"))\n  ).toBe(JSON.stringify([0, 100, 101, -100, -101]));\n\n});\n\ndescribe(\"Should deserialize float arrays\", () => {\n\n  expect(\n    JSON.stringify(JSON.parse<f64[]>(\"[7.23,1000.0,1000.0,1.23456,1.23456,0.0,7.23]\"))\n  ).toBe(JSON.stringify([7.23, 1000.0, 1000.0, 1.23456, 1.23456, 0.0, 7.23]));\n\n  expect(\n    JSON.stringify(JSON.parse<f64[]>(\"[1e+21,1e+22,1e-7,1e-8,1e-9]\"))\n  ).toBe(JSON.stringify([1e21, 1e22, 1e-7, 1e-8, 1e-9]));\n\n});\n\ndescribe(\"Should deserialize boolean arrays\", () => {\n\n  expect(\n    JSON.stringify(JSON.parse<boolean[]>(\"[true,false]\"))\n  ).toBe(JSON.stringify([true, false]));\n\n});\n\ndescribe(\"Should deserialize string arrays\", () => {\n\n  expect(\n    JSON.stringify(JSON.parse<string[]>('[\"string \\\\\"with random spa\\\\nces and \\\\nnewlines\\\\n\\\\n\\\\n\"]'))\n  ).toBe(JSON.stringify([ 'string \"with random spa\\nces and \\nnewlines\\n\\n\\n' ]));\n\n});\n\ndescribe(\"Should deserialize nested integer arrays\", () => {\n\n  expect(\n    JSON.stringify(JSON.parse<i64[][]>(\"[[100,101],[-100,-101],[0]]\"))\n  ).toBe(JSON.stringify([[100, 101], [-100, -101], [0]]));\n\n});\n\ndescribe(\"Should deserialize nested float arrays\", () => {\n\n  expect(\n    JSON.stringify(JSON.parse<f64[][]>(\"[[7.23],[1000.0],[1000.0],[1.23456],[1.23456],[0.0],[7.23]]\"))\n  ).toBe(JSON.stringify([[7.23], [1000.0], [1000.0], [1.23456], [1.23456], [0.0], [7.23]]));\n\n});\n\ndescribe(\"Should deserialize nested boolean arrays\", () => {\n\n  expect(\n    JSON.stringify(JSON.parse<boolean[][]>(\"[[true],[false]]\"))\n  ).toBe(JSON.stringify([[true], [false]]));\n\n});\n\ndescribe(\"Should deserialize object arrays\", () => {\n\n  expect(\n    JSON.stringify(JSON.parse<Vec3[]>('[{\"x\":3.4,\"y\":1.2,\"z\":8.3},{\"x\":3.4,\"y\":-2.1,\"z\":9.3}]'))\n  ).toBe(JSON.stringify(<Vec3[]>[\n    { x: 3.4, y: 1.2, z: 8.3 },\n    { x: 3.4, y: -2.1, z: 9.3 }\n  ]));\n\n});\n\ndescribe(\"Should deserialize Objects\", () => {\n\n  expect(\n    JSON.stringify(JSON.parse<Vec3>('{\"x\":3.4,\"y\":1.2,\"z\":8.3}'))\n  ).toBe(JSON.stringify(<Vec3>{ x: 3.4, y: 1.2, z: 8.3 }));\n\n  expect(\n    JSON.stringify(JSON.parse<Player>('{\"firstName\":\"Emmet\",\"lastName\":\"West\",\"lastActive\":[8,27,2022],\"age\":23,\"pos\":{\"x\":3.4,\"y\":1.2,\"z\":8.3},\"isVerified\":true}'))\n  ).toBe(JSON.stringify(<Player>{\n    firstName: \"Emmet\",\n    lastName: \"West\",\n    lastActive: [8, 27, 2022],\n    age: 23,\n    pos: { x: 3.4, y: 1.2, z: 8.3 },\n    isVerified: true\n  }));\n\n  expect(\n    JSON.stringify(JSON.parse<ObjectWithFloat>('{\"f\":7.23}'))\n  ).toBe(JSON.stringify(<ObjectWithFloat>{ f: 7.23 }));\n\n  expect(\n    JSON.stringify(JSON.parse<ObjectWithFloat>('{\"f\":0.000001}'))\n  ).toBe(JSON.stringify(<ObjectWithFloat>{ f: 0.000001 }));\n\n  expect(\n    JSON.stringify(JSON.parse<ObjWithStrangeKey<string>>('{\"a\\\\\\\\\\\\t\\\\\"\\\\u0002b`c\":\"foo\"}'))\n  ).toBe(JSON.stringify(<ObjWithStrangeKey<string>>{ data: \"foo\" }));\n\n});\n\nrun({\n  log: true,\n  coverage: true\n});","/// <reference path=\"./index.d.ts\" />\nimport { serializeString } from \"./serialize/string\";\nimport { serializeBool } from \"./serialize/bool\";\nimport { serializeInteger } from \"./serialize/integer\";\nimport { serializeFloat } from \"./serialize/float\";\nimport { serializeObject } from \"./serialize/object\";\nimport { serializeDate } from \"./serialize/date\";\nimport { serializeArray } from \"./serialize/array\";\nimport { serializeMap } from \"./serialize/map\";\nimport { deserializeBoolean } from \"./deserialize/bool\";\nimport { deserializeArray } from \"./deserialize/array\";\nimport { deserializeFloat } from \"./deserialize/float\";\nimport { deserializeObject } from \"./deserialize/object\";\nimport { deserializeMap } from \"./deserialize/map\";\nimport { deserializeDate } from \"./deserialize/date\";\nimport { FALSE_WORD, NULL_WORD, TRUE_WORD } from \"./chars\";\nimport { deserializeInteger } from \"./deserialize/integer\";\nimport { deserializeString } from \"./deserialize/string\";\nimport { Sink } from \"./sink\";\nimport { Variant } from \"as-variant/assembly\";\nimport { MpZ } from \"@hypercubed/as-mpz\";\nimport { serializeMpZ } from \"./serialize/mpz\";\nimport { deserializeMpZ } from \"./deserialize/mpz\";\n\n/**\n * Offset of the 'storage' property in the JSON.Value class.\n */\n// @ts-ignore: Decorator valid here\nconst STORAGE = offsetof<JSON.Value>(\"storage\");\n\n/**\n * JSON Encoder/Decoder for AssemblyScript\n */\nexport namespace JSON {\n  /**\n * Enum representing the different types supported by JSON.\n */\n  export enum Types {\n    U8,\n    U16,\n    U32,\n    U64,\n    F32,\n    F64,\n    Bool,\n    String,\n    ManagedString,\n    Struct,\n    ManagedStruct,\n    Array,\n    ManagedArray\n  }\n\n  export class Value {\n    public type: i32;\n    // @ts-ignore: storage is set directly through memory\n    private storage: u64;\n\n    private constructor() { unreachable(); }\n\n    /**\n     * Creates an JSON.Value instance from a given value.\n     * @param value - The value to be encapsulated.\n     * @returns An instance of JSON.Value.\n     */\n    static from<T>(value: T): JSON.Value {\n      if (value instanceof Variant) {\n        // Handle\n      } else if (value instanceof JSON.Value) {\n        return value;\n      }\n      const out = changetype<JSON.Value>(__new(offsetof<JSON.Value>(), idof<JSON.Value>()));\n      out.set<T>(value);\n      return out;\n    }\n\n    /**\n     * Sets the value of the JSON.Value instance.\n     * @param value - The value to be set.\n     */\n    set<T>(value: T): void {\n      if (isBoolean<T>()) {\n        this.type = JSON.Types.Bool;\n        store<T>(changetype<usize>(this), value, STORAGE);\n      } else if (value instanceof u8 || value instanceof i8) {\n        this.type = JSON.Types.U8;\n        store<T>(changetype<usize>(this), value, STORAGE);\n      } else if (value instanceof u16 || value instanceof i16) {\n        this.type = JSON.Types.U16;\n        store<T>(changetype<usize>(this), value, STORAGE);\n      } else if (value instanceof u32 || value instanceof i32) {\n        this.type = JSON.Types.U32;\n        store<T>(changetype<usize>(this), value, STORAGE);\n      } else if (value instanceof u64 || value instanceof i64) {\n        this.type = JSON.Types.U64;\n        store<T>(changetype<usize>(this), value, STORAGE);\n      } else if (value instanceof f32) {\n        this.type = JSON.Types.F64;\n        store<T>(changetype<usize>(this), value, STORAGE);\n      } else if (value instanceof f64) {\n        this.type = JSON.Types.F64;\n        store<T>(changetype<usize>(this), value, STORAGE);\n      } else if (isString<T>()) {\n        this.type = JSON.Types.String;\n        store<T>(changetype<usize>(this), value, STORAGE);\n      } else if (value instanceof Map) {\n        if (idof<T>() !== idof<Map<string, JSON.Value>>()) {\n          throw new Error(\"Maps must be of type Map<string, JSON.Value>!\");\n        }\n        this.type = JSON.Types.Struct;\n        store<T>(changetype<usize>(this), value, STORAGE);\n        // @ts-ignore: __SERIALIZE is implemented by the transform\n      } else if (isDefined(value.__SERIALIZE)) {\n        this.type = JSON.Types.Struct;\n        store<T>(changetype<usize>(this), value, STORAGE);\n      } else if (isArray<T>()) {\n        // @ts-ignore: T satisfies constraints of any[]\n        this.type = JSON.Types.Array + getArrayDepth<T>(0);\n        store<T>(changetype<usize>(this), value, STORAGE);\n      }\n    }\n\n    /**\n     * Gets the value of the JSON.Value instance.\n     * @returns The encapsulated value.\n     */\n    unwrap<T>(): T {\n      if (isManaged<T>()) {\n        if (this.type !== JSON.Types.Struct) throw new Error(\"Type mismatch\");\n        if (idof<T>() !== load<u32>(changetype<usize>(this.storage), -8)) throw new Error(\"Type mismatch\");\n      }\n      return load<T>(changetype<usize>(this), STORAGE);\n    }\n\n    /**\n     * Gets the value of the JSON.Value instance.\n     * @returns The encapsulated value.\n     */\n    unwrapUnsafe<T>(): T {\n      return load<T>(changetype<usize>(this), STORAGE);\n    }\n\n    /**\n     * Gets the value of the JSON.Value instance.\n     * @returns The encapsulated value.\n     */\n    get<T>(): T {\n      return load<T>(changetype<usize>(this), STORAGE);\n    }\n\n    /**\n     * Gets the value of the JSON.Value instance.\n     * @returns The encapsulated value.\n     */\n    getUnsafe<T>(): T {\n      return load<T>(changetype<usize>(this), STORAGE);\n    }\n\n    /**\n     * Gets the value of the JSON.Value instance.\n     * @returns The encapsulated value.\n     */\n    is<T>(): T {\n      return load<T>(changetype<usize>(this), STORAGE);\n    }\n\n    /**\n     * Gets the value of the JSON.Value instance.\n     * @returns The encapsulated value.\n     */\n    clone<T>(): T {\n      return load<T>(changetype<usize>(this), STORAGE);\n    }\n\n    /**\n     * Converts the JSON.Value to a string representation.\n     * @param useString - If true, treats Buffer as a string.\n     * @returns The string representation of the JSON.Value.\n     */\n    toString(useString: boolean = false): string {\n      switch (this.type) {\n        case JSON.Types.U8: return this.get<u8>().toString();\n        case JSON.Types.U16: return this.get<u16>().toString();\n        case JSON.Types.U32: return this.get<u32>().toString();\n        case JSON.Types.U64: return this.get<u64>().toString();\n        case JSON.Types.String: return \"\\\"\" + this.get<string>() + \"\\\"\";\n        case JSON.Types.Bool: return this.get<boolean>() ? TRUE_WORD : FALSE_WORD;\n        default: {\n          const arr = this.get<JSON.Value[]>();\n          if (!arr.length) return \"[]\";\n          const out = Sink.fromString(\"[\");\n          for (let i = 0; i < arr.length - 1; i++) {\n            const element = unchecked(arr[i]);\n            out.write(element.toString(useString));\n            out.write(\",\");\n          }\n\n          const element = unchecked(arr[arr.length - 1]);\n          out.write(element.toString(useString));\n\n          out.write(\"]\");\n          return out.toString();\n        }\n      }\n    }\n  }\n\n  export class Box<T> {\n    constructor(public value: T) {}\n    @inline static from<T>(value: T): Box<T> {\n      return new Box(value);\n    }\n  }\n  \n  /**\n   * Stringifies valid JSON data.\n   * ```js\n   * JSON.stringify<T>(data)\n   * ```\n   * @param data T\n   * @returns string\n   */\n  // @ts-ignore: Decorator\n  export function stringify<T>(data: T): string {\n    if (isBoolean<T>()) {\n      return serializeBool(data as bool);\n    } else if (isInteger<T>()) {\n      // @ts-ignore\n      return serializeInteger<T>(data);\n    } else if (isFloat<T>(data)) {\n      // @ts-ignore\n      return serializeFloat<T>(data);\n      // @ts-ignore: Function is generated by transform\n    } else if (isNullable<T>() && changetype<usize>(data) == <usize>0) {\n      return NULL_WORD;\n      // @ts-ignore\n    } else if (isString<nonnull<T>>()) {\n      return serializeString(changetype<string>(data));\n    } else if (isDefined(data.__SERIALIZE)) {\n      // @ts-ignore\n      return serializeObject(changetype<nonnull<T>>(data));\n    } else if (data instanceof Date) {\n      // @ts-ignore\n      return serializeDate(changetype<nonnull<T>>(data));\n    } else if (data instanceof Array) {\n      // @ts-ignore\n      return serializeArray(changetype<nonnull<T>>(data));\n    } else if (data instanceof Map) {\n      // @ts-ignore\n      return serializeMap(changetype<nonnull<T>>(data));\n    } else if (data instanceof MpZ) {\n      return serializeMpZ(data);\n    } else {\n      throw new Error(\n        `Could not serialize data of type ${nameof<T>()}. Make sure to add the correct decorators to classes.`\n      );\n    }\n  }\n  /**\n   * Parses valid JSON strings into their original format.\n   * ```js\n   * JSON.parse<T>(data)\n   * ```\n   * @param data string\n   * @returns T\n   */\n\n  // @ts-ignore: Decorator\n  export function parse<T>(data: string): T {\n    if (isBoolean<T>()) {\n      return deserializeBoolean(data) as T;\n    } else if (isInteger<T>()) {\n      return deserializeInteger<T>(data);\n    } else if (isFloat<T>()) {\n      return deserializeFloat<T>(data);\n    } else if (isNullable<T>() && data.length === 4 && data == \"null\") {\n      // @ts-ignore\n      return null;\n    } else if (isString<T>()) {\n      // @ts-ignore\n      return deserializeString(data);\n    } else if (isArray<T>()) {\n      // @ts-ignore\n      return deserializeArray<nonnull<T>>(data);\n    }\n    let type: nonnull<T> = changetype<nonnull<T>>(0);\n    if (isDefined(type.__DESERIALIZE)) {\n      // @ts-ignore\n      return deserializeObject<nonnull<T>>(data.trimStart());\n    } else if (type instanceof Map) {\n      // @ts-ignore\n      return deserializeMap<nonnull<T>>(data.trimStart());\n    } else if (type instanceof MpZ) {\n      // @ts-ignore\n      return deserializeMpZ(data);\n    }else if (type instanceof Date) {\n      // @ts-ignore\n      return deserializeDate(data);\n    } else {\n      throw new Error(\n        `Could not deserialize data ${data} to type ${nameof<T>()}. Make sure to add the correct decorators to classes.`\n      );\n    }\n  }\n}\n\n// This allows JSON.stringify and JSON.parse to be available globally through an alias\n// @ts-ignore: Decorator\n@global function __SERIALIZE<T>(data: T): string {\n  return JSON.stringify(data);\n}\n// @ts-ignore: Decorator\n@global function __DESERIALIZE<T>(data: string): T {\n  return JSON.parse<T>(data);\n}","import {\n    BACK_SLASH,\n    BACKSPACE,\n    CARRIAGE_RETURN,\n    FORM_FEED,\n    NEW_LINE,\n    QUOTE,\n    QUOTE_WORD,\n    TAB\n} from \"../chars\";\nimport { Sink } from \"../sink\";\nimport { unsafeCharCodeAt } from \"../util\";\n\n// @ts-ignore: Decorator valid here\n@inline export function serializeString(data: string): string {\n    if (data.length === 0) {\n        return QUOTE_WORD + QUOTE_WORD;\n    }\n\n    let result = Sink.fromString(QUOTE_WORD, data.length);\n\n    let last: i32 = 0;\n    for (let i = 0; i < data.length; i++) {\n        const char = unsafeCharCodeAt(<string>data, i);\n        if (char === QUOTE || char === BACK_SLASH) {\n            result.write(<string>data, last, i);\n            result.writeCodePoint(BACK_SLASH);\n            last = i;\n        } else if (16 > char) {\n            result.write(<string>data, last, i);\n            last = i + 1;\n            switch (char) {\n                case BACKSPACE: {\n                    result.write(\"\\\\b\");\n                    break;\n                }\n                case TAB: {\n                    result.write(\"\\\\t\");\n                    break;\n                }\n                case NEW_LINE: {\n                    result.write(\"\\\\n\");\n                    break;\n                }\n                case FORM_FEED: {\n                    result.write(\"\\\\f\");\n                    break;\n                }\n                case CARRIAGE_RETURN: {\n                    result.write(\"\\\\r\");\n                    break;\n                }\n                default: {\n                    // all chars 0-31 must be encoded as a four digit unicode escape sequence\n                    // \\u0000 to \\u000f handled here\n                    result.write(\"\\\\u000\");\n                    result.write(char.toString(16));\n                    break;\n                }\n            }\n        } else if (32 > char) {\n            result.write(<string>data, last, i);\n            last = i + 1;\n            // all chars 0-31 must be encoded as a four digit unicode escape sequence\n            // \\u0010 to \\u001f handled here\n            result.write(\"\\\\u00\");\n            result.write(char.toString(16));\n        }\n    }\n    result.write(<string>data, last);\n    result.writeCodePoint(QUOTE);\n    return result.toString();\n}","// Characters\n// @ts-ignore = Decorator is valid here\n@inline export const COMMA = 44;\n// @ts-ignore = Decorator is valid here\n@inline export const QUOTE = 34;\n// @ts-ignore = Decorator is valid here\n@inline export const BACK_SLASH = 92;\n// @ts-ignore: Decorator is valid here\n@inline export const FWD_SLASH = 47;\n// @ts-ignore: Decorator is valid here\n@inline export const BRACE_LEFT = 123;\n// @ts-ignore: Decorator is valid here\n@inline export const BRACE_RIGHT = 125;\n// @ts-ignore: Decorator is valid here\n@inline export const BRACKET_LEFT = 91;\n// @ts-ignore: Decorator is valid here\n@inline export const BRACKET_RIGHT = 93;\n// @ts-ignore: Decorator is valid here\n@inline export const COLON = 58;\n// @ts-ignore: Decorator is valid here\n@inline export const CHAR_T = 116;\n// @ts-ignore: Decorator is valid here\n@inline export const CHAR_R = 114;\n// @ts-ignore: Decorator is valid here\n@inline export const CHAR_U = 117;\n// @ts-ignore: Decorator is valid here\n@inline export const CHAR_E = 101;\n// @ts-ignore: Decorator is valid here\n@inline export const CHAR_F = 102;\n// @ts-ignore: Decorator is valid here\n@inline export const CHAR_A = 97;\n// @ts-ignore: Decorator is valid here\n@inline export const CHAR_L = 108;\n// @ts-ignore: Decorator is valid here\n@inline export const CHAR_S = 115;\n// @ts-ignore = Decorator is valid here\n@inline export const CHAR_N = 110;\n// @ts-ignore = Decorator is valid here\n@inline export const CHAR_B = 98;\n// Strings\n// @ts-ignore: Decorator is valid here\n@inline export const TRUE_WORD = \"true\";\n// @ts-ignore: Decorator is valid here\n@inline export const FALSE_WORD = \"false\";\n// @ts-ignore: Decorator is valid here\n@inline export const NULL_WORD = \"null\";\n// @ts-ignore: Decorator is valid here\n@inline export const BRACE_LEFT_WORD = \"{\";\n// @ts-ignore: Decorator is valid here\n@inline export const BRACKET_LEFT_WORD = \"[\";\n// @ts-ignore: Decorator is valid here\n@inline export const EMPTY_BRACKET_WORD = \"[]\";\n// @ts-ignore: Decorator is valid here\n@inline export const COLON_WORD = \":\";\n// @ts-ignore: Decorator is valid here\n@inline export const COMMA_WORD = \",\";\n// @ts-ignore: Decorator is valid here\n@inline export const BRACE_RIGHT_WORD = \"}\";\n// @ts-ignore: Decorator is valid here\n@inline export const BRACKET_RIGHT_WORD = \"]\";\n// @ts-ignore: Decorator is valid here\n@inline export const QUOTE_WORD = \"\\\"\";\n// @ts-ignore: Decorator is valid here\n@inline export const EMPTY_QUOTE_WORD = \"\\\"\\\"\";\n\n// Escape Codes\n// @ts-ignore: Decorator is valid here\n@inline export const BACKSPACE = 8; // \\b\n// @ts-ignore: Decorator is valid here\n@inline export const TAB = 9; // \\t\n// @ts-ignore: Decorator is valid here\n@inline export const NEW_LINE = 10; // \\n\n// @ts-ignore: Decorator is valid here\n@inline export const FORM_FEED = 12; // \\f\n// @ts-ignore: Decorator is valid here\n@inline export const CARRIAGE_RETURN = 13; // \\r\n","import { itoa_buffered, dtoa_buffered } from \"util/number\";\n\nconst MIN_BUFFER_LEN = 32;\nconst MIN_BUFFER_SIZE: u32 = MIN_BUFFER_LEN << 1;\n\nconst NEW_LINE_CHAR: u16 = 0x0A; // \\n\n\n// @ts-ignore: decorator\nfunction nextPowerOf2(n: u32): u32 {\n    return 1 << 32 - clz(n - 1);\n}\n\nexport class Sink {\n    public buffer!: ArrayBuffer;\n    public offset: u32 = 0;\n\n    static withCapacity(capacity: i32): Sink {\n        const sink = new Sink();\n        sink.buffer = changetype<ArrayBuffer>(__new(\n            max<u32>(MIN_BUFFER_SIZE, <u32>capacity << 1),\n            idof<ArrayBuffer>())\n        );\n        return sink;\n    }\n\n    static fromString(initial: string = \"\", capacity: i32 = MIN_BUFFER_LEN): Sink {\n        const sink = new Sink();\n        const size = <u32>initial.length << 1;\n        sink.buffer = changetype<ArrayBuffer>(__new(\n            max<u32>(size, max<u32>(MIN_BUFFER_SIZE, <u32>capacity << 1)),\n            idof<ArrayBuffer>())\n        );\n        if (size) {\n            memory.copy(\n                changetype<usize>(sink.buffer),\n                changetype<usize>(initial),\n                size\n            );\n            sink.offset += size;\n        }\n        return sink;\n    }\n\n    static fromStringLiteral(initial: string = \"\"): Sink {\n        const sink = new Sink();\n        const size = <u32>initial.length << 1;\n        sink.buffer = changetype<ArrayBuffer>(__new(\n            size,\n            idof<ArrayBuffer>())\n        );\n        if (size) {\n            memory.copy(\n                changetype<usize>(sink.buffer),\n                changetype<usize>(initial),\n                size\n            );\n            sink.offset += size;\n        }\n        return sink;\n    }\n\n    static fromBuffer(initial: ArrayBuffer, capacity: i32 = MIN_BUFFER_LEN): Sink {\n        const sink = new Sink();\n        const size = <u32>initial.byteLength;\n        sink.buffer = changetype<ArrayBuffer>(__new(\n            max<u32>(size, max<u32>(MIN_BUFFER_SIZE, <u32>capacity << 1)),\n            idof<ArrayBuffer>())\n        );\n        if (size) {\n            memory.copy(\n                changetype<usize>(sink.buffer),\n                changetype<usize>(initial),\n                size\n            );\n            sink.offset = size;\n        }\n        return sink;\n    }\n\n    constructor() { }\n\n    get length(): i32 {\n        return this.offset >> 1;\n    }\n\n    get capacity(): i32 {\n        return this.buffer.byteLength >>> 1;\n    }\n    reset(): void {\n        this.offset = 0;\n    }\n    write(src: string, start: i32 = 0, end: i32 = i32.MAX_VALUE): Sink | null {\n        let len = src.length as u32;\n\n        if (start != 0 || end != i32.MAX_VALUE) {\n            let from: i32;\n            from = min<i32>(max(start, 0), len);\n            end = min<i32>(max(end, 0), len);\n            start = min<i32>(from, end);\n            end = max<i32>(from, end);\n            len = end - start;\n        }\n\n        if (!len) return null;\n\n        let size = len << 1;\n        this.ensureCapacity(size);\n        let offset = this.offset;\n\n        memory.copy(\n            changetype<usize>(this.buffer) + offset,\n            changetype<usize>(src) + (<usize>start << 1),\n            size\n        );\n        this.offset = offset + size;\n        return this;\n    }\n\n    writeLn(src: string = \"\", start: i32 = 0, end: i32 = i32.MAX_VALUE): Sink {\n        let len = src.length as u32;\n        if (start != 0 || end != i32.MAX_VALUE) {\n            let from: i32;\n            from = min<i32>(max(start, 0), len);\n            end = min<i32>(max(end, 0), len);\n            start = min<i32>(from, end);\n            end = max<i32>(from, end);\n            len = end - start;\n        }\n\n        let size = len << 1;\n        this.ensureCapacity(size + 2);\n        let offset = this.offset;\n        let dest = changetype<usize>(this.buffer) + offset;\n        if (size) memory.copy(dest, changetype<usize>(src) + (<usize>start << 1), size);\n        store<u16>(dest + size, NEW_LINE_CHAR);\n        this.offset = offset + (size + 2);\n        return this;\n    }\n\n    writeCodePoint(code: i32): Sink {\n        let hasSur = <u32>code > 0xFFFF;\n        this.ensureCapacity(2 << i32(hasSur));\n\n        let offset = this.offset;\n        let dest = changetype<usize>(this.buffer) + offset;\n\n        if (!hasSur) {\n            store<u16>(dest, <u16>code);\n            this.offset = offset + 2;\n        } else {\n            assert(<u32>code <= 0x10FFFF);\n            code -= 0x10000;\n            let hi = (code & 0x03FF) | 0xDC00;\n            let lo = code >>> 10 | 0xD800;\n            store<u32>(dest, lo | hi << 16);\n            this.offset = offset + 4;\n        }\n        return this;\n    }\n\n    writeCodePoint16(code: i32): Sink {\n        this.ensureCapacity(2);\n\n        let offset = this.offset;\n        let dest = changetype<usize>(this.buffer) + offset;\n\n        store<u16>(dest, <u16>code);\n        this.offset = offset + 2;\n\n        return this;\n    }\n\n    writeCodePointUnsafe(code: i32): Sink {\n        this.ensureCapacity(2);\n\n        let offset = this.offset;\n        let dest = changetype<usize>(this.buffer) + offset;\n\n        code -= 0x10000;\n        let hi = (code & 0x03FF) | 0xDC00;\n        let lo = code >>> 10 | 0xD800;\n        store<u32>(dest, lo | hi << 16);\n        this.offset = offset + 4;\n        return this;\n    }\n\n    writeNumber<T extends number>(value: T): Sink {\n        let offset = this.offset;\n        if (isInteger<T>()) {\n            let maxCapacity = 0;\n            // this also include size for sign\n            if (sizeof<T>() == 1) {\n                maxCapacity = 4 << 1;\n            } else if (sizeof<T>() == 2) {\n                maxCapacity = 6 << 1;\n            } else if (sizeof<T>() == 4) {\n                maxCapacity = 11 << 1;\n            } else if (sizeof<T>() == 8) {\n                maxCapacity = 21 << 1;\n            }\n            this.ensureCapacity(maxCapacity);\n            offset += itoa_buffered(\n                changetype<usize>(this.buffer) + offset,\n                value\n            ) << 1;\n        } else {\n            this.ensureCapacity(32 << 1);\n            offset += dtoa_buffered(\n                changetype<usize>(this.buffer) + offset,\n                value\n            ) << 1;\n        }\n        this.offset = offset;\n        return this;\n    }\n    writeNumberUnsafe<T extends number>(value: T): Sink {\n        let offset = this.offset;\n        if (isInteger<T>()) {\n            offset += itoa_buffered(\n                changetype<usize>(this.buffer) + offset,\n                value\n            ) << 1;\n        } else {\n            offset += dtoa_buffered(\n                changetype<usize>(this.buffer) + offset,\n                value\n            ) << 1;\n        }\n        this.offset = offset;\n        return this;\n    }\n    writeIntegerUnsafe<T extends number>(value: T): Sink {\n        let offset = this.offset;\n        if (isInteger<T>()) {\n            offset += itoa_buffered(\n                changetype<usize>(this.buffer) + offset,\n                value\n            ) << 1;\n        } else {\n            offset += dtoa_buffered(\n                changetype<usize>(this.buffer) + offset,\n                value\n            ) << 1;\n        }\n        this.offset = offset;\n        return this;\n    }\n\n    reserve(capacity: i32, clear: bool = false): void {\n        if (clear) this.offset = 0;\n        this.buffer = changetype<ArrayBuffer>(__renew(\n            changetype<usize>(this.buffer),\n            max<u32>(this.offset, max<u32>(MIN_BUFFER_SIZE, <u32>capacity << 1))\n        ));\n    }\n\n    shrink(): void {\n        this.buffer = changetype<ArrayBuffer>(__renew(\n            changetype<usize>(this.buffer),\n            max<u32>(this.offset, MIN_BUFFER_SIZE)\n        ));\n    }\n\n    clear(): void {\n        this.reserve(0, true);\n    }\n\n    toString(): string {\n        let size = this.offset;\n        if (!size) return \"\";\n        let out = changetype<string>(__new(size, idof<string>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this.buffer), size);\n        return out;\n    }\n\n    ensureCapacity(deltaBytes: u32): void {\n        let buffer = this.buffer;\n        let newSize = this.offset + deltaBytes;\n        if (newSize > <u32>buffer.byteLength) {\n            this.buffer = changetype<ArrayBuffer>(__renew(\n                changetype<usize>(buffer),\n                nextPowerOf2(newSize)\n            ));\n        }\n    }\n}","import { isSpace } from \"util/string\";\nimport { BACK_SLASH, QUOTE } from \"./chars\";\nimport { Sink } from \"./sink\";\n\n// @ts-ignore: Decorator\nexport function isMap<T>(): bool {\n  let type = changetype<T>(0);\n  return type instanceof Map;\n}\n\n// @ts-ignore: Decorator\nexport function unsafeCharCodeAt(data: string, pos: i32): i32 {\n  return load<u16>(changetype<usize>(data) + ((<usize>pos) << 1));\n}\n\n// @ts-ignore: Decorator\nexport function removeWhitespace(data: string): string {\n  const result = new Sink();\n  let instr = false;\n  for (let i = 0; i < data.length; i++) {\n    const char = unsafeCharCodeAt(data, i);\n    if (instr === false && char === QUOTE) instr = true;\n    else if (\n      instr === true && char === QUOTE\n      && unsafeCharCodeAt(data, i - 1) !== BACK_SLASH\n    ) instr = false;\n\n    if (instr === false) {\n      if (!isSpace(char)) result.write(data.charAt(i));\n    } else {\n      result.write(data.charAt(i));\n    }\n  }\n  return result.toString();\n}\n\n// @ts-ignore: Decorator\nexport function escapeChar(char: string): string {\n  switch (unsafeCharCodeAt(char, 0)) {\n    case 0x22:\n      return '\\\\\"';\n    case 0x5c:\n      return \"\\\\\\\\\";\n    case 0x08:\n      return \"\\\\b\";\n    case 0x0a:\n      return \"\\\\n\";\n    case 0x0d:\n      return \"\\\\r\";\n    case 0x09:\n      return \"\\\\t\";\n    case 0x0c:\n      return \"\\\\f\";\n    case 0x0b:\n      return \"\\\\u000b\";\n    default:\n      return char;\n  }\n}\n\n/**\n * A terrible function which finds the depth of a certain array.\n * Suffers no overhead besides function calling and a if/else.\n * @returns depth of array\n */\n\n// @ts-ignore: Decorator\nexport function getArrayDepth<T extends ArrayLike>(depth: i32 = 1): i32 {\n  if (!isArray<T>()) {\n    return 0;\n  } else if (isArray<valueof<T>>()) {\n    depth++;\n    return getArrayDepth<valueof<T>>(depth);\n  } else {\n    return depth;\n  }\n}\n\n/** Scientific Notation Integer Parsing - SNIP\n * This is absolutely the fastest algorithm I could think of while adding full support for Scientific Notation\n * Loads 32 bits and retrieves the high/low bits.\n * The reason why we only load 4 bytes at a time is that numbers in the 32-bit range are 7 chars long at most.\n * Using SIMD or 64 bit loads would only work well when parsing large 128+ numbers.\n * \n * Here are some benchmarks\n * Parsing: \"12345\" \n * Results are spread over 5000ms\n * \n * SNIP: 270M iterations\n * ATOI: 285M iterations\n * ParseInt: 176M iterations \n * \n * @param str - Any number. Can include scientific notation.\n*/\n// @ts-ignore: Decorator\nexport function snip_fast<T extends number>(str: string, len: u32 = 0, offset: u32 = 0): T {\n  if (isSigned<T>()) {\n    const firstChar: u32 = load<u16>(changetype<usize>(str));\n    if (firstChar === 48) return 0 as T;\n    const isNegative = firstChar === 45; // Check if the number is negative\n    let val: T = 0 as T;\n    if (len == 0) len = u32(str.length << 1);\n    if (isNegative) {\n      offset += 2;\n      if (len >= 4) {\n        // 32-bit route\n        for (; offset < (len - 3); offset += 4) {\n          const ch = load<u32>(changetype<usize>(str) + <usize>offset);\n          const low = ch & 0xFFFF;\n          const high = ch >> 16;\n          // 9 is 57. The highest group of two numbers is 114, so if a e or an E is included, this will fire.\n          if (low > 57) {\n            // The first char (f) is E or e\n            // We push the offset up by two and apply the notation.\n            if (load<u16>(changetype<usize>(str) + <usize>offset + 2) == 45) {\n              return -(val / (10 ** (__atoi_fast<u32>(str, offset + 6, offset + 8) - 1))) as T;\n            } else {\n              // Inlined this operation instead of using a loop\n              return -(val * (10 ** (__atoi_fast<u32>(str, offset + 2, offset + 4) + 1))) as T;\n            }\n          } else if (high > 57) {\n            // The first char (f) is E or e\n            // We push the offset up by two and apply the notation.\n            if (load<u16>(changetype<usize>(str) + <usize>offset + 4) == 45) {\n              return -(val / (10 ** (__atoi_fast<u32>(str, offset + 6, offset + 8) - 1))) as T;\n            } else {\n              // Inlined this operation instead of using a loop\n              return -(val * (10 ** (__atoi_fast<u32>(str, offset + 4, offset + 6) + 1))) as T;\n            }\n          } else {\n            val = (val * 100 + ((low - 48) * 10) + (high - 48)) as T;\n          }\n        }\n      }\n      // Finish up the remainder with 16 bits.\n      for (; offset < len; offset += 2) {\n        const ch = load<u16>(changetype<usize>(str) + <usize>offset);\n        // 9 is 57. E and e are larger. Assumes valid JSON.\n        if (ch > 57) {\n          // The first char (f) is E or e\n          // We push the offset up by two and apply the notation.\n          if (load<u16>(changetype<usize>(str) + <usize>offset + 2) == 45) {\n            return -(val / (10 ** (__atoi_fast<u32>(str, offset + 6, offset + 8) - 1))) as T;\n          } else {\n            // Inlined this operation instead of using a loop\n            return -(val * (10 ** (__atoi_fast<u32>(str, offset + 2, offset + 4) + 1))) as T;\n          }\n        } else {\n          val = (val * 10) + (ch - 48) as T;\n        }\n      }\n      return -val as T;\n    } else {\n      if (len >= 4) {\n        // Duplet 16 bit lane load\n        for (; offset < (len - 3); offset += 4) {\n          const ch = load<u32>(changetype<usize>(str) + <usize>offset);\n          const low = ch & 0xFFFF;\n          const high = ch >> 16;\n          // 9 is 57. The highest group of two numbers is 114, so if a e or an E is included, this will fire.\n          if (low > 57) {\n            // The first char (f) is E or e\n            // We push the offset up by two and apply the notation.\n            if (load<u16>(changetype<usize>(str) + <usize>offset + 2) == 45) {\n              return (val / (10 ** (__atoi_fast<u32>(str, offset + 6, offset + 8) - 1))) as T;\n            } else {\n              // Inlined this operation instead of using a loop\n              return (val * (10 ** (__atoi_fast<u32>(str, offset + 2, offset + 4) + 1))) as T;\n            }\n          } else if (high > 57) {\n            if (load<u16>(changetype<usize>(str) + <usize>offset + 4) == 45) {\n              return (val / (10 ** (__atoi_fast<u32>(str, offset + 6, offset + 8) - 1))) as T;\n            } else {\n              // Inlined this operation instead of using a loop\n              return (val * (10 ** (__atoi_fast<u32>(str, offset + 4, offset + 6) + 1))) as T;\n            }\n          } else {\n            // Optimized with multiplications and shifts.\n            val = (val * 100 + ((low - 48) * 10) + (high - 48)) as T;\n          }\n        }\n      }\n      // Cover the remaining numbers with 16 bit loads.\n      for (; offset < len; offset += 2) {\n        const ch = load<u16>(changetype<usize>(str) + <usize>offset);\n        // 0's char is 48 and 9 is 57. Anything above this range would signify an exponent (e or E).\n        // e is 101 and E is 69.\n        if (ch > 57) {\n          if (load<u16>(changetype<usize>(str) + <usize>offset + 2) == 45) {\n            val = (val / (10 ** (__atoi_fast<u32>(str, offset + 6, offset + 8) - 1))) as T;\n          } else {\n            // Inlined this operation instead of using a loop\n            val = (val * (10 ** (__atoi_fast<u32>(str, offset + 2, offset + 4) + 1))) as T;\n          }\n          return val as T;\n        } else {\n          val = (val * 10) + (ch - 48) as T;\n        }\n      }\n      return val as T;\n    }\n  } else {\n    const firstChar: u32 = load<u16>(changetype<usize>(str));\n    if (firstChar === 48) return 0 as T;\n    let val: T = 0 as T;\n    if (len == 0) len = u32(str.length << 1);\n    if (len >= 4) {\n      // Duplet 16 bit lane load\n      for (; offset < (len - 3); offset += 4) {\n        const ch = load<u32>(changetype<usize>(str) + <usize>offset);\n        const low = ch & 0xFFFF;\n        const high = ch >> 16;\n        // 9 is 57. The highest group of two numbers is 114, so if a e or an E is included, this will fire.\n        if (low > 57) {\n          // The first char (f) is E or e\n          // We push the offset up by two and apply the notation.\n          if (load<u16>(changetype<usize>(str) + <usize>offset + 2) == 45) {\n            return (val / (10 ** (__atoi_fast<u32>(str, offset + 6, offset + 8) - 1))) as T;\n          } else {\n            // Inlined this operation instead of using a loop\n            return (val * (10 ** (__atoi_fast<u32>(str, offset + 2, offset + 4) + 1))) as T;\n          }\n        } else if (high > 57) {\n          if (load<u16>(changetype<usize>(str) + <usize>offset + 4) == 45) {\n            return (val / (10 ** (__atoi_fast<u32>(str, offset + 6, offset + 8) - 1))) as T;\n          } else {\n            // Inlined this operation instead of using a loop\n            return (val * (10 ** (__atoi_fast<u32>(str, offset + 4, offset + 6) + 1))) as T;\n          }\n        } else {\n          // Optimized with multiplications and shifts.\n          val = (val * 100 + ((low - 48) * 10) + (high - 48)) as T;\n        }\n      }\n    }\n    // Cover the remaining numbers with 16 bit loads.\n    for (; offset < len; offset += 2) {\n      const ch = load<u16>(changetype<usize>(str) + <usize>offset);\n      // 0's char is 48 and 9 is 57. Anything above this range would signify an exponent (e or E).\n      // e is 101 and E is 69.\n      if (ch > 57) {\n        if (load<u16>(changetype<usize>(str) + <usize>offset + 2) == 45) {\n          return (val / (10 ** (__atoi_fast<u32>(str, offset + 6, offset + 8) - 1))) as T;\n        } else {\n          // Inlined this operation instead of using a loop\n          return (val * (10 ** (__atoi_fast<u32>(str, offset + 2, offset + 4) + 1))) as T;\n        }\n      } else {\n        val = (val * 10) + (ch - 48) as T;\n      }\n    }\n    return val as T;\n  }\n}\n\n/**\n * Implementation of ATOI. Can be much much faster with SIMD.\n */\n\n// @ts-ignore\nexport function __atoi_fast<T extends number>(str: string, start: u32 = 0, end: u32 = 0): T {\n  // @ts-ignore\n  let val: T = 0;\n  if (!end) end = start + u32(str.length << 1);\n  if (isSigned<T>()) {\n    // Negative path\n    if (load<u16>(changetype<usize>(str) + <usize>start) === 45) {\n      start += 2;\n      for (; start < end; start += 2) {\n        val = (val * 10) + (load<u16>(changetype<usize>(str) + <usize>start) - 48) as T;\n      }\n      return -val as T;\n    } else {\n      for (; start < end; start += 2) {\n        val = ((val * 10) + (load<u16>(changetype<usize>(str) + <usize>start) - 48)) as T;\n      }\n      return val as T;\n    }\n  } else {\n    for (; start < end; start += 2) {\n      val = ((val * 10) + (load<u16>(changetype<usize>(str) + <usize>start) - 48)) as T;\n    }\n    return val as T;\n  }\n}\n\n/**\n * Parses an integer using __atoi_fast and applies the appended exponential number to it as scientific notation.\n * Benchmark: Hovers around 30m ops/s\n * Only safe if the string is valid.\n * @param str integer to parse. example: 123e1, 123e-1, 123E100\n * @returns\n */\n\n// @ts-ignore\nexport function parseSciInteger<T extends number>(str: string): T {\n  // @ts-ignore\n  let val: T = 0;\n  let offset = 0;\n  let firstChar = load<u16>(changetype<usize>(str) + <usize>offset);\n  if (firstChar === 45) {\n    offset = 2;\n  }\n  for (; offset < str.length << 1; offset += 2) {\n    const char = load<u16>(changetype<usize>(str) + <usize>offset);\n    if (char === 101 || char === 69) {\n      const char = load<u16>(changetype<usize>(str) + <usize>(offset += 2));\n      if (char === 45) {\n        // @ts-ignore\n        val /= sciNote<T>(__atoi_fast<T>(str, (offset += 2)));\n        // @ts-ignore\n        return val;\n      } else {\n        // @ts-ignore\n        val *= sciNote<T>(__atoi_fast<T>(str, offset));\n        // @ts-ignore\n        return val;\n      }\n    }\n    // @ts-ignore\n    val = (val << 1) + (val << 3) + (char - 48);\n    // We use load because in this case, there is no need to have bounds-checking\n  }\n  if (firstChar === 45) {\n    val = -val as T;\n  }\n  return val;\n}\n\n// @ts-ignore\nfunction sciNote<T extends number>(num: T): T {\n  let res = 1;\n  // @ts-ignore\n  if (num > 0) {\n    for (let i: T = <T>0; i < num; i++) {\n      res *= 10;\n    }\n  } else {\n    for (let i: T = <T>0; i < num; i++) {\n      res /= 10;\n    }\n  }\n  // @ts-ignore\n  return res;\n}\n\n// @ts-ignore\nfunction equalsSlice(p1_data: string, p1_start: i32, p1_end: i32, p2_data: string, p2_start: i32, p2_end: i32): boolean {\n  const p1_len = p1_end - p1_start;\n  const p2_len = p2_end - p2_start;\n  if (p1_len != p2_len) return false;\n  if (p1_len == 2) {\n    return load<u16>(changetype<usize>(p1_data) + p1_start) == load<u16>(changetype<usize>(p2_data) + p2_start)\n  }\n  return memory.compare(changetype<usize>(p1_data) + p1_start, changetype<usize>(p2_data) + p2_start, p1_len) === 0;\n}\n\n// @ts-ignore\nexport function containsCodePoint(str: string, code: u32, start: i32, end: i32): bool {\n  for (let i = start; i <= end; i++) {\n    if (unsafeCharCodeAt(str, i) == code) return true;\n  }\n  return false;\n}\n","/**\n * Serialize a bool to type string\n * @param data data to serialize\n * @returns string\n */\n// @ts-ignore: Decorator valid here\n@inline export function serializeBool(data: bool): string {\n    return data ? \"true\" : \"false\";\n}","// @ts-ignore: Decorator valid here\n@inline export function serializeInteger<T extends number>(data: T): string {\n    // I have a much faster implementation of itoa that I will port over later. Its ~4x faster\n    return data.toString();\n}","// @ts-ignore: Decorator valid here\n@inline export function serializeFloat<T extends number>(data: T): string {\n    return data.toString();\n}","interface GeneratedInterface {\n    __SERIALIZE(): string;\n}\n// @ts-ignore: Decoraor valid here\n@inline export function serializeObject<T extends GeneratedInterface>(data: T): string {\n    return changetype<nonnull<T>>(data).__SERIALIZE();\n}","// @ts-ignore: Decorator valid here\n@inline export function serializeDate(data: Date): string {\n    return `\"${data.toISOString()}\"`\n}","import { JSON } from \"..\";\nimport {\n    COMMA,\n    COMMA_WORD,\n    EMPTY_BRACKET_WORD,\n    BRACKET_LEFT_WORD,\n    BRACKET_RIGHT,\n    BRACKET_RIGHT_WORD\n} from \"../chars\";\nimport { Sink } from \"../sink\";\nimport { serializeString } from \"./string\";\n\n// @ts-ignore: Decorator valid here\n@inline export function serializeArray<T extends any[]>(data: T): string {\n    if (changetype<usize>(data) == <usize>0) return EMPTY_BRACKET_WORD;\n    // @ts-ignore\n    else if (data.length == 0) {\n        return EMPTY_BRACKET_WORD;\n        // @ts-ignore\n    } else if (isString<valueof<T>>()) {\n        let result = BRACKET_LEFT_WORD;\n        // @ts-ignore\n        for (let i = 0; i < data.length - 1; i++) {\n            // @ts-ignore\n            result += serializeString(unchecked(data[i]));\n            result += COMMA_WORD;\n        }\n        // @ts-ignore\n        result += serializeString(unchecked(data[data.length - 1]));\n        result += BRACKET_RIGHT_WORD;\n        return result;\n        // @ts-ignore\n    } else if (isBoolean<valueof<T>>()) {\n        // @ts-ignore\n        return BRACKET_LEFT_WORD + data.join(COMMA_WORD) + BRACKET_RIGHT_WORD;\n        // @ts-ignore\n    } else if (isFloat<valueof<T>>() || isInteger<valueof<T>>()) {\n        // @ts-ignore\n        return BRACKET_LEFT_WORD + data.join(COMMA_WORD) + BRACKET_RIGHT_WORD;\n    } else {\n        let result = Sink.fromString(BRACKET_LEFT_WORD);\n        // @ts-ignore\n        for (let i = 0; i < data.length - 1; i++) {\n            // @ts-ignore\n            result.write(JSON.stringify(unchecked(data[i])));\n            result.writeCodePoint(COMMA);\n        }\n        // @ts-ignore\n        result.write(JSON.stringify(unchecked(data[data.length - 1])));\n        result.writeCodePoint(BRACKET_RIGHT);\n        return result.toString();\n    }\n}","import { COLON, COMMA, BRACE_LEFT_WORD, BRACE_RIGHT } from \"../chars\";\nimport { JSON } from \"..\";\nimport { Sink } from \"../sink\";\n\n// @ts-ignore: Decorator valid here\n@inline export function serializeMap<T extends Map<any, any>>(data: T): string {\n    if (changetype<usize>(data) == <usize>0) return \"{}\";\n    let result = Sink.fromString(BRACE_LEFT_WORD);\n    if (!data.size) return \"{}\";\n    let keys = data.keys();\n    let values = data.values();\n    const end = data.size - 1;\n    for (let i = 0; i < end; i++) {\n        result.write(JSON.stringify(unchecked(keys[i]).toString()));\n        result.writeCodePoint(COLON);\n        result.write(JSON.stringify(unchecked(values[i])));\n        result.writeCodePoint(COMMA);\n    }\n    result.write(JSON.stringify(unchecked(keys[end]).toString()));\n    result.writeCodePoint(COLON);\n    result.write(JSON.stringify(unchecked(values[end])));\n\n    result.writeCodePoint(BRACE_RIGHT);\n    return result.toString();\n}","import { CHAR_F, CHAR_T } from \"../chars\";\nimport { unsafeCharCodeAt } from \"../util\";\n\n/**\n * Deserialize a string to type boolean\n * @param data data to parse\n * @returns boolean\n */\n// @ts-ignore: Decorator valid here\n@inline export function deserializeBoolean(data: string, start: i32 = 0, end: i32 = 0): boolean {\n    if (!end) end = data.length;\n    const len = end - start;\n    const ptr = changetype<usize>(data) + <usize>(start << 1);\n    const firstChar = unsafeCharCodeAt(data, start);\n    if (len === 4 && firstChar === CHAR_T && load<u64>(ptr) === 28429475166421108) return true;\n    else if (len === 5 && firstChar === CHAR_F && load<u64>(ptr, 2) === 28429466576093281) return false;\n    return false//ERROR(`Expected to find boolean, but found \"${data.slice(0, 100)}\" instead!`);\n}","import { isMap } from \"../util\";\nimport { deserializeArrayArray } from \"./array/array\";\nimport { deserializeBooleanArray } from \"./array/bool\";\nimport { deserializeFloatArray } from \"./array/float\";\nimport { deserializeIntegerArray } from \"./array/integer\";\nimport { deserializeMapArray } from \"./array/map\";\nimport { deserializeObjectArray } from \"./array/object\";\nimport { deserializeStringArray } from \"./array/string\";\n\n// @ts-ignore: Decorator valid here\nexport function deserializeArray<T extends unknown[]>(data: string): T {\n    if (isString<valueof<T>>()) {\n        return <T>deserializeStringArray(data);\n    } else if (isBoolean<valueof<T>>()) {\n        // @ts-ignore\n        return deserializeBooleanArray<T>(data);\n    } else if (isInteger<valueof<T>>()) {\n        // @ts-ignore\n        return deserializeIntegerArray<T>(data);\n    } else if (isFloat<valueof<T>>()) {\n        // @ts-ignore\n        return deserializeFloatArray<T>(data);\n    } else if (isArrayLike<valueof<T>>()) {\n        // @ts-ignore\n        return deserializeArrayArray<T>(data);\n    } else if (isMap<valueof<T>>()) {\n        return deserializeMapArray<T>(data);\n    } else if (isManaged<valueof<T>>() || isReference<valueof<T>>()) {\n        const type = changetype<nonnull<valueof<T>>>(0);\n        // @ts-ignore\n        if (isDefined(type.__DESERIALIZE)) {\n            return deserializeObjectArray<T>(data);\n        }\n        ERROR(\"Could not parse array of type \" + nameof<T>() + \"! Make sure to add the @json decorator over classes!\");\n    } else {\n        ERROR(\"Could not parse array of type \" + nameof<T>() + \"!\");\n    }\n}","import { BRACKET_LEFT, BRACKET_RIGHT } from \"../../chars\";\nimport { JSON } from \"../..\";\nimport { unsafeCharCodeAt } from \"../../util\";\n\n// @ts-ignore: Decorator valid here\n@inline export function deserializeArrayArray<T extends unknown[][]>(data: string): T {\n    const result = instantiate<T>();\n    let lastPos = 0;\n    let depth = 0;\n    let i = 1;\n    // Find start of bracket\n    //for (; unsafeCharCodeAt(data, i) !== leftBracketCode; i++) {}\n    //i++;\n    for (; i < data.length - 1; i++) {\n        const char = unsafeCharCodeAt(data, i);\n        if (char === BRACKET_LEFT) {\n            if (depth === 0) {\n                lastPos = i;\n            }\n            // Shifting is 6% faster than incrementing\n            depth++;\n        } else if (char === BRACKET_RIGHT) {\n            depth--;\n            if (depth === 0) {\n                i++;\n                result.push(JSON.parse<valueof<T>>(data.slice(lastPos, i)));\n            }\n        }\n    }\n    return result;\n}","import { CHAR_E, CHAR_F, CHAR_T } from \"../../chars\";\nimport { unsafeCharCodeAt } from \"../../util\";\nimport { deserializeBoolean } from \"../bool\";\n\n// @ts-ignore: Decorator valid here\n@inline export function deserializeBooleanArray<T extends boolean[]>(data: string): T {\n  const result = instantiate<T>();\n  let lastPos = 1;\n  for (let i = 1; i < data.length - 1; i++) {\n    const char = unsafeCharCodeAt(data, i);\n    if (char === CHAR_T || char === CHAR_F) {\n      lastPos = i;\n    } else if (char === CHAR_E) {\n      i++;\n      result.push(deserializeBoolean(data.slice(lastPos, i)));\n    }\n  }\n  return result;\n}","import { isSpace } from \"util/string\";\nimport { unsafeCharCodeAt } from \"../../util\";\nimport { COMMA, BRACKET_RIGHT } from \"../../chars\";\nimport { deserializeFloat } from \"../float\";\n\n// @ts-ignore: Decorator valid here\n@inline export function deserializeFloatArray<T extends number[]>(data: string): T {\n    const result = instantiate<T>();\n    let lastPos = 0;\n    let i = 1;\n    let awaitingParse = false;\n    for (; i < data.length; i++) {\n      const char = unsafeCharCodeAt(data, i);\n      if (lastPos === 0 && ((char >= 48 && char <= 57) || char === 45)) {\n        awaitingParse = true;\n        lastPos = i;\n      } else if (awaitingParse && (isSpace(char) || char == COMMA || char == BRACKET_RIGHT) && lastPos > 0) {\n        awaitingParse = false;\n        result.push(deserializeFloat<valueof<T>>(data.slice(lastPos, i)));\n        lastPos = 0;\n      }\n    }\n    return result;\n  }","// @ts-ignore: Decorator valid here\n@inline export function deserializeFloat<T>(data: string): T {\n    // @ts-ignore\n    const type: T = 0;\n    // @ts-ignore\n    if (type instanceof f64) return f64.parse(data);\n    // @ts-ignore\n    return f32.parse(data);\n}","import { isSpace } from \"util/string\";\nimport { unsafeCharCodeAt } from \"../../util\";\nimport { COMMA, BRACKET_RIGHT } from \"../../chars\";\nimport { deserializeInteger } from \"../integer\";\n\n// @ts-ignore: Decorator valid here\n@inline export function deserializeIntegerArray<T extends number[]>(data: string): T {\n    const result = instantiate<T>();\n    let lastPos = 0;\n    let i = 1;\n    let awaitingParse = false;\n    for (; i < data.length; i++) {\n        const char = unsafeCharCodeAt(data, i);\n        if (lastPos === 0 && ((char >= 48 && char <= 57) || char === 45)) {\n            awaitingParse = true;\n            lastPos = i;\n        } else if (awaitingParse && (isSpace(char) || char == COMMA || char == BRACKET_RIGHT) && lastPos > 0) {\n            awaitingParse = false;\n            result.push(deserializeInteger<valueof<T>>(data.slice(lastPos, i)));\n            lastPos = 0;\n        }\n    }\n    return result;\n}","import { snip_fast } from \"../util\";\n\n// @ts-ignore: Decorator valid here\n@inline export function deserializeInteger<T>(data: string): T {\n    // @ts-ignore\n    return snip_fast<T>(data);\n}","import { BRACE_LEFT, BRACE_RIGHT } from \"../../chars\";\nimport { JSON } from \"../..\";\nimport { unsafeCharCodeAt } from \"../../util\";\n\n// @ts-ignore: Decorator valid here\n@inline export function deserializeMapArray<T extends unknown[]>(data: string): T {\n    const result = instantiate<T>();\n    let lastPos: u32 = 1;\n    let depth: u32 = 0;\n    for (let pos: u32 = 0; pos < <u32>data.length; pos++) {\n        const char = unsafeCharCodeAt(data, pos);\n        if (char === BRACE_LEFT) {\n            if (depth === 0) {\n                lastPos = pos;\n            }\n            depth++;\n        } else if (char === BRACE_RIGHT) {\n            depth--;\n            if (depth === 0) {\n                pos++;\n                result.push(JSON.parse<valueof<T>>(data.slice(lastPos, pos)));\n                //lastPos = pos + 2;\n            }\n        }\n    }\n    return result;\n}","import { BRACE_LEFT, BRACE_RIGHT } from \"../../chars\";\nimport { JSON } from \"../..\";\nimport { unsafeCharCodeAt } from \"../../util\";\n\n// @ts-ignore: Decorator valid here\n@inline export function deserializeObjectArray<T extends unknown[]>(data: string): T {\n    const result = instantiate<T>();\n    let lastPos: u32 = 1;\n    let depth: u32 = 0;\n    for (let pos: u32 = 0; pos < <u32>data.length; pos++) {\n        const char = unsafeCharCodeAt(data, pos);\n        if (char === BRACE_LEFT) {\n            if (depth === 0) {\n                lastPos = pos;\n            }\n            depth++;\n        } else if (char === BRACE_RIGHT) {\n            depth--;\n            if (depth === 0) {\n                pos++;\n                result.push(JSON.parse<valueof<T>>(data.slice(lastPos, pos)));\n                //lastPos = pos + 2;\n            }\n        }\n    }\n    return result;\n}","import { BACK_SLASH, QUOTE } from \"../../chars\";\nimport { unsafeCharCodeAt } from \"../../util\";\nimport { deserializeString } from \"../string\";\n\n// @ts-ignore: Decorator valid here\n@inline export function deserializeStringArray(data: string): string[] {\n  const result: string[] = [];\n  let lastPos = 0;\n  let instr = false;\n  let escaping = false;\n  for (let i = 1; i < data.length - 1; i++) {\n    const char = unsafeCharCodeAt(data, i);\n    if (char === BACK_SLASH && !escaping) {\n      escaping = true;\n    } else {\n      if (char === QUOTE && !escaping) {\n        if (instr === false) {\n          instr = true;\n          lastPos = i;\n        } else {\n          instr = false;\n          result.push(deserializeString(data, lastPos, i));\n        }\n      }\n      escaping = false;\n    }\n  }\n  return result;\n}","import {\n    CHAR_B,\n    BACK_SLASH,\n    BACKSPACE,\n    CARRIAGE_RETURN,\n    CHAR_F,\n    FORM_FEED,\n    FWD_SLASH,\n    CHAR_N,\n    NEW_LINE,\n    QUOTE,\n    CHAR_R,\n    CHAR_T,\n    TAB,\n    CHAR_U\n} from \"../chars\";\nimport { Sink } from \"../sink\";\nimport { unsafeCharCodeAt } from \"../util\";\n\n// @ts-ignore: Decorator valid here\n@inline export function deserializeString(data: string, start: i32 = 0, end: i32 = 0): string {\n    end = end || data.length - 1;\n    let result = Sink.withCapacity(end - start - 1);\n    let last = start + 1;\n    for (let i = last; i < end; i++) {\n        if (unsafeCharCodeAt(data, i) !== BACK_SLASH) {\n            continue;\n        }\n        const char = unsafeCharCodeAt(data, ++i);\n        result.write(data, last, i - 1);\n        switch (char) {\n            case QUOTE: {\n                result.writeCodePoint(QUOTE);\n                last = i + 1;\n                break;\n            }\n            case BACK_SLASH: {\n                result.writeCodePoint(BACK_SLASH);\n                last = i + 1;\n                break;\n            }\n            case FWD_SLASH: {\n                result.writeCodePoint(FWD_SLASH);\n                last = i + 1;\n                break;\n            }\n            case CHAR_B: {\n                result.writeCodePoint(BACKSPACE);\n                last = i + 1;\n                break;\n            }\n            case CHAR_F: {\n                result.writeCodePoint(FORM_FEED);\n                last = i + 1;\n                break;\n            }\n            case CHAR_N: {\n                result.writeCodePoint(NEW_LINE);\n                last = i + 1;\n                break;\n            }\n            case CHAR_R: {\n                result.writeCodePoint(CARRIAGE_RETURN);\n                last = i + 1;\n                break;\n            }\n            case CHAR_T: {\n                result.writeCodePoint(TAB);\n                last = i + 1;\n                break;\n            }\n            case CHAR_U: {\n                const code = u16.parse(data.slice(i + 1, i + 5), 16);\n                result.writeCodePoint(code);\n                i += 4;\n                last = i + 1;\n                break;\n            }\n            default: {\n                throw new Error(`JSON: Cannot parse \"${data}\" as string. Invalid escape sequence: \\\\${data.charAt(i)}`);\n            }\n        }\n    }\n    if (end > last) {\n        result.write(data, last, end);\n    }\n    return result.toString()\n}","import {  unsafeCharCodeAt } from \"../util\";\nimport { CHAR_A, BACK_SLASH, COMMA, CHAR_E, CHAR_F, CHAR_L, BRACE_LEFT, BRACKET_LEFT, CHAR_N, QUOTE, CHAR_R, BRACE_RIGHT, BRACKET_RIGHT, CHAR_S, CHAR_T, CHAR_U } from \"../chars\";\nimport { isSpace } from \"util/string\";\n\n// @ts-ignore: Decorator valid here\n@inline export function deserializeObject<T>(data: string): T {\n  const schema: nonnull<T> = changetype<nonnull<T>>(\n    __new(offsetof<nonnull<T>>(), idof<nonnull<T>>())\n  );\n\n  // @ts-ignore\n  schema.__INITIALIZE();\n\n  let key_start: i32 = 0;\n  let key_end: i32 = 0;\n  let isKey = false;\n  let depth = 0;\n  let outerLoopIndex = 1;\n  for (; outerLoopIndex < data.length - 1; outerLoopIndex++) {\n    const char = unsafeCharCodeAt(data, outerLoopIndex);\n    if (char === BRACKET_LEFT) {\n      for (\n        let arrayValueIndex = outerLoopIndex;\n        arrayValueIndex < data.length - 1;\n        arrayValueIndex++\n      ) {\n        const char = unsafeCharCodeAt(data, arrayValueIndex);\n        if (char === BRACKET_LEFT) {\n          depth++;\n        } else if (char === BRACKET_RIGHT) {\n          depth--;\n          if (depth === 0) {\n            ++arrayValueIndex;\n            // @ts-ignore\n            schema.__DESERIALIZE(data, key_start, key_end, outerLoopIndex, arrayValueIndex);\n            outerLoopIndex = arrayValueIndex;\n            isKey = false;\n            break;\n          }\n        }\n      }\n    } else if (char === BRACE_LEFT) {\n      for (\n        let objectValueIndex = outerLoopIndex;\n        objectValueIndex < data.length - 1;\n        objectValueIndex++\n      ) {\n        const char = unsafeCharCodeAt(data, objectValueIndex);\n        if (char === BRACE_LEFT) {\n          depth++;\n        } else if (char === BRACE_RIGHT) {\n          depth--;\n          if (depth === 0) {\n            ++objectValueIndex;\n            // @ts-ignore\n            schema.__DESERIALIZE(data, key_start, key_end, outerLoopIndex, objectValueIndex);\n            outerLoopIndex = objectValueIndex;\n            isKey = false;\n            break;\n          }\n        }\n      }\n    } else if (char === QUOTE) {\n      let escaping = false;\n      for (\n        let stringValueIndex = ++outerLoopIndex;\n        stringValueIndex < data.length - 1;\n        stringValueIndex++\n      ) {\n        const char = unsafeCharCodeAt(data, stringValueIndex);\n        if (char === BACK_SLASH && !escaping) {\n          escaping = true;\n        } else {\n          if (char === QUOTE && !escaping) {\n            if (isKey === false) {\n              key_start = outerLoopIndex;\n              key_end = stringValueIndex;\n              isKey = true;\n            } else {\n              // @ts-ignore\n              schema.__DESERIALIZE(data, key_start, key_end, outerLoopIndex - 1, stringValueIndex + 1);\n              isKey = false;\n            }\n            outerLoopIndex = ++stringValueIndex;\n            break;\n          }\n          escaping = false;\n        }\n      }\n    } else if (\n      char == CHAR_N &&\n      unsafeCharCodeAt(data, outerLoopIndex + 1) === CHAR_U &&\n      unsafeCharCodeAt(data, outerLoopIndex + 2) === CHAR_L &&\n      unsafeCharCodeAt(data, outerLoopIndex + 3) === CHAR_L\n    ) {\n      // @ts-ignore\n      schema.__DESERIALIZE(data, key_start, key_end, outerLoopIndex, outerLoopIndex + 4);\n      outerLoopIndex += 3;\n      isKey = false;\n    } else if (\n      char === CHAR_T &&\n      unsafeCharCodeAt(data, outerLoopIndex + 1) === CHAR_R &&\n      unsafeCharCodeAt(data, outerLoopIndex + 2) === CHAR_U &&\n      unsafeCharCodeAt(data, outerLoopIndex + 3) === CHAR_E\n    ) {\n      // @ts-ignore\n      schema.__DESERIALIZE(data, key_start, key_end, outerLoopIndex, outerLoopIndex + 4);\n      outerLoopIndex += 3;\n      isKey = false;\n    } else if (\n      char === CHAR_F &&\n      unsafeCharCodeAt(data, outerLoopIndex + 1) === CHAR_A &&\n      unsafeCharCodeAt(data, outerLoopIndex + 2) === CHAR_L &&\n      unsafeCharCodeAt(data, outerLoopIndex + 3) === CHAR_S &&\n      unsafeCharCodeAt(data, outerLoopIndex + 4) === CHAR_E\n    ) {\n      // @ts-ignore\n      schema.__DESERIALIZE(data, key_start, key_end, outerLoopIndex, outerLoopIndex + 5);\n      outerLoopIndex += 4;\n      isKey = false;\n    } else if ((char >= 48 && char <= 57) || char === 45) {\n      let numberValueIndex = ++outerLoopIndex;\n      for (; numberValueIndex < data.length; numberValueIndex++) {\n        const char = unsafeCharCodeAt(data, numberValueIndex);\n        if (char === COMMA || char === BRACE_RIGHT || isSpace(char)) {\n          // @ts-ignore\n          schema.__DESERIALIZE(data, key_start, key_end, outerLoopIndex - 1, numberValueIndex);\n          outerLoopIndex = numberValueIndex;\n          isKey = false;\n          break;\n        }\n      }\n    }\n  }\n  return schema;\n}","import { Virtual } from \"as-virtual/assembly\";\nimport { containsCodePoint, unsafeCharCodeAt } from \"../util\";\nimport {\n    CHAR_A,\n    BACK_SLASH,\n    COLON,\n    COMMA,\n    CHAR_E,\n    CHAR_F,\n    CHAR_L,\n    BRACE_LEFT,\n    BRACKET_LEFT,\n    CHAR_N,\n    QUOTE,\n    CHAR_R,\n    BRACE_RIGHT,\n    BRACKET_RIGHT,\n    CHAR_S,\n    CHAR_T,\n    CHAR_U\n} from \"../chars\";\nimport { deserializeBoolean } from \"./bool\";\nimport { JSON } from \"..\";\nimport { deserializeString } from \"./string\";\nimport { isSpace } from \"util/string\";\nimport { deserializeInteger } from \"./integer\";\nimport { deserializeFloat } from \"./float\";\n\n// @ts-ignore: Decorator valid here\n@inline export function deserializeMap<T extends Map>(data: string): T {\n\n    const map: nonnull<T> = changetype<nonnull<T>>(\n        __new(offsetof<nonnull<T>>(), idof<nonnull<T>>())\n    );\n\n    const key = Virtual.createEmpty<string>();\n    let isKey = false;\n    let depth = 0;\n    let outerLoopIndex = 1;\n    for (; outerLoopIndex < data.length - 1; outerLoopIndex++) {\n        const char = unsafeCharCodeAt(data, outerLoopIndex);\n        if (char === BRACKET_LEFT) {\n            for (\n                let arrayValueIndex = outerLoopIndex;\n                arrayValueIndex < data.length - 1;\n                arrayValueIndex++\n            ) {\n                const char = unsafeCharCodeAt(data, arrayValueIndex);\n                if (char === BRACKET_LEFT) {\n                    depth++;\n                } else if (char === BRACKET_RIGHT) {\n                    depth--;\n                    if (depth === 0) {\n                        ++arrayValueIndex;\n                        map.set(deserializeMapKey<indexof<T>>(key), JSON.parse<valueof<T>>(data.slice(outerLoopIndex, arrayValueIndex)));\n                        outerLoopIndex = arrayValueIndex;\n                        isKey = false;\n                        break;\n                    }\n                }\n            }\n        } else if (char === BRACE_LEFT) {\n            for (\n                let objectValueIndex = outerLoopIndex;\n                objectValueIndex < data.length - 1;\n                objectValueIndex++\n            ) {\n                const char = unsafeCharCodeAt(data, objectValueIndex);\n                if (char === BRACE_LEFT) {\n                    depth++;\n                } else if (char === BRACE_RIGHT) {\n                    depth--;\n                    if (depth === 0) {\n                        ++objectValueIndex;\n                        map.set(deserializeMapKey<indexof<T>>(key), JSON.parse<valueof<T>>(data.slice(outerLoopIndex, objectValueIndex)));\n                        outerLoopIndex = objectValueIndex;\n                        isKey = false;\n                        break;\n                    }\n                }\n            }\n        } else if (char === QUOTE) {\n            let escaping = false;\n            for (\n                let stringValueIndex = ++outerLoopIndex;\n                stringValueIndex < data.length - 1;\n                stringValueIndex++\n            ) {\n                const char = unsafeCharCodeAt(data, stringValueIndex);\n                if (char === BACK_SLASH && !escaping) {\n                    escaping = true;\n                } else {\n                    if (\n                        char === QUOTE && !escaping\n                    ) {\n                        if (isKey === false) {\n                            // perf: we can avoid creating a new string here if the key doesn't contain any escape sequences\n                            if (containsCodePoint(data, BACK_SLASH, outerLoopIndex, stringValueIndex)) {\n                                key.reinst(deserializeString(data, outerLoopIndex - 1, stringValueIndex));\n                            } else {\n                                key.reinst(data, outerLoopIndex, stringValueIndex);\n                            }\n                            isKey = true;\n                        } else {\n                            if (isString<valueof<T>>()) {\n                                const value = deserializeString(data, outerLoopIndex - 1, stringValueIndex);\n                                map.set(deserializeMapKey<indexof<T>>(key), value);\n                            }\n                            isKey = false;\n                        }\n                        outerLoopIndex = ++stringValueIndex;\n                        break;\n                    }\n                    escaping = false;\n                }\n            }\n        } else if (\n            char == CHAR_N &&\n            unsafeCharCodeAt(data, ++outerLoopIndex) === CHAR_U &&\n            unsafeCharCodeAt(data, ++outerLoopIndex) === CHAR_L &&\n            unsafeCharCodeAt(data, ++outerLoopIndex) === CHAR_L) {\n            if (isNullable<valueof<T>>()) {\n                map.set(deserializeMapKey<indexof<T>>(key), null);\n            }\n            isKey = false;\n        } else if (\n            char === CHAR_T &&\n            unsafeCharCodeAt(data, ++outerLoopIndex) === CHAR_R &&\n            unsafeCharCodeAt(data, ++outerLoopIndex) === CHAR_U &&\n            unsafeCharCodeAt(data, ++outerLoopIndex) === CHAR_E\n        ) {\n            if (isBoolean<valueof<T>>()) {\n                map.set(deserializeMapKey<indexof<T>>(key), true);\n            }\n            isKey = false;\n        } else if (\n            char === CHAR_F &&\n            unsafeCharCodeAt(data, ++outerLoopIndex) === CHAR_A &&\n            unsafeCharCodeAt(data, ++outerLoopIndex) === CHAR_L &&\n            unsafeCharCodeAt(data, ++outerLoopIndex) === CHAR_S &&\n            unsafeCharCodeAt(data, ++outerLoopIndex) === CHAR_E\n        ) {\n            if (isBoolean<valueof<T>>()) {\n                map.set(deserializeMapKey<indexof<T>>(key), false);\n            }\n            isKey = false;\n        } else if ((char >= 48 && char <= 57) || char === 45) {\n            let numberValueIndex = ++outerLoopIndex;\n            for (; numberValueIndex < data.length; numberValueIndex++) {\n                const char = unsafeCharCodeAt(data, numberValueIndex);\n                if (char === COLON || char === COMMA || char === BRACE_RIGHT || isSpace(char)) {\n                    if (isInteger<valueof<T>>()) {\n                        map.set(deserializeMapKey<indexof<T>>(key), deserializeInteger<valueof<T>>(data.slice(outerLoopIndex - 1, numberValueIndex)));\n                    } else if (isFloat<valueof<T>>()) {\n                        map.set(deserializeMapKey<indexof<T>>(key), deserializeFloat<valueof<T>>(data.slice(outerLoopIndex - 1, numberValueIndex)));\n                    }\n                    outerLoopIndex = numberValueIndex;\n                    isKey = false;\n                    break;\n                }\n            }\n        }\n    }\n\n    return map;\n}\n\n//@ts-ignore: Decorator\nfunction deserializeMapKey<T>(key: Virtual<string>): T {\n    const k = key.copyOut();\n    if (isString<T>()) {\n        return k as T;\n    } else if (isBoolean<T>()) {\n        return deserializeBoolean(k) as T;\n    } else if (isInteger<T>()) {\n        return deserializeInteger<T>(k);\n    } else if (isFloat<T>()) {\n        return deserializeFloat<T>(k);\n    }\n\n    throw new Error(`JSON: Cannot parse JSON object to a Map with a key of type ${nameof<T>()}`);\n}","// @ts-ignore: Decorator valid here\n@inline export function deserializeDate(dateTimeString: string): Date {\n    // Use AssemblyScript's date parser\n    const d = Date.fromString(dateTimeString);\n  \n    // Return a new object instead of the one that the parser returned.\n    // This may seem redundant, but addreses the issue when Date\n    // is globally aliased to wasi_Date (or some other superclass).\n    return new Date(d.getTime());\n  }\n  ","const enum Discriminator {\n  Bool,\n   I8, I16, I32, I64,\n   U8, U16, U32, U64,\n  F32, F64,\n  UnmanagedRef,\n  ManagedRef\n}\n\n// @ts-ignore: decorator\n@inline\nfunction DISCRIMINATOR<T>(): Discriminator {\n  if (isManaged<T>())   return Discriminator.ManagedRef + idof<T>();\n  if (isReference<T>()) return Discriminator.UnmanagedRef;\n  const value: T = 0;\n  if (value instanceof bool) return Discriminator.Bool;\n  if (value instanceof i8)   return Discriminator.I8;\n  if (value instanceof i16)  return Discriminator.I16;\n  if (value instanceof i32)  return Discriminator.I32;\n  if (value instanceof i64)  return Discriminator.I64;\n  if (value instanceof u8)   return Discriminator.U8;\n  if (value instanceof u16)  return Discriminator.U16;\n  if (value instanceof u32)  return Discriminator.U32;\n  if (value instanceof u64)  return Discriminator.U64;\n  if (value instanceof f32)  return Discriminator.F32;\n  if (value instanceof f64)  return Discriminator.F64;\n  return unreachable();\n}\n\n// @ts-ignore: decorator\n@inline\nconst STORAGE = offsetof<Variant>(\"storage\");\n\n@final\nexport class Variant {\n\n  @inline static from<T>(value: T): Variant {\n    var out = changetype<Variant>(__new(offsetof<Variant>(), idof<Variant>()));\n    out.set<T>(value);\n    return out;\n  }\n\n  @inline static idof<T>(): i32 {\n    return DISCRIMINATOR<T>();\n  }\n\n  private discriminator: i32;\n  private storage: u64;\n\n  private constructor() { unreachable(); }\n\n  @inline get id(): i32 {\n    return this.discriminator;\n  }\n\n  @inline set<T>(value: T): void {\n    this.discriminator = DISCRIMINATOR<T>();\n    store<T>(changetype<usize>(this), value, STORAGE);\n  }\n\n  @inline get<T>(): T {\n    if (!this.is<T>()) throw new Error(\"type mismatch\");\n    let value = this.getUnchecked<T>();\n    if (isReference<T>() && !isNullable<T>()) {\n      if (!value) throw new Error(\"unexpected null\");\n    }\n    return value;\n  }\n\n  @unsafe @inline getUnchecked<T>(): T {\n    return load<T>(changetype<usize>(this), STORAGE);\n  }\n\n  @inline is<T>(): bool {\n    return this.discriminator == DISCRIMINATOR<T>();\n  }\n\n  @unsafe private __visit(cookie: u32): void {\n    if (this.discriminator >= Discriminator.ManagedRef) {\n      let ptr = this.getUnchecked<usize>();\n      if (ptr) __visit(ptr, cookie);\n    }\n  }\n}\n","// @ts-ignore\n@inline\nconst LOW_MASK: u32 = 0xffffffff;\n\n// @ts-ignore\n@inline\nconst LIMB_BITS: u32 = 32;\n\n// @ts-ignore\n@inline\nconst BASE: u64 = 1 << LIMB_BITS;\n\n//  BigInteger must support values in this range\n//  -2**I32.MAX_VALUE (exclusive) - +2**I32.MAX_VALUE (exclusive)\n// However, realistically memory limits the maximum size of the MpZ\n\n// @ts-ignore\n@inline\nconst MAX_LIMBS: u32 = I32.MAX_VALUE; // 2**31-1, experimental: ~2**27-1, realistic: ~< 2**25-1\n\n// @ts-ignore\n@inline\nfunction LOW(value: u64): u32 {\n  return u32(value & LOW_MASK);\n}\n\n// @ts-ignore\n@inline\nfunction HIGH(value: u64): u32 {\n  return u32(value >> LIMB_BITS);\n}\n\nfunction fromI32(value: i32): MpZ {\n  const neg = value < 0;\n  if (value < 0) {\n    value = -value;\n  }\n  return fromU32(<u32>value, neg);\n}\n\n// @ts-ignore\n@inline\nfunction fromU32(value: u32, neg: boolean = false): MpZ {\n  return new MpZ([u32(value)], neg);\n}\n\nfunction fromI64(value: i64): MpZ {\n  if (value < 0) return fromU64(-(<u64>value), true);\n  return fromU64(<u64>value);\n}\n\nfunction fromU64(value: u64, neg: boolean = false): MpZ {\n  const hi = HIGH(value);\n  const lo = LOW(value);\n  if (hi === 0) {\n    return fromU32(lo, neg);\n  }\n  return new MpZ([lo, hi], neg);\n}\n\nfunction codeToU32(code: u32): u32 {\n  if (code >= 48 && code <= 57) {\n    return <u32>(code - 48);\n  }\n  if (code >= 65 && code <= 90) {\n    return <u32>(code - 55);\n  }\n  if (code >= 97 && code <= 122) {\n    return <u32>(code - 87);\n  }\n  throw new Error(`Invalid digit code ${code}`);\n}\n\nfunction fromStringU(value: string, base: u32 = 10): MpZ {\n  let res = MpZ.ZERO;\n  if (value === '0') return res;\n  for (let i = 0; i < value.length; i++) {\n    const code: u32 = value.charCodeAt(i);\n    const val = codeToU32(code);\n    res = res.mul(base).add(val);\n  }\n  return res;\n}\n\nfunction getBase(str: string): u32 {\n  if (str.length < 3) return 10;\n\n  if (str.charAt(0) === '0') {\n    switch (str.charCodeAt(1)) {\n      case 98: // b\n      case 66: // B\n        return 2;\n      case 111: // o\n      case 79: // O\n        return 8;\n      case 120: // x\n      case 88: // X\n        return 16;\n    }\n  }\n  return 10;\n}\n\nfunction fromString(value: string): MpZ {\n  const neg = value.substr(0, 1) === '-';\n  value = neg ? value.substr(1) : value;\n  const base = getBase(value);\n\n  const r =\n    base === 10 ? fromStringU(value, 10) : fromStringU(value.substr(2), base);\n  return neg ? r.negate() : r;\n}\n\n// @ts-ignore\n@lazy\nconst LOG2_10: f64 = Math.log2(10);\n\n// Constants for decimal conversion\n// @ts-ignore\n@inline\nconst DIGITS_PER_LIMB = 9;\n\n// @ts-ignore\n@inline\nconst TO_DECIMAL_N = 1000000000; // 10 ** 9;\n\n/** @internal */\nexport class DivRem<R> {\n  div!: MpZ;\n  rem!: R;\n}\n\n/**\n * ## `as-mpz` API\n *\n * Value is stored as a sign and magnitude.\n *\n * > Note: Arithmatic methods and operators can be used interchangably, with operators acting as shorthand for the methods.\n * > However, unlike instance methods, the operators do not coerce inputs to an MpZ.\n */\n\n// @ts-ignore\n@final\nexport class MpZ {\n  // Contains the size and sign of the MpZ\n  // The sign is stored as the negation of the size\n  // This size excludes leading zero limbs (except for least significant limb)\n  protected readonly _sgn_size: i32;\n\n  // Contains the limbs of the MpZ\n  // The last limb is the most significant\n  // The first limb is the least significant\n  // The most significant limb may be zero, never use _data.length to get the size\n  protected readonly _data: StaticArray<u32>;\n\n  // Should not be used directly\n  // Mutating _data will cause unexpected behavior\n  constructor(data: StaticArray<u32>, neg: boolean = false) {\n    assert(ASC_NO_ASSERT || data.length > 0, 'MpZ must have at least 1 limb');\n\n    let size = data.length;\n\n    // Reduce size by leading zeros\n    while (size > 1 && unchecked(data[size - 1] === 0)) {\n      size--;\n    }\n\n    if (size === 0) {\n      this._data = [0];\n      this._sgn_size = 1;\n    } else {\n      this._data = data;\n      this._sgn_size = neg ? -size : size;\n    }\n  }\n\n  /**\n   * ### Constructor\n   */\n\n  /**\n   * #### `MpZ.from(value: i32 | u32 | i64 | u64 | string): MpZ`\n   *\n   * Creates a new MpZ from a number or string.  The `MpZ.from` method accepts a number or string. The string can be in decimal or hexadecimal format (prefixed with `0x`). The string can also be prefixed with `-` to indicate a negative number.\n   *\n   * > Note: The MpZ class should not be instantiated directly (using `new`). Instead use the static `MpZ.from` method to create a new MpZ.\n   */\n  static from<T>(val: T): MpZ {\n    if (val instanceof MpZ) return val;\n    if (val instanceof i32) return fromI32(val as i32);\n    if (val instanceof u32) return fromU32(val as u32);\n    if (val instanceof i64) return fromI64(val as i64);\n    if (val instanceof u64) return fromU64(val as u64);\n    if (typeof val === 'string') return fromString(val);\n\n    throw new TypeError('Unsupported generic type ' + nameof<T>(val));\n  }\n\n  /**\n   * ### Instance Methods\n   */\n\n  /**\n   * #### `#isNeg(): boolean`\n   *\n   * @returns `true` if `this` MpZ is negative, otherwise `false`.\n   */\n  // @ts-ignore\n  @inline\n  get isNeg(): boolean {\n    return this._sgn_size < 0;\n  }\n\n  // Returns the number of limbs in `this` MpZ (excluding leading zeros)\n  // @ts-ignore\n  @inline\n  get size(): i32 {\n    return this._sgn_size < 0 ? -this._sgn_size : this._sgn_size;\n  }\n\n  /**\n   * #### `#abs(): MpZ`\n   *\n   * @returns the absolute value of `this` MpZ.\n   */\n  abs(): MpZ {\n    return this.isNeg ? new MpZ(this._data) : this;\n  }\n\n  /**\n   * #### `#sign(): MpZ`\n   *\n   * @returns the sign of `this` MpZ, indicating whether x is positive (`1`), negative (`-1`), or zero (`0`).\n   */\n  sign(): i32 {\n    if (this._sgn_size < 0) return -1;\n    if (this.eqz()) return 0;\n    return 1;\n  }\n\n  /**\n   * #### `#isOdd(): MpZ`\n   *\n   * @returns `true` if `this` MpZ is odd, otherwise `false`.\n   */\n  isOdd(): boolean {\n    return (unchecked(this._data[0]) & 1) === 1;\n  }\n\n  /**\n   * #### `#isEven(): boolean`\n   *\n   * @returns `true` if `this` MpZ is even, otherwise `false`.\n   */\n  isEven(): boolean {\n    return (unchecked(this._data[0]) & 1) === 0;\n  }\n\n  /**\n   * #### `#negate(): MpZ`\n   *\n   * @returns the negation of `this` MpZ (`-this`).\n   */\n  // @ts-ignore\n  negate(): MpZ {\n    if (this.eqz()) return MpZ.ZERO;\n    return new MpZ(this._data, !this.isNeg);\n  }\n\n  // *** Addition ***\n\n  /**\n   * #### `#add(rhs: i32 | u32 | i64 | u64 | MpZ): MpZ`\n   *\n   * @returns the sum of `this` MpZ and `rhs`.\n   */\n  // @ts-ignore\n  add<T>(rhs: T): MpZ {\n    const y = MpZ.from(rhs);\n\n    if (this.isNeg && y.isNeg) return this._uadd(y).negate(); // -a + -b = -(a + b)\n    if (this.isNeg) return y._usub(this); // -a + b = b - a\n    if (y.isNeg) return this._usub(y); // a + -b = a - b\n    return this._uadd(y);\n  }\n\n  // unsigned addition\n  // treats values as unsigned\n  protected _uadd(rhs: MpZ): MpZ {\n    if (this.size < rhs.size) return rhs._uadd(this); // a + b = b + a\n    if (rhs.size === 1) return this._uaddU32(unchecked(rhs._data[0]));\n    return this.__uadd(rhs);\n  }\n\n  // unsigned addition\n  // ordered such that Size(lhs) > Size(rhs)\n  // treats values as unsigned\n  protected __uadd(rhs: MpZ): MpZ {\n    const q = this.size;\n    const p = rhs.size;\n\n    assert(ASC_NO_ASSERT || q >= p, '_uadd: Size(lhs) must be >= Size(rhs)');\n\n    const z = new StaticArray<u32>(q + 1);\n\n    let k: bool = 0;\n    let i: i32 = 0;\n    for (; i < p; ++i) {\n      const lx = unchecked(this._data[i]);\n      const ly = unchecked(rhs._data[i]);\n      unchecked((z[i] = lx + ly + k));\n      k = unchecked(z[i] < lx) || unchecked(k && z[i] === lx);\n    }\n    for (; i < q; ++i) {\n      const lx = unchecked(this._data[i]);\n      unchecked((z[i] = lx + k));\n      k = unchecked(z[i] < lx);\n    }\n    unchecked((z[q] = k));\n\n    return new MpZ(z);\n  }\n\n  // unsigned addition by uint32\n  // treats values as unsigned\n  protected _uaddU32(rhs: u32): MpZ {\n    const q = this.size;\n    const z = new StaticArray<u32>(q + 1);\n\n    let k: u32 = rhs;\n    for (let i: i32 = 0; i < q; ++i) {\n      unchecked((z[i] = k + this._data[i]));\n      k = unchecked(z[i] < this._data[i]) ? 1 : 0;\n    }\n    unchecked((z[q] = k));\n    return new MpZ(z);\n  }\n\n  /**\n   * #### `#inc(): MpZ`\n   *\n   * @returns the increment of `this` MpZ (`this + 1`).\n   */\n  @operator.prefix('++')\n  @operator.postfix('++')\n  inc(): MpZ {\n    if (this.isNeg) return this._udec().negate(); // -a + 1 = -(a - 1)\n    return this._uinc();\n  }\n\n  protected _uinc(): MpZ {\n    // TODO: optimize by couting bits?\n    const q = this.size;\n    const z = new StaticArray<u32>(q + 1);\n\n    let k: bool = 1;\n    for (let i: i32 = 0; i < q; ++i) {\n      unchecked((z[i] = k + this._data[i]));\n      k = unchecked(z[i] < this._data[i]);\n    }\n    unchecked((z[q] = k));\n    return new MpZ(z);\n  }\n\n  // *** Subtraction ***\n\n  /**\n   * #### `#sub(rhs: i32 | u32 | i64 | u64 | MpZ): MpZ`\n   *\n   * @returns the difference of `this` MpZ and the `rhs`.\n   */\n  sub<T>(rhs: T): MpZ {\n    const y = MpZ.from(rhs);\n\n    const sx = this.isNeg;\n    const sy = y.isNeg;\n\n    if (sx && sy) return y._usub(this); // -a - -b = b - a\n    if (sx) return this._uadd(y).negate(); // -a - b = -(a + b)\n    if (sy) return this._uadd(y); // a - -b = a + b\n    return this._usub(y);\n  }\n\n  // unsigned subtraction\n  // treats values as unsigned\n  protected _usub(rhs: MpZ): MpZ {\n    if (this._ucmp(rhs) < 0) return rhs._usub(this).negate(); // a - b = -(b - a)\n    if (rhs.size === 1) return this._usubU32(unchecked(rhs._data[0]));\n    return this.__usub(rhs);\n  }\n\n  // unsigned sub\n  // ordered such that lhs >= rhs\n  // treats values as unsigned\n  protected __usub(rhs: MpZ): MpZ {\n    const q = this.size;\n    const p = rhs.size;\n\n    assert(ASC_NO_ASSERT || q >= p, '_uadd: Size(lhs) must be >= Size(rhs)');\n\n    const z = new StaticArray<u32>(q);\n\n    let k: i64 = 0;\n    let i: i32 = 0;\n    for (; i < p; ++i) {\n      const lx = unchecked(this._data[i]);\n      const ly = unchecked(rhs._data[i]);\n\n      k = i64(lx) - i64(ly) - k;\n      unchecked((z[i] = LOW(k)));\n      k = k < 0 ? 1 : 0;\n    }\n    for (; i < q; ++i) {\n      const lx = unchecked(this._data[i]);\n\n      k = i64(lx) - k;\n      unchecked((z[i] = LOW(k)));\n      k = k < 0 ? 1 : 0;\n    }\n    return new MpZ(z);\n  }\n\n  // unsigned sub by uint32\n  // treats values as unsigned\n  protected _usubU32(rhs: u32): MpZ {\n    const q = this.size;\n    const z = new StaticArray<u32>(q);\n\n    let k: u32 = rhs;\n    for (let i: i32 = 0; i < q; ++i) {\n      const lx = unchecked(this._data[i]);\n\n      unchecked((z[i] = lx - k));\n      k = k > lx ? 1 : 0;\n    }\n\n    return new MpZ(z);\n  }\n\n  /**\n   * #### `#dec(): MpZ`\n   *\n   * @returns the decrement of `this` MpZ (`this - 1`).\n   */\n  @operator.prefix('--')\n  @operator.postfix('--')\n  dec(): MpZ {\n    if (this.isNeg) return this._uinc().negate(); // -a - 1 = -(a + 1)\n    if (this.eqz()) return MpZ.ONE.negate();\n    return this._udec();\n  }\n\n  protected _udec(): MpZ {\n    // TODO: optimize by couting bits?\n    const q = this.size;\n    const z = new StaticArray<u32>(q);\n\n    let k: bool = 1;\n    for (let i: i32 = 0; i < q; ++i) {\n      const lx = unchecked(this._data[i]);\n\n      unchecked((z[i] = lx - k));\n      k = k > lx ? 1 : 0;\n    }\n\n    return new MpZ(z);\n  }\n\n  // *** Multiplication ***\n\n  /**\n   * #### `#mul(rhs: i32 | u32 | i64 | u64 | MpZ): MpZ`\n   *\n   * @returns the product of `this` MpZ and the `rhs` (`this * rhs`).\n   */\n  mul<T>(rhs: T): MpZ {\n    const y = MpZ.from(rhs);\n\n    // if (u64(this.size) + u64(y.size) > u64(MAX_LIMBS)) {\n    //   throw new RangeError('Maximum MpZ size exceeded');\n    // }\n\n    if (this.eqz() || y.eqz()) return MpZ.ZERO;\n    if (this.eq(MpZ.ONE)) return y;\n    if (y.eq(MpZ.ONE)) return this;\n\n    const q = this.size;\n    const p = y.size;\n\n    let z: MpZ;\n\n    if (p === 1) {\n      z = this._umulU32(unchecked(y._data[0]));\n    } else if (q === 1) {\n      z = y._umulU32(unchecked(this._data[0]));\n    } else {\n      z = this._umul(y);\n    }\n\n    return this.isNeg !== y.isNeg ? z.negate() : z;\n  }\n\n  /**\n   * #### `#mul_pow2(rhs: i32 | u32 | i64 | u64 | MpZ): MpZ`\n   *\n   * @returns the product of `this` MpZ multiplied and `2**rhs` (`this * 2 ** rhs`).\n   */\n  // multiply by power of 2, using bit shifts\n  mul_pow2<T>(rhs: T): MpZ {\n    const y = MpZ.from(rhs);\n    if (y.eqz()) return this;\n    if (this.eqz()) return MpZ.ZERO;\n    return this._leftShift(y);\n  }\n\n  // unsigned mul\n  // treats values as unsigned\n  protected _umul(rhs: MpZ): MpZ {\n    const q = this.size;\n    const p = rhs.size;\n    const z = new StaticArray<u32>(q + p);\n\n    for (let i: i32 = 0; i < q; ++i) {\n      let c: u64 = 0;\n      for (let j: i32 = 0; j < p; ++j) {\n        const k = i + j;\n        c +=\n          u64(unchecked(this._data[i])) * u64(unchecked(rhs._data[j])) +\n          u64(unchecked(z[k]));\n        unchecked((z[k] = LOW(c)));\n        c = HIGH(c);\n      }\n      unchecked((z[i + p] = LOW(c)));\n    }\n\n    return new MpZ(z);\n  }\n\n  // unsigned square\n  // treats values as unsigned\n  // TODO: optimize for aij = aji\n  protected _usqr(): MpZ {\n    const q = this.size;\n    const z = new StaticArray<u32>(q * 2);\n\n    for (let i: i32 = 0; i < q; ++i) {\n      let carry: u64 = 0;\n      for (let j: i32 = 0; j < q; ++j) {\n        const k = i + j;\n        carry +=\n          u64(unchecked(this._data[i])) * u64(unchecked(this._data[j])) +\n          u64(unchecked(z[k]));\n        unchecked((z[k] = LOW(carry)));\n        carry = HIGH(carry);\n      }\n      unchecked((z[i + q] = LOW(carry)));\n    }\n\n    return new MpZ(z);\n  }\n\n  // unsigned multiply by uint32\n  // treats values as unsigned\n  protected _umulU32(rhs: u32): MpZ {\n    const q = this.size;\n    const z = new StaticArray<u32>(q + 1);\n\n    let c: u64 = 0;\n    for (let i: i32 = 0; i < q; ++i) {\n      c += u64(unchecked(this._data[i])) * u64(rhs);\n      unchecked((z[i] = LOW(c)));\n      c = HIGH(c);\n    }\n    unchecked((z[q] = LOW(c)));\n\n    return new MpZ(z);\n  }\n\n  // unsigned mul by power of 2\n  // treats values as unsigned\n  protected _umulpow2U32(rhs: u32): MpZ {\n    const q = this.size;\n    const z = new StaticArray<u32>(q + 1);\n\n    let c: u64 = 0;\n    for (let i: i32 = 0; i < q; ++i) {\n      c += u64(unchecked(this._data[i])) << rhs;\n      unchecked((z[i] = LOW(c)));\n      c = HIGH(c);\n    }\n    unchecked((z[q] = LOW(c)));\n\n    return new MpZ(z);\n  }\n\n  // *** Division ***\n\n  /**\n   * #### `#div(rhs: MpZ): MpZ`\n   *\n   * @returns the quotient of `this` MpZ divided by the `rhs` (`trunc(this / rhs)`) truncated towards zero.\n   * @throws RangeError if `rhs` is zero.\n   */\n  div<T>(rhs: T): MpZ {\n    if (this.eqz()) return MpZ.ZERO;\n\n    const y = MpZ.from(rhs);\n\n    if (y.eqz()) throw new RangeError('Divide by zero');\n    if (y.eq(MpZ.ONE)) return this; // x / 1 = x\n    if (this.eq(y)) return MpZ.ONE; // x / x = 1\n\n    const sx = this.isNeg;\n    const sy = y.isNeg;\n\n    const n = this.abs();\n    const d = y.abs();\n\n    if (n.lt(d)) return MpZ.ZERO; // n / d = 0 if n < d\n\n    const sz = sx !== sy;\n\n    if (d.size === 1) {\n      const r = n._udivU32(unchecked(d._data[0]));\n      return sz ? r.negate() : r;\n    }\n\n    const p = n._udiv(d);\n    return sz ? p.negate() : p;\n  }\n\n  /**\n   * #### `#div_pow2(rhs: i32 | u32 | i64 | u64 | MpZ): MpZ`\n   *\n   * @returns the quotant of `this` MpZand `2**rhs` (`this / 2 ** rhs`) truncated towards zero.\n   */\n  // divide by power of 2, using bit shifts\n  div_pow2<T>(rhs: T): MpZ {\n    const y = MpZ.from(rhs);\n    if (y.eqz()) return this;\n    if (this.eqz()) return MpZ.ZERO;\n    return this._rightShift(y);\n  }\n\n  // unsigned divide, lhs > rhs\n  // Donald Knuths Algorithm D\n  protected _udiv(rhs: MpZ): MpZ {\n    assert(ASC_NO_ASSERT || this > rhs, '_udiv: lhs must be greater than rhs');\n\n    const m = this.size;\n    const n = rhs.size;\n    const z = new StaticArray<u32>(m - n + 1);\n\n    // D1. [Normalize]\n    // Normalize by shifting rhs left just enough so that\n    // its high-order bit is on, and shift lhs left the\n    // same amount.\n    const s = rhs._clz();\n    const un = this._umul_pow2(s).toArray();\n    const vn = rhs._umul_pow2(s).toArray();\n\n    // We may have to append a high-order\n    // digit on the dividend;\n    if (un.length === m) {\n      un.push(0);\n    }\n\n    assert(ASC_NO_ASSERT || un.length === m + 1, '_udiv: un.length !== m + 1');\n    assert(ASC_NO_ASSERT || vn.length === n, '_udiv: vn.length !== n');\n\n    // Main loop.\n    for (let j = m - n; j >= 0; j--) {\n      // D3. [Calculate Q]\n      const un1: u64 =\n        unchecked(u64(un[j + n]) << 32) + unchecked(u64(un[j + n - 1]));\n      const vn1 = unchecked(u64(vn[n - 1]));\n      let qhat: u64 = un1 / vn1;\n      let rhat: u64 = un1 % vn1;\n\n      const vn2 = unchecked(u64(vn[n - 2]));\n      const un2 = unchecked(u64(un[j + n - 2]));\n\n      while (true) {\n        if (qhat >= BASE || LOW(qhat) * vn2 > (rhat << 32) + un2) {\n          qhat -= 1;\n          rhat += vn1;\n          if (rhat < BASE) continue;\n        }\n        break;\n      }\n\n      // D4. [Multiply and subtract]\n      let k: i64 = 0;\n      let t: i64 = 0;\n      for (let i = 0; i < n; i++) {\n        const p: u64 = qhat * unchecked(u64(vn[i]));\n        t = unchecked(u64(un[i + j])) - k - LOW(p);\n        unchecked((un[i + j] = LOW(t)));\n        k = (p >> 32) - (t >> 32);\n      }\n      t = unchecked(u64(un[j + n])) - k;\n      unchecked((un[j + n] = LOW(t)));\n\n      // D5. [Test remainder]\n      unchecked((z[j] = LOW(qhat))); // Store quotient digit.\n      if (t < 0) {\n        // D6. [Add back]\n\n        // If we subtracted too much, add back.\n        z[j] -= 1;\n        k = 0;\n        for (let i = 0; i < n; i++) {\n          t = unchecked(u64(un[i + j]) + u64(vn[i])) + k;\n          unchecked((un[i + j] = LOW(t)));\n          k = t >> 32;\n        }\n        unchecked((un[j + n] = LOW(u64(un[j + n]) + k)));\n      }\n    }\n    return new MpZ(z);\n  }\n\n  // unsigned divide by uint32\n  // treats values as unsigned\n  protected _udivU32(rhs: u32): MpZ {\n    const q = this.size;\n    const z = new StaticArray<u32>(q);\n\n    let r: u64 = 0;\n    for (let i: i32 = this.size - 1; i >= 0; --i) {\n      r = u64(unchecked(this._data[i])) + u64(r << 32);\n      unchecked((z[i] = LOW(r / rhs)));\n      r %= rhs;\n    }\n\n    return new MpZ(z);\n  }\n\n  protected _udivRemU32(rhs: u32): DivRem<u32> {\n    assert(ASC_NO_ASSERT || !this.isNeg, '_udivRemU32: lhs must be positive');\n\n    const q = this.size;\n    const z = new StaticArray<u32>(q);\n\n    let r: u64 = 0;\n    for (let i: i32 = q - 1; i >= 0; --i) {\n      r = u64(unchecked(this._data[i])) + (r << 32);\n      unchecked((z[i] = LOW(r / rhs)));\n      r %= rhs;\n    }\n\n    return { div: new MpZ(z), rem: LOW(r) };\n  }\n\n  // *** Modulus ***\n\n  /**\n   * #### `#mod(rhs: MpZ): MpZ`\n   *\n   * @returns the modulus of `this` MpZ divided by the `rhs`.\n   * @throws RangeError if `rhs` is zero.\n   *\n   * > Note: The `#mod` method is not the same as the `%` operator.  The `%` operator returns the `#rem` of the division of the lhs and rhs, while the `#mod` method returns the modulo of the lhs and rhs.\n   */\n  mod<T>(rhs: T): MpZ {\n    const y = MpZ.from(rhs);\n    const r = this._rem(y);\n    if (this.isNeg === y.isNeg) return r;\n    if (r.eqz()) return MpZ.ZERO;\n    return r.add(y);\n  }\n\n  /**\n   * #### `#rem(rhs: MpZ): MpZ`\n   *\n   * @returns the remainder of `this` MpZ divided by the `rhs` (`this % rhs`).\n   * @throws RangeError if `rhs` is zero.\n   *\n   * > Note: The `#rem` method is the same as the `%` operator.  The `%` operator returns the `#rem` of the division of the lhs and rhs, while the `#mod` method returns the modulo of the lhs and rhs.\n   */\n  rem<T>(rhs: T): MpZ {\n    const y = MpZ.from(rhs);\n    return this._rem(y);\n  }\n\n  protected _rem(rhs: MpZ): MpZ {\n    const q = this.div(rhs);\n    return this.sub(rhs.mul(q));\n  }\n\n  // *** Pow ***\n\n  /**\n   * #### `#pow(rhs: i32 | u32 | i64 | u64 | MpZ): MpZ`\n   *\n   * @returns the value of `this` MpZ raised to the power of `rhs` (`this ** rhs`).\n   */\n  pow<T>(rhs: T): MpZ {\n    const y = MpZ.from(rhs);\n    if (y.isNeg) return MpZ.ZERO;\n\n    if (y.eqz()) return MpZ.ONE;\n    if (this.eqz()) return MpZ.ZERO;\n    if (y.eq(MpZ.ONE)) return this;\n    if (this.eq(MpZ.ONE)) return MpZ.ONE;\n\n    const sz = this.isNeg && y.isOdd();\n    const z =\n      y.size === 1 ? this._upowU32(unchecked(y._data[0])) : this._upow(y);\n    return sz ? z.negate() : z;\n  }\n\n  // unsigned pow\n  // exponentiation by squaring (modified)\n  // ignores sign of base and exponent\n  protected _upow(rhs: MpZ): MpZ {\n    let z = MpZ.ONE;\n    let x: MpZ = this;\n\n    const p = rhs.size;\n    for (let i: i32 = 0; i < p; ++i) {\n      let ly = unchecked(rhs._data[i]);\n\n      for (let j: u32 = 0; j < LIMB_BITS; ++j) {\n        if (ly & 1) {\n          z = z._umul(x);\n        }\n\n        ly >>= 1;\n        if (ly === 0 && i === p - 1) break;\n        x = x._usqr();\n      }\n    }\n\n    return z;\n  }\n\n  // Exponentiation by squaring\n  // Ignores sign of base and exponent\n  protected _upowU32(rhs: u32): MpZ {\n    let z = MpZ.ONE;\n    let x: MpZ = this;\n\n    while (true) {\n      if (rhs & 1) {\n        z = z._umul(x);\n      }\n\n      rhs >>= 1;\n      if (rhs === 0) break;\n      x = x._usqr();\n    }\n\n    return z;\n  }\n\n  /**\n   * #### `#sqrt(): MpZ`\n   *\n   * @returns the greatest integer less than or equal to the square root of `this`.\n   * @throws RangeError if `this` is negative.\n   */\n  isqrt(): MpZ {\n    if (this.isNeg) {\n      throw new RangeError(\n        'Square root of negative number is not a real number'\n      );\n    }\n    if (this.lt(2)) return this;\n\n    let x0 = this._bitShiftRight(1);\n    let x1 = x0._uadd(this.div(x0))._bitShiftRight(1);\n\n    while (x1 < x0) {\n      x0 = x1;\n      x1 = x0._uadd(this.div(x0))._bitShiftRight(1);\n    }\n\n    return x0;\n  }\n\n  /**\n   * #### `#iroot(n: u32): MpZ`\n   *\n   * @returns the greatest integer less than or equal to the nth root of `this`.\n   * @throws RangeError if `n` is zero or `this` is negative and `n` is even.\n   */\n  iroot(k: u32): MpZ {\n    if (k === 0) throw new RangeError('Root must be greater than 0');\n\n    if (this.isNeg) {\n      if (k % 2 === 0) {\n        throw new RangeError('Root of negative number is not a real number');\n      }\n      return this.abs()._uiroot(k).negate();\n    }\n\n    return this._uiroot(k);\n  }\n\n  protected _uiroot(k: u32): MpZ {\n    if (this.lt(2)) return this;\n\n    const n1 = MpZ.from(k - 1);\n\n    let d = this._uaddU32(1);\n    let e: MpZ = this;\n\n    while (e < d) {\n      d = e;\n      e = e\n        ._umul(n1)\n        ._uadd(this.div(e._upow(n1)))\n        ._udivU32(k);\n    }\n\n    return d;\n  }\n\n  /**\n   * #### `#log2(): MpZ`\n   *\n   * @returns the base 2 logarithm of `this`.\n   * @throws RangeError if `this` is negative or zero.\n   */\n  log2(): MpZ {\n    if (this.isNeg) throw new RangeError('Logarithm of negative number');\n    if (this.eqz()) throw new RangeError('Logarithm of zero');\n    if (this.lt(2)) return MpZ.ZERO;\n\n    return MpZ.from(this._bits() - 1);\n  }\n\n  // Returns the ceiling of the base 10 logarithm of `this`\n  // Assumes x > 1\n  protected _ceilLog10(): u64 {\n    if (this.lt(10)) return 1;\n\n    const k = f64(this._bits() - 1);\n    const z = u64(k / LOG2_10); // ~log2(x)/log2(10) < 2.1*10^10\n    return z + 1;\n  }\n\n  /**\n   * #### `#log10(): MpZ`\n   *\n   * @returns the base 10 logarithm of `this`.\n   * @throws RangeError if `this` is negative or zero.\n   */\n  log10(): MpZ {\n    if (this.isNeg) throw new RangeError('Logarithm of negative number');\n    if (this.eqz()) throw new RangeError('Logarithm of zero');\n    if (this.lt(10)) return MpZ.ZERO;\n\n    assert(\n      ASC_NO_ASSERT || this.log2().size < 3,\n      'log10: internal assumption failed'\n    );\n\n    // Correcting ceilLog10\n    const x = this.abs();\n    const z = x._ceilLog10();\n    const t = MpZ.TEN.pow(z);\n    return x.ge(t) ? MpZ.from(z) : MpZ.from(z - 1);\n\n    // Direct implementation\n    // let x = this.abs();\n    // let k: u64 = 0;\n\n    // while (!x.eqz()) {\n    //   x = x.div(10);\n    //   k++;\n    // }\n\n    // return MpZ.from(k - 1);\n  }\n\n  /**\n   * #### `#fact(): MpZ`\n   *\n   * @returns the factorial of `this` MpZ (`this!`).\n   * @throws RangeError if `this` is negative or too large (greater than `MAX_INTEGER`).\n   */\n  fact(): MpZ {\n    if (this.isNeg) throw new RangeError('Factorial of negative number');\n    if (this.eqz()) return MpZ.ONE;\n    if (this.size > 1) throw new RangeError('Factorial of large number');\n    return this._fact();\n  }\n\n  protected _fact(): MpZ {\n    let x = this.toU32();\n    let z = MpZ.ONE;\n    while (x > 1) {\n      z = z.mul(x--);\n    }\n    return z;\n  }\n\n  /**\n   * #### `#gcd(rhs: i32 | u32 | i64 | u64 | MpZ): MpZ`\n   *\n   * @returns the greatest common divisor of `this` MpZ and `rhs`.\n   */\n  gcd<T>(rhs: T): MpZ {\n    const y = MpZ.from(rhs);\n    if (this.eqz()) return y.abs();\n    const x = this.abs();\n    if (y.eqz()) return x;\n\n    return x._gcd(y.abs());\n  }\n\n  protected _gcd(rhs: MpZ): MpZ {\n    let x: MpZ = this;\n    let y = rhs;\n\n    const i = x._ctz();\n    x = x._udiv_pow2(i);\n\n    const j = y._ctz();\n    y = y._udiv_pow2(j);\n\n    const k = min(i, j);\n\n    while (true) {\n      if (y > x) {\n        const t = x;\n        x = y;\n        y = t;\n      }\n\n      x = x._usub(y);\n      if (x.eqz()) return y._umul_pow2(k);\n\n      x = x._udiv_pow2(x._ctz());\n    }\n  }\n\n  /**\n   * #### `#lcm(rhs: i32 | u32 | i64 | u64 | MpZ): MpZ`\n   *\n   * @returns the least common multiple of `this` MpZ and `rhs`.\n   */\n  lcm<T>(rhs: T): MpZ {\n    let y = MpZ.from(rhs);\n    if (this.eqz() || y.eqz()) return MpZ.ZERO;\n\n    const x = this.abs();\n    y = y.abs();\n    return x.mul(y).div(x._gcd(y));\n  }\n\n  // *** Shifts ***\n\n  // Gets the value of the bit at the specified position (2's complement)\n  protected _getBit(n: u64): bool {\n    const limb = <i32>(n / LIMB_BITS);\n    if (limb >= this.size) return this.isNeg;\n\n    const x = this.isNeg ? this.not() : this;\n\n    const mask = 1 << u32(n % LIMB_BITS);\n    const b = unchecked(x._data[limb]) & mask;\n    return this.isNeg === !b ? 1 : 0;\n  }\n\n  // count leading zeros (doesn't count sign bit, treats value as unsigned)\n  protected _clz(): u32 {\n    const d = unchecked(this._data[this.size - 1]);\n    return <u32>clz(d);\n  }\n\n  // count trailing zeros (doesn't count sign bit, treats value as unsigned)\n  protected _ctz(): u64 {\n    if (this.eqz()) return 0;\n\n    let l: u32 = 0;\n    while (unchecked(this._data[l]) === 0) {\n      l++;\n    }\n    return l * LIMB_BITS + ctz(unchecked(this._data[l]));\n  }\n\n  // returns the number of bits in the magnitude excluding leading zeros\n  // doesn't count sign bit, treats value as unsigned\n  protected _bits(): u64 {\n    return u64(this.size) * LIMB_BITS - this._clz();\n  }\n\n  protected _limbShiftLeft(n: u32): MpZ {\n    assert(\n      ASC_NO_ASSERT || n < MAX_LIMBS,\n      '_limbShiftLeft: n must be less than i32.MAX_VALUE'\n    );\n    assert(ASC_NO_ASSERT || n >= 0, '_bitShiftRight: n must be > 0');\n\n    if (n === 0) return this;\n    const data = this._data.slice();\n    const low = new StaticArray<u32>(n);\n    return new MpZ(StaticArray.fromArray<u32>(low.concat(data)));\n  }\n\n  protected _limbShiftRight(n: u32): MpZ {\n    assert(ASC_NO_ASSERT || n >= 0, '_bitShiftRight: n must be > 0');\n\n    if (n === 0) return this;\n    if (n >= <u32>this.size) return MpZ.ZERO;\n    const data = this._data.slice(n);\n    return new MpZ(StaticArray.fromArray<u32>(data));\n  }\n\n  protected _bitShiftLeft(n: u32): MpZ {\n    assert(\n      ASC_NO_ASSERT || n < LIMB_BITS,\n      '_bitShiftLeft: n must be less than LIMB_BITS'\n    );\n    assert(ASC_NO_ASSERT || n >= 0, '_bitShiftRight: n must be > 0');\n\n    return n === 0 ? this : this._umulpow2U32(n);\n  }\n\n  protected _bitShiftRight(n: u32): MpZ {\n    assert(\n      ASC_NO_ASSERT || n < LIMB_BITS,\n      '_bitShiftRight: n must be less than LIMB_BITS'\n    );\n    assert(ASC_NO_ASSERT || n >= 0, '_bitShiftRight: n must be > 0');\n\n    return n === 0 ? this : this._udivPow2U32(n);\n  }\n\n  // unsigned divide by power of 2\n  // treats values as unsigned\n  protected _udivPow2U32(n: u32): MpZ {\n    const q = this.size;\n    const z = new StaticArray<u32>(q);\n    const n2 = 2 ** n;\n\n    let rem: u64 = 0;\n    for (let i: i32 = this.size - 1; i >= 0; --i) {\n      rem = u64(unchecked(this._data[i])) + (rem << 32);\n      unchecked((z[i] = LOW(rem >> n)));\n      rem %= n2;\n    }\n\n    return new MpZ(z);\n  }\n\n  // unsigned multiply by power of 2 using bit shifts\n  // treats values as unsigned\n  protected _umul_pow2(n: u64): MpZ {\n    assert(\n      ASC_NO_ASSERT || n < LIMB_BITS * MAX_LIMBS,\n      '_udiv_pow2: rhs must be < 32*MAX_LIMBS'\n    );\n    assert(ASC_NO_ASSERT || n >= 0, '_udiv_pow2: rhs must be > 0');\n\n    if (n === 0) return this;\n\n    let z: MpZ = this;\n    const limbs = u32(n / LIMB_BITS);\n    if (limbs > 0) z = z._limbShiftLeft(limbs);\n\n    const bits = u32(n % LIMB_BITS);\n    if (bits > 0) z = z._bitShiftLeft(bits);\n\n    return z;\n  }\n\n  // unsigned divide by power of 2 using bit shifts\n  // treats values as unsigned\n  protected _udiv_pow2(n: u64): MpZ {\n    assert(\n      ASC_NO_ASSERT || n < LIMB_BITS * MAX_LIMBS,\n      '_udiv_pow2: rhs must be < 32*MAX_LIMBS'\n    );\n    assert(ASC_NO_ASSERT || n >= 0, '_udiv_pow2: rhs must be > 0');\n\n    if (n === 0) return this;\n\n    let z: MpZ = this;\n\n    const bits = u32(n % LIMB_BITS);\n    if (bits > 0) z = z._bitShiftRight(bits);\n\n    const limbs = u32(n / LIMB_BITS);\n    if (limbs > 0) z = z._limbShiftRight(limbs);\n\n    return z;\n  }\n\n  protected _leftShift(rhs: MpZ): MpZ {\n    if (rhs.size > 2) throw new RangeError('Maximum MpZ size exceeded');\n\n    const n = rhs.toU64();\n    if ((this.size + n) / LIMB_BITS > MAX_LIMBS) {\n      throw new RangeError('Maximum MpZ size exceeded');\n    }\n    return this.isNeg ? this._umul_pow2(n).negate() : this._umul_pow2(n);\n  }\n\n  protected _rightShift(rhs: MpZ): MpZ {\n    if (rhs.size > 2) return MpZ.ZERO;\n\n    const n = rhs.toU64();\n    if (n > LIMB_BITS * MAX_LIMBS) return MpZ.ZERO;\n    return this.isNeg ? this._udiv_pow2(n).negate() : this._udiv_pow2(n);\n  }\n\n  /**\n   * #### `#shiftLeft(rhs: i32 | u32 | i64 | u64 | MpZ): MpZ`\n   *\n   * @returns the value of `this` MpZ left shifted by `rhs` (`this << rhs`). Negative `rhs` values shift right.\n   * @throws RangeError if the result exceeds the maximum MpZ size.\n   *\n   * > Note: The `#shiftLeft` method return the result of the bitwise shift as if the MpZ was a 2's complement signed integer; matching JavaScript's BigInt `<<` operator.\n   */\n  shiftLeft<T>(rhs: T): MpZ {\n    const y = MpZ.from(rhs);\n    if (y.isNeg) return this.shiftRight(y.negate());\n\n    if (y.eqz()) return this;\n    if (this.eqz()) return MpZ.ZERO;\n\n    return this._leftShift(y);\n  }\n\n  /**\n   * #### `#shiftRight(rhs: i32 | u32 | i64 | u64 | MpZ): MpZ`\n   *\n   * @returns the value of `this` MpZ right shifted by `rhs` (`this >> rhs`).  Negative `rhs` values shift left.\n   * @throws RangeError if the result exceeds the maximum MpZ size.\n   *\n   * > Note: The `#shiftLeft` method return the result of the bitwise shift as if the MpZ was a 2's complement signed integer; matching JavaScript's BigInt `>>` operator.\n   */\n  shiftRight<T>(rhs: T): MpZ {\n    const y = MpZ.from(rhs);\n    if (y.isNeg) return this._leftShift(y.negate());\n    if (y.eqz()) return this;\n    if (this.eqz()) return MpZ.ZERO;\n\n    return this.isNeg ? this.not()._rightShift(y).not() : this._rightShift(y);\n  }\n\n  // *** Bitwise operators ***\n\n  /**\n   * #### `#not(): MpZ`\n   *\n   * @returns the bitwise NOT of `this` MpZ (`~this`).\n   *\n   * > Note: The `#not` method returns the result as if the MpZ was a 2's complement signed integer (yeilding `-(x + 1)`); matching JavaScript's BigInt `~` operator.\n   */\n  not(): MpZ {\n    return this.isNeg ? this._udec() : this._uinc().negate();\n  }\n\n  /**\n   * #### `#and(rhs: MpZ): MpZ`\n   *\n   * @returns the bitwise AND of `this` MpZ and `rhs`.\n   *\n   * > Note: The `#and` method returns the result of the bitwise `AND` as if the MpZ was a 2's complement signed integer; matching JavaScript's `&` BigInt operator.\n   */\n  and<T>(rhs: T): MpZ {\n    const y = MpZ.from(rhs);\n    if (!this.isNeg && !y.isNeg) return this._and(y);\n    if (this.isNeg && y.isNeg) return this.not()._or(y.not()).not(); // x & y = ~(~x | ~y)\n    if (this.isNeg) return y._andNot(this.not()); // x & y = y & ~~x\n    return this._andNot(y.not()); // x & y = x & ~~y\n  }\n\n  protected _and(rhs: MpZ): MpZ {\n    const p = this.size;\n    const q = rhs.size;\n    const z = new StaticArray<u32>(q > p ? q : p);\n\n    for (let i: i32 = 0; i < z.length; ++i) {\n      const lx = p > i ? unchecked(this._data[i]) : 0;\n      const ly = q > i ? unchecked(rhs._data[i]) : 0;\n      unchecked((z[i] = lx & ly));\n    }\n\n    return new MpZ(z);\n  }\n\n  // Exponse this?\n  protected _andNot(rhs: MpZ): MpZ {\n    const p = this.size;\n    const q = rhs.size;\n    const z = new StaticArray<u32>(q > p ? q : p);\n\n    for (let i: i32 = 0; i < z.length; ++i) {\n      const lx = p > i ? unchecked(this._data[i]) : 0;\n      const ly = q > i ? unchecked(rhs._data[i]) : 0;\n      unchecked((z[i] = ly === 0 ? lx : lx & ~ly));\n    }\n\n    return new MpZ(z);\n  }\n\n  /**\n   * #### `#or(rhs: MpZ): MpZ`\n   *\n   * @returns the bitwise OR of `this` MpZ and `rhs`.\n   *\n   * > Note: The `#or` method returns the result of the bitwise `OR` as if the MpZ was a 2's complement signed integer; matching JavaScript's BigInt `|` operator.\n   */\n  or<T>(rhs: T): MpZ {\n    const y = MpZ.from(rhs);\n    if (!this.isNeg && !y.isNeg) return this._or(y);\n    if (this.isNeg && y.isNeg) return this.not()._and(y.not()).not(); // x | y = ~(~x & ~y)\n    if (this.isNeg) return this.not()._andNot(y).not(); // x | y = ~(~x & ~y)\n    return y.not()._andNot(this).not(); // x | y = ~(~y & ~x)\n  }\n\n  protected _or(rhs: MpZ): MpZ {\n    const p = this.size;\n    const q = rhs.size;\n    const z = new StaticArray<u32>(q > p ? q : p);\n\n    for (let i: i32 = 0; i < z.length; ++i) {\n      const lx = p > i ? unchecked(this._data[i]) : 0;\n      const ly = q > i ? unchecked(rhs._data[i]) : 0;\n      unchecked((z[i] = lx | ly));\n    }\n\n    return new MpZ(z);\n  }\n\n  /**\n   * #### `#xor(rhs: MpZ): MpZ`\n   *\n   * @returns the bitwise XOR of `this` MpZ and `rhs`.\n   *\n   *  Note: The `#xor` method returns the result of the bitwise `XOR` as if the MpZ was a 2's complement signed integer; matching JavaScript's BigInt `^` operator.\n   */\n  xor<T>(rhs: T): MpZ {\n    const y = MpZ.from(rhs);\n    if (!this.isNeg && !y.isNeg) return this._xor(y);\n    if (this.isNeg && y.isNeg) return this.not()._xor(y.not()); // x ^ y = ~x ^ ~y\n    if (this.isNeg) return y._xor(this.not()).not(); // x ^ y = ~(y ^ ~x)\n    return this._xor(y.not()).not(); // x ^ y = ~(x ^ ~y)\n  }\n\n  protected _xor(rhs: MpZ): MpZ {\n    const p = this.size;\n    const q = rhs.size;\n    const z = new StaticArray<u32>(q > p ? q : p);\n\n    for (let i: i32 = 0; i < z.length; ++i) {\n      const lx = p > i ? unchecked(this._data[i]) : 0;\n      const ly = q > i ? unchecked(rhs._data[i]) : 0;\n      unchecked((z[i] = lx ^ ly));\n    }\n\n    return new MpZ(z);\n  }\n\n  // *** ToString ***\n\n  /**\n   * #### `#toString(radix: i32 = 10): string`\n   *\n   * @returns the value of `this` MpZ as a string. The radix can be from 2 and 36 (inclusive). The default radix is 10.  Negative numbers are prefixed with a `-`.  Negitive radix values return the result in uppercase.\n   * @throws Error if the radix is not between 2 and 36.\n   *\n   * Note: The resulting string is not prefixed with the radix (e.g. `0x` or `0b`) and therefore not compatible as input to `MpZ.from` (radix of 10 excluded).\n   */\n  toString(radix: i32 = 10): string {\n    if (this.eqz()) return '0';\n\n    if (radix < -10) {\n      return this.toString(-radix).toUpperCase();\n    }\n\n    if (radix === 10) {\n      return this.toDecimal();\n    } else if (radix === 16) {\n      return this.isNeg ? `-${this.abs()._uhex()}` : this._uhex();\n    } else if (radix >= 2 && radix <= 36) {\n      return this.isNeg ? `-${this.abs()._uitoa(radix)}` : this._uitoa(radix);\n    } else {\n      throw new Error('toString() radix argument must be between 2 and 36');\n    }\n  }\n\n  /**\n   * #### `#toHex(): string`\n   *\n   * @returns the value of `this` MpZ as a hexadecimal string.\n   *\n   * > Note: The resulting string is prefixed with `0x` and is therefore compatible as input to `MpZ.from`.\n   */\n  toHex(): string {\n    if (this.eqz()) return '0x0';\n\n    const s = this._uhex();\n    return this.isNeg ? `-0x${s}` : `0x${s}`;\n  }\n\n  /**\n   * #### `#toDecimal(): string`\n   *\n   * @returns the value of `this` MpZ as a decimal string.\n   */\n  toDecimal(): string {\n    if (this.eqz()) return '0';\n    return (this.isNeg ? `-` : '') + this.abs()._uitoaDecimal();\n  }\n\n  protected _uhex(): string {\n    const s = new StaticArray<string>(2 * this.size - 1);\n\n    let q = this.size;\n    let i = 0;\n\n    // MSB is not padded\n    s[i++] = unchecked(this._data[--q]).toString(16);\n\n    while (q > 0) {\n      const x = unchecked(this._data[--q]).toString(16);\n      s[i++] = '0'.repeat(8 - x.length); // padding\n      s[i++] = x;\n    }\n\n    return s.join('');\n  }\n\n  protected _uitoaDecimal(): string {\n    assert(\n      ASC_NO_ASSERT || this.isNeg === false,\n      '_uitoaDecimal: this must be positive'\n    );\n\n    if (this.size === 1) return this.toU32().toString(10);\n\n    let n: MpZ = this;\n    const k = (f64(this.size) / LOG2_10 / 9) * LIMB_BITS;\n    let i = 2 * u32(k) + 1;\n    const s = new StaticArray<string>(i);\n\n    while (n.compareTo(TO_DECIMAL_N) === 1) {\n      const d = n._udivRemU32(TO_DECIMAL_N);\n      n = d.div;\n\n      const x = d.rem.toString(10);\n      s[--i] = x;\n      s[--i] = '0'.repeat(DIGITS_PER_LIMB - x.length);\n    }\n\n    if (!n.eqz()) {\n      s[--i] = n.toU32().toString(10);\n    }\n\n    return s.join('');\n  }\n\n  protected _uitoa(base: u32): string {\n    assert(ASC_NO_ASSERT || base >= 2, '_uitoa: base must be >= 2');\n    assert(ASC_NO_ASSERT || base <= 36, '_uitoa: base must be <= 36');\n    assert(\n      ASC_NO_ASSERT || this.isNeg === false,\n      '_uitoa: this must be positive'\n    );\n\n    const s = new Array<string>();\n\n    let n: MpZ = this;\n    while (n.compareTo(base) === 1) {\n      const d = n._udivRemU32(base);\n      n = d.div;\n      s.unshift(d.rem.toString(base));\n    }\n\n    if (!n.eqz()) {\n      s.unshift(n.toU32().toString(base));\n    }\n\n    return s.join('');\n  }\n\n  // *** valueOf/toString ***\n\n  /**\n   * #### `#valueOf(): number`\n   *\n   * @returns the value of `this` MpZ as a `number`.\n   */\n  valueOf(): number {\n    const q = this.size;\n    const l1: u64 = unchecked(this._data[q - 1]);\n    const z0 = f64(l1) * f64(BASE) ** (q - 1);\n    const l2: u64 = q > 1 ? unchecked(this._data[q - 2]) : 0;\n    const z1 = f64(l2) * f64(BASE) ** (q - 2);\n    const z = z0 + z1;\n    return this.isNeg ? -z : z;\n  }\n\n  /**\n   * #### `#toU32Array(): u32[]`\n   *\n   * @returns the value of `this` MpZ as an unsigned 32-bit integer array.  Ther sign of the MpZ is ignored.\n   */\n  toArray(): u32[] {\n    return this._data.slice<u32[]>(0, this.size);\n  }\n\n  /**\n   * #### `#toU32(): u32`\n   *\n   * @returns the value of `this` MpZ as an unsigned 32-bit integer.  If `this` MpZ is too big to fit in an int32, only the low-order 32 bits are returned.\n   * If `this` MpZ is negative, the returned value is the 2's complement representation of the MpZ.\n   */\n  toU32(): u32 {\n    const z = unchecked(this._data[0]);\n    return this.isNeg ? -z : z;\n  }\n\n  /**\n   * #### `#toI32(): i32`\n   *\n   * @returns the value of `this` MpZ as a signed 32-bit integer.  If `this` MpZ is too big to fit in an int32, only the low-order 32 bits are returned.\n   */\n  toI32(): i32 {\n    const z = unchecked(this._data[0]);\n    return this.isNeg ? -z : z;\n  }\n\n  /**\n   * #### `#toU64(): u64`\n   *\n   * @returns the value of `this` MpZ as an unsigned 64-bit integer.  If `this` MpZ is too big to fit in an int64, only the low-order 64 bits are returned.\n   */\n  toU64(): u64 {\n    const z =\n      this.size === 1\n        ? u64(unchecked(this._data[0]))\n        : (u64(unchecked(this._data[1])) << 32) + u64(unchecked(this._data[0]));\n    return this.isNeg ? -z : z;\n  }\n\n  protected _toU64_safe(): u64 {\n    if (this.size > 3) {\n      throw new RangeError('MpZ too large to fit in u64');\n    }\n    return this.toU64();\n  }\n\n  /**\n   * #### `#toI64(): i64`\n   *\n   * @returns the value as a signed 64-bit integer.  If `this` MpZ is too big to fit in an int64, only the low-order 64 bits are returned.\n   */\n  toI64(): i64 {\n    const z =\n      this.size === 1\n        ? u64(unchecked(this._data[0]))\n        : (u64(unchecked(this._data[1])) << 32) + u64(unchecked(this._data[0]));\n    return this.isNeg ? -z : z;\n  }\n\n  // aka mod_power_of_two\n  // bitwise_modulo_power_of_two\n  protected _truncateToNBits(bits: u64): MpZ {\n    if (bits === 0) return MpZ.ZERO;\n\n    const isNeg = this.isNeg;\n    const limbs = <i32>(bits / LIMB_BITS);\n    if (!isNeg && limbs >= this.size) return this;\n\n    const x = isNeg ? this.not() : this;\n\n    const p = x.size;\n    let q: i32 = limbs + 1;\n    const z = new StaticArray<u32>(q);\n\n    for (let i: i32 = 0; i < q; ++i) {\n      const lx = p > i ? unchecked(x._data[i]) : 0;\n      unchecked((z[i] = isNeg ? ~lx : lx));\n    }\n\n    const n = <u32>(bits % LIMB_BITS);\n    z[limbs] &= (1 << n) - 1;\n\n    return new MpZ(z);\n  }\n\n  // *** Comparison ***\n\n  /**\n   * #### `#eqz(): boolean`\n   *\n   * @returns `true` if `this` MpZ is equal to zero.\n   */\n  eqz(): boolean {\n    return this.size === 1 && unchecked(this._data[0]) === 0;\n  }\n\n  /**\n   * #### `#compareTo(rhs: MpZ | i32 | u32 | i64 | u64 | string): i32`\n   *\n   * @returns `-1` if `this` MpZ is less than the rhs, `0` if `this` MpZ is equal to the rhs, or `1` if `this` MpZ is greater than the rhs.\n   */\n  compareTo<T>(rhs: T): i32 {\n    const y = MpZ.from(rhs);\n\n    const q = this._sgn_size;\n    const p = y._sgn_size;\n\n    if (q > p) return 1;\n    if (p > q) return -1;\n    if (q < 0) return -this._ucmp(y);\n    return this._ucmp(y);\n  }\n\n  // unsigned compare\n  protected _ucmp(rhs: MpZ): i32 {\n    const q = this.size;\n    const p = rhs.size;\n\n    if (q !== p) return q > p ? 1 : -1;\n    for (let i = q - 1; i >= 0; i--) {\n      const lx = unchecked(this._data[i]);\n      const ly = unchecked(rhs._data[i]);\n      if (lx != ly) {\n        return lx > ly ? 1 : -1;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * #### `#eq(rhs: MpZ | i32 | u32 | i64 | u64 | string): boolean`\n   *\n   * @returns `true` if `this` MpZ is equal to the rhs.\n   */\n  eq<T>(rhs: T): boolean {\n    return this.compareTo(MpZ.from(rhs)) === 0;\n  }\n\n  /**\n   * #### `#ne(rhs: MpZ | i32 | u32 | i64 | u64 | string): boolean`\n   *\n   * @returns `true` if `this` MpZ is not equal to the rhs.\n   */\n  ne<T>(rhs: T): boolean {\n    return this.compareTo(MpZ.from(rhs)) !== 0;\n  }\n\n  /**\n   * #### `#gt(rhs: MpZ | i32 | u32 | i64 | u64 | string): boolean`\n   *\n   * @returns `true` if `this` MpZ is greater than the rhs.\n   */\n  gt<T>(rhs: T): boolean {\n    return this.compareTo(MpZ.from(rhs)) > 0;\n  }\n\n  /**\n   * #### `#ge(rhs: MpZ | i32 | u32 | i64 | u64 | string): boolean`\n   *\n   * @returns `true` if `this` MpZ is greater than or equal to the rhs.\n   */\n  ge<T>(rhs: T): boolean {\n    return this.compareTo(MpZ.from(rhs)) >= 0;\n  }\n\n  /**\n   * #### `#lt(rhs: MpZ | i32 | u32 | i64 | u64 | string): boolean`\n   *\n   * @returns `true` if `this` MpZ is less than the rhs.\n   */\n  lt<T>(rhs: T): boolean {\n    return this.compareTo(MpZ.from(rhs)) < 0;\n  }\n\n  /**\n   * #### `#le(rhs: MpZ | i32 | u32 | i64 | u64 | string): boolean`\n   *\n   * @returns `true` if `this` MpZ is less than or equal to the rhs.\n   */\n  le<T>(rhs: T): boolean {\n    return this.compareTo(MpZ.from(rhs)) <= 0;\n  }\n\n  /**\n   * #### Static values\n   *\n   * The following static values are provided for convenience:\n   * - `MpZ.ZERO` - The MpZ value `0`.\n   * - `MpZ.ONE` - The MpZ value `1`.\n   * - `MpZ.TWO` - The MpZ value `2`.\n   * - `MpZ.TEN` - The MpZ value `10`.\n   */\n  static readonly ZERO: MpZ = new MpZ([0]);\n  static readonly ONE: MpZ = new MpZ([1]);\n  static readonly TWO: MpZ = new MpZ([2]);\n  static readonly TEN: MpZ = new MpZ([10]);\n\n  /**\n   * ### Operators\n   */\n\n  /**\n   * #### Unary `-` operator\n   *\n   * @returns the negation of `this` MpZ (`-this`).\n   */\n  @operator.prefix('-')\n  static neg(lhs: MpZ): MpZ {\n    return lhs.negate();\n  }\n\n  /**\n   * #### Binary `+`, `-`, `*`, `/` operators\n   *\n   * Same as the `#add`, `#sub`, `#mul`, `#div` methods.\n   */\n\n  // @ts-ignore\n  @inline\n  @operator('*')\n  static mul(lhs: MpZ, rhs: MpZ): MpZ {\n    return lhs.mul(rhs);\n  }\n\n  // @ts-ignore\n  @inline\n  @operator('/')\n  static div(lhs: MpZ, rhs: MpZ): MpZ {\n    return lhs.div(rhs);\n  }\n\n  // @ts-ignore\n  @inline\n  @operator('+')\n  static add(lhs: MpZ, rhs: MpZ): MpZ {\n    return lhs.add(rhs);\n  }\n\n  // @ts-ignore\n  @inline\n  @operator('-')\n  static sub(lhs: MpZ, rhs: MpZ): MpZ {\n    return lhs.sub(rhs);\n  }\n\n  /**\n   * ### Comparison Operators\n   *\n   * #### `==`, `>`, `>=`, `<`, `<=`, `!=`\n   *\n   * Same as the `#eq`, `#gt`, `#ge`, `#lt`, `#le`, `#ne` methods.\n   */\n\n  // @ts-ignore\n  @inline\n  @operator('==')\n  static eq(lhs: MpZ, rhs: MpZ): boolean {\n    return lhs.eq(rhs);\n  }\n\n  // @ts-ignore\n  @inline\n  @operator('>')\n  static gt(lhs: MpZ, rhs: MpZ): boolean {\n    return lhs.gt(rhs);\n  }\n\n  // @ts-ignore\n  @inline\n  @operator('>=')\n  static ge(lhs: MpZ, rhs: MpZ): boolean {\n    return lhs.ge(rhs);\n  }\n\n  // @ts-ignore\n  @inline\n  @operator('<')\n  static lt(lhs: MpZ, rhs: MpZ): boolean {\n    return lhs.lt(rhs);\n  }\n\n  // @ts-ignore\n  @inline\n  @operator('<=')\n  static le(lhs: MpZ, rhs: MpZ): boolean {\n    return lhs.le(rhs);\n  }\n\n  // @ts-ignore\n  @inline\n  @operator('!=')\n  static ne(lhs: MpZ, rhs: MpZ): boolean {\n    return !lhs.eq(rhs);\n  }\n\n  /**\n   * #### `%` operator\n   *\n   * @returns the remainder of the lhs and rhs (`lhs % rhs`).\n   * @throws RangeError if `rhs` is zero.\n   *\n   * > Note: The `%` operator is not the same as the `#mod` method. The `%` operator returns the `#rem` of the division of the lhs and rhs; matching JavaScript's BigInt `%` operator.\n   */\n  // @ts-ignore\n  @inline\n  @operator('%')\n  static mod(lhs: MpZ, rhs: MpZ): MpZ {\n    return lhs._rem(rhs);\n  }\n\n  /**\n   * #### `**` operator\n   *\n   * @returns the power of the lhs to the rhs (`lhs ** rhs`).\n   */\n  // @ts-ignore\n  @inline\n  @operator('**')\n  static pow(lhs: MpZ, rhs: MpZ): MpZ {\n    return lhs.pow(rhs);\n  }\n\n  /**\n   * #### `<<`, `>>` operators\n   *\n   * @returns the result of the left/right shift of the lhs by the rhs.  Negitive rhs values will result in a opposite shift.\n   * @throws RangeError if the result exceeds the maximum MpZ size.\n   *\n   * > Shift operators behave as if they were represented in two's-complement notation; like JavaScripts's `<<` and `>>` operators.\n   */\n\n  // @ts-ignore\n  @operator('<<')\n  static shiftLeft(lhs: MpZ, rhs: MpZ): MpZ {\n    return lhs.shiftLeft(rhs);\n  }\n\n  // @ts-ignore\n  @operator('>>')\n  static shiftRight(lhs: MpZ, rhs: MpZ): MpZ {\n    return lhs.shiftRight(rhs);\n  }\n\n  /**\n   * #### `~` operator\n   *\n   * @returns the bitwise NOT of `this` MpZ (`~this`).\n   */\n  @operator.prefix('~')\n  static not(lhs: MpZ): MpZ {\n    return lhs.not();\n  }\n\n  /**\n   * #### `&`, `|`, `^ operators\n   *\n   * @returns the bitwise `AND`, `OR`, `XOR` operation on the two operands.\n   *\n   * > This operator returns the result of the bitwise `AND`, `OR`, `XOR` as if the values were 2's complement signed integers; matching JavaScript's BigInt `&`, `|`, `^` operators.\n   */\n\n  // @ts-ignore\n  @operator('&')\n  static and(lhs: MpZ, rhs: MpZ): MpZ {\n    return lhs.and(rhs);\n  }\n\n  // @ts-ignore\n  @operator('|')\n  static or(lhs: MpZ, rhs: MpZ): MpZ {\n    return lhs.or(rhs);\n  }\n\n  // @ts-ignore\n  @operator('^')\n  static xor(lhs: MpZ, rhs: MpZ): MpZ {\n    return lhs.xor(rhs);\n  }\n\n  /**\n   * ### `!` operator\n   *\n   * @returns the logical NOT of `this` MpZ (`!this`).  This is equivalent to `#eqz()`.\n   */\n  @operator.prefix('!')\n  static logicalNot(lhs: MpZ): boolean {\n    return lhs.eqz();\n  }\n\n  /**\n   * #### `MpZ.asIntN(bits: u32, a: MpZ): MpZ`\n   *\n   * @returns a BigInt value truncated to the given number of least significant bits and returns that value as a signed integer.\n   * If the leading bit of the remaining number is 1, the result is negative.\n   */\n  static asIntN(bits: u32, a: MpZ): MpZ {\n    if (bits === 0) return MpZ.ZERO;\n    const isNeg = a._getBit(bits - 1);\n    return isNeg\n      ? a.negate()._truncateToNBits(bits).negate()\n      : a._truncateToNBits(bits);\n  }\n\n  /**\n   * ### `MpZ.asUintN(bits: u32, a: MpZ): MpZ`\n   *\n   * @returns a BigInt value truncated to the given number of least significant bits and returns that value as an unsigned integer.\n   * Results are always non-negative and two's complement in binary.\n   */\n  static asUintN(bits: u32, a: MpZ): MpZ {\n    return a._truncateToNBits(bits);\n  }\n\n  /**\n   * #### `MpZ.random(bits: u64): MpZ`\n   *\n   * @returns a random MpZ value with the specified maximum number of bits.\n   * @throws RangeError if `bits` exceeds the maximum MpZ size.\n   */\n  static random(bits: u64): MpZ {\n    const b = u32(bits % 32);\n    const limbs = <u32>(bits / LIMB_BITS) + <bool>(b > 0);\n    if (limbs > MAX_LIMBS) throw new RangeError('Maximum MpZ size exceeded');\n\n    const n = new StaticArray<u32>(limbs);\n    for (let i: u32 = 0; i < limbs; ++i) {\n      n[i] = u32(Math.random() * u32.MAX_VALUE);\n    }\n    if (b > 0) {\n      const m = (1 << b) - 1;\n      n[n.length - 1] &= m;\n    }\n    return new MpZ(n);\n  }\n}\n","import { strtol, strtod, strtob } from \"./util/string\";\n\ntype auto = i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVector<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): bool;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function add<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sub<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function mul<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function div<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function eq<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ne<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rem<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): auto;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: auto): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: auto[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: auto): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: auto): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: auto): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i32 {\n    return strtol<i32>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i32, right: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u32, right: u32): u32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: auto): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i64, right: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u64, right: u64): u64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: auto): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: auto): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: auto): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: auto): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: auto): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: auto): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: auto): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): bool {\n    return strtob(value);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: auto): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f32 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f32 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f32, right: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f32, right: f32): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: auto): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f64 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f64 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f64 {\n    return strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f64, right: f64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f64, right: f64): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask<T>(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_zero<T = f64>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low<T = f32>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_madd<T>(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_nmadd<T>(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect<T>(a: v128, b: v128, m: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_q15mulr<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot_add<T>(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_q15mulr_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot_i8x16_i7x16_s(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot_i8x16_i7x16_add_s(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_f64x2_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_madd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_nmadd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_max(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low_f32x4(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_madd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_nmadd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_max(a: v128, b: v128): v128;\n}\n\n@final\nexport abstract class i31 { // FIXME: usage of 'new' requires a class :(\n\n  // @ts-ignore: decorator\n  @builtin\n  static new(value: i32): i31ref { return changetype<i31ref>(unreachable()); }\n\n  // @ts-ignore: decorator\n  @builtin\n  static get(i31expr: i31ref): i32 { return unreachable(); }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\n@external.js(\"throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\n@external.js(\"console.log(message, ...[a0, a1, a2, a3, a4].slice(0, n));\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"seed\")\n@external.js(\"return Date.now() * Math.random();\")\ndeclare function seed(): f64;\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol, strtod } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0; // context-aware\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0; // context-aware\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(<i32>this, radix);\n    } else {\n      return itoa64(<i64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<usize>() == 4) {\n      return utoa32(<u32>this, radix);\n    } else {\n      return utoa64(<u64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f64 {\n    return strtod(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    let length = source.length;\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  /** @deprecated Please use source.concat<StaticArray<T>> instead. */\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    return source.concat<StaticArray<T>>(other);\n  }\n\n  /** @deprecated Please use source.slice<StaticArray<T>> instead. */\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    return source.slice<StaticArray<T>>(start, end);\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(out), 0, outSize);\n    }\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    let len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(changetype<usize>(this), this.length, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(changetype<usize>(this), this.length, value, start, end);\n    }\n    return this;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    let ptr = changetype<usize>(this);\n    let len = this.length;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    let length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat<U extends ArrayLike<T> = Array<T>>(other: U): U {\n    let sourceLen = this.length;\n    let otherLen = other.length;\n    let outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) {\n      throw new Error(E_INVALIDLENGTH);\n    }\n    let sourceSize = <usize>sourceLen << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      out = changetype<U>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      let otherStart = changetype<Array<T>>(other).dataStart;\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else if (out instanceof StaticArray<T>) {\n      out = changetype<U>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      let otherStart = changetype<usize>(other);\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  slice<U extends ArrayLike<T> = Array<T>>(start: i32 = 0, end: i32 = i32.MAX_VALUE): U {\n    let length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end,   length);\n    length = max(end - start, 0);\n\n    let sourceStart = changetype<usize>(this) + (<usize>start << alignof<T>());\n    let size = <usize>length << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      // return Array\n      out = changetype<U>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(changetype<usize>(out), ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else if (out instanceof StaticArray<T>) {\n      // return StaticArray\n      out = changetype<U>(__new(size, idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(outStart, ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = this.length - 1; i >= 0; --i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\n    let len = this.length;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < len; ++i) {\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length; i < len; ++i) {\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length; i < len; ++i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): StaticArray<T> {\n    SORT<T>(changetype<usize>(this), this.length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  reverse(): StaticArray<T> {\n    REVERSE<T>(changetype<usize>(this), this.length);\n    return this;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n","import { MpZ } from \"@hypercubed/as-mpz\";\n\n// @ts-ignore: Decorator valid here\n@inline export function serializeMpZ(data: MpZ): string {\n  return data.toString();\n}","import { MpZ } from \"@hypercubed/as-mpz\";\n\n/**\n * Deserialize a string to type MpZ\n * @param data data to parse\n * @returns MpZ\n */\n// @ts-ignore: Decorator valid here\n@inline export function deserializeMpZ(data: string, start: i32 = 0, end: i32 = 0): MpZ {\n    if (!end) end = data.length;\n    return MpZ.from(data.slice(start, end));\n}","import { TableStructure } from \"./types\";\n\nclass Cell {\n    public x: i32 = 0;\n    public y: i32 = 0;\n    public text: string = \"\";\n    toString(): string {\n        return this.text;\n    }\n}\n\nconst padding = \" \";\n\nconst fmt = new TableStructure();\n\nfunction stripAnsii(text: string): string {\n    let inEscape = false;\n    let output = \"\";\n    for (let i = 0; i < text.length; i++) {\n        const char = text.charAt(i);\n\n        if (char === \"\\x1B\") { \n            inEscape = true;\n        } else if (char === \"m\" && inEscape) {\n            inEscape = false;\n        } else if (!inEscape) {\n            output += char;\n        }\n    }\n\n    return output;\n}\n\nfunction drawRow(cells: Cell[], columnWidths: i32[], padding_width: i32): string {\n    let line = fmt.bodyLeft;\n    for (let i = 0; i < cells.length; i++) {\n        const cell = unchecked(cells[i]);\n        const width = unchecked(columnWidths[i]);\n        const cellPadding = padding.repeat(padding_width);\n        const diff = cell.text.length - stripAnsii(cell.text).length;\n        line += cellPadding + cell.text.padEnd(diff + width - (padding_width * 2), padding) + cellPadding;\n        if (i < cells.length - 1) {\n            line += fmt.bodyJoin;\n        } else {\n            line += fmt.bodyRight;\n        }\n    }\n    return line;\n}\n\nfunction drawTable(rows: Cell[][], columns: Cell[][], padding_width: i32): string {\n    const columnWidths: i32[] = new Array<i32>(columns.length);\n\n    for (let i = 0; i < columns.length; i++) {\n        const column = unchecked(columns[i]);\n        for (let j = 0; j < column.length; j++) {\n            const cell = unchecked(column[j]);\n            const cellWidth = stripAnsii(cell.text).length + padding_width * 2;\n            if (columnWidths[i] < cellWidth) {\n                columnWidths[i] = cellWidth;\n            }\n        }\n    }\n\n    let result = \"\";\n\n    result += fmt.topLeft;\n    for (let i = 0; i < columnWidths.length; i++) {\n        result += fmt.topBody.repeat(unchecked(columnWidths[i]));\n        if (i < columnWidths.length - 1) {\n            result += fmt.topJoin;\n        }\n    }\n    result += fmt.topRight + \"\\n\";\n\n    for (let i = 0; i < rows.length; i++) {\n        const row = unchecked(rows[i]);\n        result += drawRow(row, columnWidths, padding_width) + \"\\n\";\n\n        if (i < rows.length - 1) {\n            result += fmt.joinLeft;\n            for (let j = 0; j < columnWidths.length; j++) {\n                result += fmt.joinBody.repeat(unchecked(columnWidths[j]));\n                if (j < columnWidths.length - 1) {\n                    result += fmt.joinJoin;\n                }\n            }\n            result += fmt.joinRight + \"\\n\";\n        }\n    }\n\n    result += fmt.bottomLeft;\n    for (let i = 0; i < columnWidths.length; i++) {\n        result += fmt.bottomBody.repeat(unchecked(columnWidths[i]));\n        if (i < columnWidths.length - 1) {\n            result += fmt.bottomJoin;\n        }\n    }\n    result += fmt.bottomRight;\n\n    return result;\n}\n\nexport function createTable(table: string[][], padding: i32 = 3): string {\n    const cellRows: Cell[][] = [];\n    const cellColumns: Cell[][] = new Array<Cell[]>(table[0].length).map<Cell[]>(() => []);\n\n    for (let rowIndex = 0; rowIndex < table.length; rowIndex++) {\n        const row = unchecked(table[rowIndex]);\n        cellRows.push([]);\n        for (let columnIndex = 0; columnIndex < row.length; columnIndex++) {\n            const col = unchecked(row[columnIndex]);\n            const cell = new Cell();\n            cell.x = columnIndex;\n            cell.y = rowIndex;\n            cell.text = col;\n            cellRows[rowIndex].push(cell);\n            cellColumns[columnIndex].push(cell);\n        }\n    }\n\n    return drawTable(cellRows, cellColumns, padding);\n}\n","export class TableStructure {\n    topBody: string = \"\";\n    topJoin: string = \"\";\n    topLeft: string = \"\";\n    topRight: string = \"\";\n\n    bottomBody: string = \"\";\n    bottomJoin: string = \"\";\n    bottomLeft: string = \"\";\n    bottomRight: string = \"\";\n\n    bodyLeft: string = \"\";\n    bodyRight: string = \"\";\n    bodyJoin: string = \"\";\n\n    joinBody: string = \"\";\n    joinLeft: string = \"\";\n    joinRight: string = \"\";\n    joinJoin: string = \"\";\n}","import { rainbow } from \"as-rainbow\";\nimport { TestGroup } from \"./src/group\";\nimport { Expectation } from \"./src/expectation\";\nimport { formatTime } from \"./util\";\nimport { stringify } from \"as-console/stringify\";\nimport { __COVER, __HASHES, __POINTS } from \"as-test/assembly/coverage\";\nimport { createTable } from \"table-as\";\n\n/**\n * Enumeration representing the verdict of a test case.\n */\nexport enum Verdict {\n    Unreachable,\n    Ok,\n    Fail\n}\n\n// Globals\nlet current_group: TestGroup | null = null;\nlet groups: TestGroup[] = [];\n\nlet before_all_callback: (() => void) | null = null;\nlet after_all_callback: (() => void) | null = null;\n\nexport let before_each_callback: (() => void) | null = null;\nexport let after_each_callback: (() => void) | null = null;\nlet __test_options!: RunOptions;\n\n/**\n * Creates a test group containing multiple test cases.\n * \n * @param {string} description - The name of the test group\n * @param {() => void} callback - The block containing the test cases for this group\n * \n * @example\n * ```ts\n * describe(\"my test suite\", () => {\n *   expect(1 + 3).toBe(4);\n *   // More tests here\n * });\n * ```\n */\nexport function describe(description: string, callback: () => void): void {\n    const group = new TestGroup(description, callback);\n\n    current_group = group;\n    groups.push(group);\n}\n\n/**\n * Creates a test group containing multiple test cases\n * \n * @param {string} description - The name of the test group\n * @param {() => void} callback - The block containing the test cases for this group\n * \n * @example\n * \n * ```ts\n * test(\"1 + 3 = 4\", () => {\n *  expect(1 + 3).toBe(4);\n * });\n * ```\n */\nexport function test(description: string, callback: () => void): void {\n    const group = new TestGroup(description, callback);\n\n    current_group = group;\n    groups.push(group);\n}\n\n/**\n * Creates a test group containing multiple test cases\n * \n * @param {string} description - The name of the test group\n * @param {() => void} callback - The block containing the test cases for this group\n * \n * @example\n * \n * ```ts\n * it(\"should perform additions\", () => {\n *  expect(1 + 3).toBe(4);\n * });\n * ```\n */\nexport function it(description: string, callback: () => void): void {\n    const group = new TestGroup(description, callback);\n\n    current_group = group;\n    groups.push(group);\n}\n\n/**\n * Creates an expectation object for making assertions within a test case.\n * \n * Use this function to chain assertions about a specific value. \n * The returned expectation object provides various methods for testing \n * different properties and conditions of the value.\n * \n * @param {T} value - The value to be asserted against.\n * @returns {Expectation<T>} - The expectation object for chaining assertions.\n * \n * @example\n * ```ts\n * test(\"number comparison\", () => {\n *   expect(1 + 2).toBe(3);\n *   expect(5).toBeGreaterThan(3);\n * });\n * ```\n */\nexport function expect<T>(value: T): Expectation<T> {\n    const result = new Expectation<T>(value);\n    current_group!.addExpectation(result);\n\n    return result;\n}\n\n/**\n * Formats and prints content to the terminal\n * Can be disabled like so:\n * \n * ```js\n * // ...\n * \n * run({ log: false });\n * ```\n * \n * @param {T} data - The data to format and print\n */\nexport function log<T>(data: T): void {\n    if (!__test_options.log) return;\n    const formatted = stringify(data);\n    if (formatted) {\n        const lines = formatted.split(\"\\n\");\n        for (let i = 0; i < lines.length; i++) {\n            const line = unchecked(lines[i]);\n            console.log(\"  \" + rainbow.bgYellow(\" LOG \") + \" \" + line);\n        }\n        console.log(\"\");\n    }\n}\n\n/**\n * Registers a callback function to be executed before each test group is run.\n * \n * @param {() => void} callback - The function to be executed before each test group.\n */\nexport function beforeAll(callback: () => void): void {\n    before_all_callback = callback;\n}\n\n/**\n * Registers a callback function to be executed after each test group is run.\n * \n * @param {() => void} callback - The function to be executed after each test group.\n */\nexport function afterAll(callback: () => void): void {\n    after_all_callback = callback;\n}\n\n/**\n * Registers a callback function to be executed before each test case is run.\n * \n * @param {() => void} callback - The function to be executed before each test case.\n */\nexport function beforeEach(callback: () => void): void {\n    before_each_callback = callback;\n}\n\n/**\n * Registers a callback function to be executed after each test case is run.\n * \n * @param {() => void} callback - The function to be executed after each test case.\n */\nexport function afterEach(callback: () => void): void {\n    after_each_callback = callback;\n}\n\n/**\n * Class defining options that can be passed to the `run` function.\n * \n * Currently, it offers a single option:\n * \n * - `log` (boolean, default: true): Controls whether enable the log() function\n **/\nclass RunOptions {\n    log: boolean = true;\n    coverage: boolean = false;\n}\n\n/**\n * Runs all the test suites defined within the current test scope.\n * \n * This function executes all the test cases you've defined in your test suites.\n * It iterates through each suite, runs the tests within the suite, and tracks results.\n * Finally, it prints a colorful summary of the test execution.\n * \n * @param {RunOptions} [options] - Optional options for running tests.\n * \n * @example\n * ```javascript\n * describe(\"Math operations\", () => {\n *   test(\"Addition\", () => {\n *     expect(1 + 2).toBe(3);\n *   });\n *   // ... other tests\n * });\n * \n * run(); // Executes all tests in the \"Math operations\" suite\n * ```\n */\nexport function run(options: RunOptions = new RunOptions()): void {\n    __test_options = options;\n    console.log(rainbow.boldMk(rainbow.blueBright(` _____  _____      _____  _____  _____  _____ `)));\n    console.log(rainbow.boldMk(rainbow.blueBright(`|  _  ||   __| ___|_   _||   __||   __||_   _|`)));\n    console.log(rainbow.boldMk(rainbow.blueBright(`|     ||__   ||___| | |  |   __||__   |  | |  `)));\n    console.log(rainbow.boldMk(rainbow.blueBright(`|__|__||_____|      |_|  |_____||_____|  |_|  `)));\n    console.log(rainbow.dimMk(\"\\n------------------- v0.1.4 -------------------\\n\"));\n    if (options.coverage) {\n        console.log(rainbow.bgBlueBright(\" PLUGIN \") + \" \" + rainbow.dimMk(\"Using Code Coverage\") + \"\\n\");\n    }\n    const suites = groups.length;\n    let failed = 0;\n    let tests = 0;\n    let failed_tests = 0;\n    let failed_suite_logs = \"\";\n    const start = performance.now();\n    for (let i = 0; i < groups.length; i++) {\n        if (before_all_callback) before_all_callback();\n        const suite = unchecked(groups[i]);\n        suite.run();\n        for (let i = 0; i < suite.results.length; i++) {\n            const expectation = unchecked(suite.results[i]);\n            const verdict = expectation.verdict;\n            tests++;\n            if (verdict == Verdict.Ok) {\n                suite.passed++;\n            } else if (verdict == Verdict.Fail) {\n                suite.verdict = Verdict.Fail;\n                suite.failed++;\n                failed_tests++;\n            }\n        }\n        if (suite.verdict == Verdict.Unreachable) {\n            suite.verdict = Verdict.Ok;\n            console.log(rainbow.bgGreenBright(\" PASS \") + \" \" + rainbow.dimMk(suite.description) + \"\\n\");\n        } else {\n            failed++;\n            const txt = rainbow.bgRed(\" FAIL \") + \" \" + rainbow.dimMk(suite.description) + \"\\n\";\n            failed_suite_logs += txt\n            console.log(txt);\n        }\n\n        const report = suite.getLogs();\n        if (report) {\n            if (report.passed) console.log(report.passed!);\n            if (report.failed) failed_suite_logs += report.failed!;\n\n        }\n        if (after_all_callback) after_all_callback();\n    }\n\n    if (failed) {\n        console.log(rainbow.red(\"------------------ [FAILED] ------------------\\n\"));\n        console.log(failed_suite_logs);\n    }\n\n\n    if (options.coverage && __HASHES().size) {\n        console.log(rainbow.dimMk(\"----------------- [COVERAGE] -----------------\\n\"));\n        const points = __HASHES().values();\n\n        const table: string[][] = [\n            [\"Location\", \"Type\", \"Hash\"]\n        ];\n\n        for (let i = 0; i < points.length; i++) {\n            const point = unchecked(points[i]);\n            const file = point.file;\n            const reference = point.file + \":\" + point.line.toString() + \":\" + point.column.toString();\n            const type = point.type;\n            const hash = point.hash;\n            table.push([rainbow.underlineMk(reference), type, \"#\" + hash]);\n        }\n        console.log(rainbow.dimMk(createTable(table)) + \"\\n\");\n    }\n\n    console.log(rainbow.dimMk(\"----------------- [RESULTS] ------------------\\n\"));\n    const ms = performance.now() - start;\n    console.log(rainbow.boldMk(\"Test Suites: \") + (failed ? rainbow.boldMk(rainbow.red(failed.toString() + \" failed\")) : rainbow.boldMk(rainbow.green(\"0 failed\"))) + \", \" + suites.toString() + \" total\");\n    console.log(rainbow.boldMk(\"Tests:       \") + (failed_tests ? rainbow.boldMk(rainbow.red(failed_tests.toString() + \" failed\")) : rainbow.boldMk(rainbow.green(\"0 failed\"))) + \", \" + tests.toString() + \" total\");\n    if (options.coverage) console.log(rainbow.boldMk(\"Coverage:    \") + (__HASHES().size ? rainbow.boldMk(rainbow.red(__HASHES().size.toString() + \" failed\")) : rainbow.boldMk(rainbow.green(\"0 failed\"))) + \", \" + __POINTS().toString() + \" total\");\n    console.log(rainbow.boldMk(\"Snapshots:   \") + \"0 total\");\n    console.log(rainbow.boldMk(\"Time:        \") + formatTime(ms));\n    if (failed) {\n        process.exit(1);\n    }\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","\n@json\nexport class ObjWithString {\n    s!: string;\n}\n\n@json\nexport class ObjWithStrangeKey<T> {\n    @alias('a\\\\\\t\"\\x02b`c')\n    data!: T;\n}\n@json\nexport class ObjectWithStringArray {\n    sa!: string[];\n}\n\n@json\nexport class ObjectWithFloat {\n    f!: f64;\n}\n\n@json\nexport class ObjectWithFloatArray {\n    fa!: f64[];\n}\n\n@json\nexport class BaseObject {\n  a: string;\n  constructor(a: string) {\n    this.a = a;\n  }\n}\n\n@json\nexport class DerivedObject extends BaseObject {\n  b: string;\n  constructor(a: string, b: string) {\n    super(a);\n    this.b = b;\n  }\n}\n\n@json\nexport class Map4 {\n  a: string;\n  b: string;\n  c: string;\n  d: string;\n}\n\n@json\nexport class Vec3 {\n  x: f64;\n  y: f64;\n  z: f64;\n\n  static shouldIgnore: string = \"should not be serialized\";\n}\n\n@json\nexport class Player {\n  firstName: string;\n  lastName: string;\n  lastActive: i32[];\n  age: i32;\n  pos: Vec3 | null;\n  isVerified: boolean;\n}\n\nexport class Nullable { }\nexport type Null = Nullable | null;\n\n@json\nexport class OmitIf {\n  x: i32 = 1;\n  @omitif(\"this.y == -1\")\n  y: i32 = -1;\n  z: i32 = 1;\n  @omitnull()\n  foo: string | null = null\n}","import { Verdict } from \"..\";\n\nexport class Node {\n    public verdict: Verdict = Verdict.Unreachable;\n    report(): string | null {\n        return null;\n    }\n}\n\nexport class ReportLogs {\n    passed: string | null;\n    failed: string | null;\n}","import { rainbow } from \"as-rainbow\";\nimport { diff, visualize } from \"../util\";\nimport { Node } from \"./node\";\nimport { Verdict, after_each_callback, before_each_callback } from \"..\";\n\nexport class Expectation<T> extends Node {\n    public verdict: Verdict = Verdict.Unreachable;\n    private left: T;\n    private _left: string | null = null;\n    private right: u64 = 0;\n    private _right: string | null = null;\n    private _not: boolean = false;\n    private op: string = \"=\";\n    constructor(left: T) {\n        super();\n        this.left = left;\n    }\n    get not(): Expectation<T> {\n        this._not = true;\n        return this;\n    }\n\n    /**\n    * Tests if a == null\n    * @returns - void\n    */\n    toBeNull(): void {\n        this.verdict = (isNullable<T>() && changetype<usize>(this.left)) ? Verdict.Ok : Verdict.Fail;\n\n        // @ts-ignore\n        store<T>(changetype<usize>(this), null, offsetof<Expectation<T>>(\"right\"));\n\n        this.op = \"=\"\n\n        // @ts-ignore\n        if (after_each_callback) after_each_callback();\n        // @ts-ignore\n        if (before_each_callback) before_each_callback();\n    }\n\n    /**\n     * Tests if a > b\n     * @param number equals - The value to test\n     * @returns - void\n     */\n    toBeGreaterThan(value: T): void {\n        if (!isInteger<T>() && !isFloat<T>()) ERROR(\"toBeGreaterThan() can only be used on number types!\");\n\n        this.verdict = this.left > value ? Verdict.Ok : Verdict.Fail;\n        store<T>(changetype<usize>(this), value, offsetof<Expectation<T>>(\"right\"));\n\n        this.op = \">\";\n\n        // @ts-ignore\n        if (after_each_callback) after_each_callback();\n        // @ts-ignore\n        if (before_each_callback) before_each_callback();\n    }\n\n    /**\n     * Tests if a >= b\n     * @param number equals - The value to test\n     * @returns - void\n     */\n    toBeGreaterOrEqualTo(value: T): void {\n        if (!isInteger<T>() && !isFloat<T>()) ERROR(\"toBeGreaterOrEqualTo() can only be used on number types!\");\n\n        this.verdict = this.left >= value ? Verdict.Ok : Verdict.Fail;\n        store<T>(changetype<usize>(this), value, offsetof<Expectation<T>>(\"right\"));\n\n        this.op = \">=\";\n\n        // @ts-ignore\n        if (after_each_callback) after_each_callback();\n        // @ts-ignore\n        if (before_each_callback) before_each_callback();\n    }\n\n    /**\n     * Tests if a < b\n     * @param number equals - The value to test\n     * @returns - void\n     */\n    toBeLessThan(value: T): void {\n        if (!isInteger<T>() && !isFloat<T>()) ERROR(\"toBeLessThan() can only be used on number types!\");\n\n        this.verdict = this.left < value ? Verdict.Ok : Verdict.Fail;\n        store<T>(changetype<usize>(this), value, offsetof<Expectation<T>>(\"right\"));\n\n        this.op = \"<\";\n\n        // @ts-ignore\n        if (after_each_callback) after_each_callback();\n        // @ts-ignore\n        if (before_each_callback) before_each_callback();\n    }\n\n    /**\n     * Tests if a <= b\n     * @param number equals - The value to test\n     * @returns - void\n     */\n    toBeLessThanOrEqualTo(value: T): void {\n        if (!isInteger<T>() && !isFloat<T>()) ERROR(\"toBeLessThanOrEqualTo() can only be used on number types!\");\n\n        this.verdict = this.left <= value ? Verdict.Ok : Verdict.Fail;\n        store<T>(changetype<usize>(this), value, offsetof<Expectation<T>>(\"right\"));\n\n        this.op = \"<=\";\n\n        // @ts-ignore\n        if (after_each_callback) after_each_callback();\n        // @ts-ignore\n        if (before_each_callback) before_each_callback();\n    }\n\n    /**\n     * Tests if a is string\n     * @returns - void\n     */\n    toBeString(): void {\n        this.verdict = isString<T>() ? Verdict.Ok : Verdict.Fail;\n\n        this._left = nameof<T>();\n        this._right = \"string\";\n\n        this.op = \"type\";\n\n        // @ts-ignore\n        if (after_each_callback) after_each_callback();\n        // @ts-ignore\n        if (before_each_callback) before_each_callback();\n    }\n\n    /**\n     * Tests if a is boolean\n     * @returns - void\n     */\n    toBeBoolean(): void {\n        this.verdict = isBoolean<T>() ? Verdict.Ok : Verdict.Fail;\n\n        this._left = nameof<T>();\n        this._right = \"boolean\";\n\n        this.op = \"type\";\n\n        // @ts-ignore\n        if (after_each_callback) after_each_callback();\n        // @ts-ignore\n        if (before_each_callback) before_each_callback();\n    }\n\n    /**\n     * Tests if a is array\n     * @returns - void\n     */\n    toBeArray(): void {\n        this.verdict = isArray<T>() ? Verdict.Ok : Verdict.Fail;\n\n        this._left = nameof<T>();\n        this._right = \"Array<any>\";\n\n        this.op = \"type\";\n\n        // @ts-ignore\n        if (after_each_callback) after_each_callback();\n        // @ts-ignore\n        if (before_each_callback) before_each_callback();\n    }\n\n    /**\n     * Tests if a is number\n     * @returns - void\n     */\n    toBeNumber(): void {\n        this.verdict = (isFloat<T>() || isInteger<T>()) ? Verdict.Ok : Verdict.Fail;\n\n        this._left = nameof<T>();\n        this._right = \"number\";\n\n        this.op = \"type\";\n\n        // @ts-ignore\n        if (after_each_callback) after_each_callback();\n        // @ts-ignore\n        if (before_each_callback) before_each_callback();\n    }\n\n    /**\n     * Tests if a is integer\n     * @returns - void\n     */\n    toBeInteger(): void {\n        this.verdict = isInteger<T>() ? Verdict.Ok : Verdict.Fail;\n\n        this._left = nameof<T>();\n        this._right = \"float\";\n\n        this.op = \"type\";\n\n        // @ts-ignore\n        if (after_each_callback) after_each_callback();\n        // @ts-ignore\n        if (before_each_callback) before_each_callback();\n    }\n\n    /**\n     * Tests if a is float\n     * @returns - void\n     */\n    toBeFloat(): void {\n        this.verdict = isFloat<T>() ? Verdict.Ok : Verdict.Fail;\n\n        this._left = nameof<T>();\n        this._right = \"integer\";\n\n        this.op = \"type\";\n\n        // @ts-ignore\n        if (after_each_callback) after_each_callback();\n        // @ts-ignore\n        if (before_each_callback) before_each_callback();\n    }\n\n    /**\n     * Tests if a is finite\n     * @returns - void\n     */\n    toBeFinite(): void {\n        // @ts-ignore\n        this.verdict = ((isFloat<T>() || isInteger<T>()) && isFinite(this.left)) ? Verdict.Ok : Verdict.Fail;\n\n        this._left = \"Infinity\";\n        this._right = \"Finite\";\n\n        this.op = \"=\";\n\n        // @ts-ignore\n        if (after_each_callback) after_each_callback();\n        // @ts-ignore\n        if (before_each_callback) before_each_callback();\n    }\n\n    /**\n     * Tests if an array has length x\n     * \n     * @param {i32} value - The value to check\n     * @returns - void\n     */\n    toHaveLength(value: i32): void {\n        // @ts-ignore\n        this.verdict = (isArray<T>() && this.left.length == value) ? Verdict.Ok : Verdict.Fail;\n\n        // @ts-ignore\n        this._left = this.left.length.toString();\n        this._right = value.toString();\n\n        this.op = \"length\";\n\n        // @ts-ignore\n        if (after_each_callback) after_each_callback();\n        // @ts-ignore\n        if (before_each_callback) before_each_callback();\n    }\n\n    /**\n     * Tests if an array contains an element\n     * \n     * @param { valueof<T> } value - The value to check\n     * @returns - void\n     */\n    // @ts-ignore\n    toContain(value: valueof<T>): void {\n        // @ts-ignore\n        this.verdict = (isArray<T>() && this.left.includes(value)) ? Verdict.Ok : Verdict.Fail;\n\n        // @ts-ignore\n        this._left = \"includes value\";\n        this._right = \"does not include value\";\n        this.op = \"=\";\n\n        // @ts-ignore\n        if (after_each_callback) after_each_callback();\n        // @ts-ignore\n        if (before_each_callback) before_each_callback();\n    }\n\n    /**\n     * Tests for equality\n     * @param {T} equals - The value to test\n     * @returns - void\n     */\n    toBe(equals: T): void {\n        store<T>(changetype<usize>(this), equals, offsetof<Expectation<T>>(\"right\"));\n        if (isBoolean<T>()) {\n            this.verdict = this.left === equals\n                ? Verdict.Ok\n                : Verdict.Fail;\n\n        } else if (isString<T>()) {\n            this.verdict = this.left === equals\n                ? Verdict.Ok\n                : Verdict.Fail;\n        } else if (isInteger<T>() || isFloat<T>()) {\n            this.verdict = this.left === equals\n                ? Verdict.Ok\n                : Verdict.Fail;\n        } else if (isArray<T>()) {\n            // getArrayDepth<T>();\n        } else {\n            this.verdict = Verdict.Unreachable;\n        }\n\n        this.op = \"=\";\n\n        // @ts-ignore\n        if (after_each_callback) after_each_callback();\n        // @ts-ignore\n        if (before_each_callback) before_each_callback();\n    }\n\n    report(): string | null {\n        if (!this._not && this.verdict === Verdict.Ok) return null;\n\n        const left = this._left || visualize(this.left);\n        const right = this._right || visualize(load<T>(changetype<usize>(this), offsetof<Expectation<T>>(\"right\")));\n\n        if (this._not) {\n            if (this.verdict === Verdict.Fail) return null;\n            const dif = diff(left, right, true);\n            return rainbow.red(\" - Test failed\") + \"\\n\" + rainbow.italicMk(`  ${rainbow.dimMk(\"(expected) ->\")} ${dif.left.toString()}\\n  ${rainbow.dimMk(\"[ !\" + this.op + \" ]\")}\\n  ${rainbow.dimMk(\"(recieved) ->\")} ${dif.right.toString()}`);\n        }\n\n        if (left == right) return null;\n\n        const dif = diff(left, right);\n\n        return rainbow.red(\" - Test failed\") + \"\\n\" + rainbow.italicMk(`  ${rainbow.dimMk(\"(expected) ->\")} ${dif.left.toString()}\\n  ${rainbow.dimMk(\"[ \" + this.op + \" ]\")}\\n  ${rainbow.dimMk(\"(recieved) ->\")} ${dif.right.toString()}`);\n    }\n}","import { Verdict } from \"..\";\nimport { Expectation } from \"./expectation\";\nimport { Node, ReportLogs } from \"./node\";\nexport class TestGroup {\n    public results: Node[] = [];\n\n    public description: string;\n    public executed: boolean = false;\n    public verdict: Verdict = Verdict.Unreachable;\n\n    public passed: i32 = 0;\n    public failed: i32 = 0;\n\n    public callback: () => void;\n    constructor(description: string, callback: () => void) {\n        this.description = description;\n        this.callback = callback;\n    }\n\n    addExpectation<T extends Expectation<unknown>>(test: T): void {\n        this.results.push(test);\n    }\n\n    getLogs(): ReportLogs {\n        let passed_logs = \"\";\n        let failed_logs = \"\";\n        for (let i = 0; i < this.results.length; i++) {\n            const result = unchecked(this.results[i]);\n            const report = result.report();\n            if (report) {\n                if (result.verdict === Verdict.Fail) failed_logs += report + \"\\n\";\n                else if (result.verdict === Verdict.Ok) passed_logs += report + \"\\n\";\n            }\n        }\n        return {\n            passed: passed_logs.length ? passed_logs : null,\n            failed: failed_logs.length ? failed_logs : null\n        }\n    }\n\n    run(): void {\n        this.callback();\n    }\n}","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n// @ts-ignore: decorator\n@inline @lazy const MIN_SIZE: usize = 8;\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\n  // Depends on the fact that Arrays mimic ArrayBufferView\n  let oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\n  if (newSize > oldCapacity >>> alignLog2) {\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    // Grows old capacity by factor of two.\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\n    let newData = __renew(oldData, newCapacity);\n    // __new / __renew already init memory range as zeros in Incremental runtime.\n    // So try to avoid this.\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    }\n    if (newData != oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  private byteLength: i32; // Uses here as capacity\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? changetype<usize>(value) != 0 && builtin_isArray(value) : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    let array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    // reserve capacity for at least MIN_SIZE elements\n    let bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\n    let buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    let len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(this.dataStart, this.length_, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(this.dataStart, this.length_, value, start, end);\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let len = this.length_;\n      if (len == 0 || fromIndex >= len) return false;\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n      let ptr = this.dataStart;\n      while (fromIndex < len) {\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let len = this.length_;\n    if (len == 0 || fromIndex >= len) return -1;\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n    let ptr = this.dataStart;\n    while (fromIndex < len) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    let len = this.length_;\n    if (len == 0) return -1;\n    if (fromIndex < 0) fromIndex = len + fromIndex;\n    else if (fromIndex >= len) fromIndex = len - 1;\n    let ptr = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    let oldLen = this.length_;\n    let len = oldLen + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    let thisLen = this.length_;\n    let otherLen = other.length_;\n    let outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    let out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    let outStart = out.dataStart;\n    let thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Array<T> {\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\n    this.length_ = len;\n    return val;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    let len = this.length_;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < min(len, this.length_); ++i) {\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  shift(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let base = this.dataStart;\n    let element = load<T>(base);\n    let lastIndex = len - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    let len = this.length_ + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    let ptr = this.dataStart;\n    memory.copy(\n      ptr + sizeof<T>(),\n      ptr,\n      <usize>(len - 1) << alignof<T>()\n    );\n    store<T>(ptr, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\n    len = max(end - start, 0);\n    let slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\n    let sliceBase = slice.dataStart;\n    let thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>len << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\n    let result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\n    let resultStart = result.dataStart;\n    let thisStart = this.dataStart;\n    let thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    let offset = start + deleteCount;\n    if (len != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(len - offset) << alignof<T>()\n      );\n    }\n    this.length_ = len - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    REVERSE<T>(this.dataStart, this.length_);\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): Array<T> {\n    SORT<T>(this.dataStart, this.length_, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    let ptr = this.dataStart;\n    let len = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      ERROR(\"Cannot call flat() on Array<T> where T is not an Array.\");\n    }\n    // Get the length and data start values\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    // calculate the end size with an initial pass\n    let size = 0;\n    for (let i = 0; i < len; ++i) {\n      let child = load<usize>(ptr + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    const align = alignof<valueof<T>>();\n    let byteLength = <usize>size << align;\n    let outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    let outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    let resultOffset: usize = 0;\n    for (let i = 0; i < len; ++i) { // for each child\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (!child) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\"length_\")) << align;\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; ++i) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","// Total tables size: ~5 kb (usually compressed to ~4 kb)\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/casemap.h\n\n// @ts-ignore: decorator\n@lazy @inline const TAB = memory.data<u8>([\n  7, 8, 9, 10, 11, 12, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  13, 6, 6, 14, 6, 6, 6, 6, 6, 6, 6, 6, 15, 16, 17, 18,\n  6, 19, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 20, 21, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 22, 23, 6, 6, 6, 24, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 25,\n  6, 6, 6, 6, 26, 6, 6, 6, 6, 6, 6, 6, 27, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 28, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 29, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36,\n  43, 43, 43, 43, 43, 43, 43, 43, 1, 0, 84, 86, 86, 86, 86, 86,\n  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 43, 43, 43, 43, 43, 43,\n  43, 7, 43, 43, 91, 86, 86, 86, 86, 86, 86, 86, 74, 86, 86, 5,\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  36, 80, 121, 49, 80, 49, 80, 49, 56, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 78, 49, 2, 78, 13, 13, 78, 3,\n  78, 0, 36, 110, 0, 78, 49, 38, 110, 81, 78, 36, 80, 78, 57, 20,\n  129, 27, 29, 29, 83, 49, 80, 49, 80, 13, 49, 80, 49, 80, 49, 80,\n  27, 83, 36, 80, 49, 2, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123,\n  20, 121, 92, 123, 92, 123, 92, 45, 43, 73, 3, 72, 3, 120, 92, 123,\n  20, 0, 150, 10, 1, 43, 40, 6, 6, 0, 42, 6, 42, 42, 43, 7,\n  187, 181, 43, 30, 0, 43, 7, 43, 43, 43, 1, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 205, 70, 205, 43, 0, 37, 43, 7, 1, 6, 1, 85, 86, 86, 86,\n  86, 86, 85, 86, 86, 2, 36, 129, 129, 129, 129, 129, 21, 129, 129, 129,\n  0, 0, 43, 0, 178, 209, 178, 209, 178, 209, 178, 209, 0, 0, 205, 204,\n  1, 0, 215, 215, 215, 215, 215, 131, 129, 129, 129, 129, 129, 129, 129, 129,\n  129, 129, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 28, 0, 0, 0,\n  0, 0, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 2, 0, 0,\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 78, 49, 80, 49, 80, 78, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 2, 135, 166, 135, 166, 135, 166, 135, 166,\n  135, 166, 135, 166, 135, 166, 135, 166, 42, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\n  12, 0, 12, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 7, 42, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 86, 86, 108, 129, 21, 0, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 7, 108, 3, 65, 43, 43, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 86, 86, 86, 86, 86, 44, 86, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 12, 108, 0, 0, 0, 0, 0, 6,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 86, 122, 158, 38, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 1, 43, 43, 79, 86,\n  86, 44, 43, 127, 86, 86, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,\n  86, 44, 43, 127, 86, 86, 129, 55, 117, 91, 123, 92, 43, 43, 79, 86,\n  86, 2, 172, 4, 0, 0, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,\n  86, 44, 43, 43, 86, 86, 50, 19, 129, 87, 0, 111, 129, 126, 201, 215,\n  126, 45, 129, 129, 14, 126, 57, 127, 111, 87, 0, 129, 129, 126, 21, 0,\n  126, 3, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 43,\n  36, 43, 151, 43, 43, 43, 43, 43, 43, 43, 43, 43, 42, 43, 43, 43,\n  43, 43, 86, 86, 86, 86, 86, 128, 129, 129, 129, 129, 57, 187, 42, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 1, 129, 129, 129, 129, 129, 129, 129, 129,\n  129, 129, 129, 129, 129, 129, 129, 201, 172, 172, 172, 172, 172, 172, 172, 172,\n  172, 172, 172, 172, 172, 172, 172, 208, 13, 0, 78, 49, 2, 180, 193, 193,\n  215, 215, 36, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 215, 215, 83, 193, 71, 212, 215, 215, 215, 5, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 1, 0, 1, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 13, 0, 0, 0, 0, 0, 36, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 121, 92, 123, 92, 123, 79, 123, 92, 123, 92, 123,\n  92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 45,\n  43, 43, 121, 20, 92, 123, 92, 45, 121, 42, 92, 39, 92, 123, 92, 123,\n  92, 123, 164, 0, 10, 180, 92, 123, 92, 123, 79, 3, 120, 56, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 79, 45, 43, 43, 1,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 72, 86, 86, 86, 86,\n  86, 86, 86, 86, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 85, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 36, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 7, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 0,\n  0, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 86, 86, 86, 86, 86, 86, 86, 86,\n  86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 86, 86,\n  86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 85,\n  86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const RULES = memory.data<i32>([\n  0x0, 0x2001, -0x2000, 0x1dbf00, 0x2e700, 0x7900,\n  0x2402, 0x101, -0x100, 0x0, 0x201, -0x200,\n  -0xc6ff, -0xe800, -0x78ff, -0x12c00, 0xc300, 0xd201,\n  0xce01, 0xcd01, 0x4f01, 0xca01, 0xcb01, 0xcf01,\n  0x6100, 0xd301, 0xd101, 0xa300, 0xd501, 0x8200,\n  0xd601, 0xda01, 0xd901, 0xdb01, 0x3800, 0x3,\n  -0x4f00, -0x60ff, -0x37ff, 0x242802, 0x0, 0x101,\n  -0x100, -0xcd00, -0xda00, -0x81ff, 0x2a2b01, -0xa2ff,\n  0x2a2801, 0x2a3f00, -0xc2ff, 0x4501, 0x4701, 0x2a1f00,\n  0x2a1c00, 0x2a1e00, -0xd200, -0xce00, -0xca00, -0xcb00,\n  0xa54f00, 0xa54b00, -0xcf00, 0xa52800, 0xa54400, -0xd100,\n  -0xd300, 0x29f700, 0xa54100, 0x29fd00, -0xd500, -0xd600,\n  0x29e700, 0xa54300, 0xa52a00, -0x4500, -0xd900, -0x4700,\n  -0xdb00, 0xa51500, 0xa51200, 0x4c2402, 0x0, 0x2001,\n  -0x2000, 0x101, -0x100, 0x5400, 0x7401, 0x2601,\n  0x2501, 0x4001, 0x3f01, -0x2600, -0x2500, -0x1f00,\n  -0x4000, -0x3f00, 0x801, -0x3e00, -0x3900, -0x2f00,\n  -0x3600, -0x800, -0x5600, -0x5000, 0x700, -0x7400,\n  -0x3bff, -0x6000, -0x6ff, 0x701a02, 0x101, -0x100,\n  0x2001, -0x2000, 0x5001, 0xf01, -0xf00, 0x0,\n  0x3001, -0x3000, 0x101, -0x100, 0x0, 0xbc000,\n  0x1c6001, 0x0, 0x97d001, 0x801, -0x800, 0x8a0502,\n  0x0, -0xbbfff, -0x186200, 0x89c200, -0x182500, -0x186e00,\n  -0x186d00, -0x186400, -0x186300, -0x185c00, 0x0, 0x8a3800,\n  0x8a0400, 0xee600, 0x101, -0x100, 0x0, -0x3b00,\n  -0x1dbeff, 0x8f1d02, 0x800, -0x7ff, 0x0, 0x5600,\n  -0x55ff, 0x4a00, 0x6400, 0x8000, 0x7000, 0x7e00,\n  0x900, -0x49ff, -0x8ff, -0x1c2500, -0x63ff, -0x6fff,\n  -0x7fff, -0x7dff, 0xac0502, 0x0, 0x1001, -0x1000,\n  0x1c01, 0x101, -0x1d5cff, -0x20beff, -0x2045ff, -0x1c00,\n  0xb10b02, 0x101, -0x100, 0x3001, -0x3000, 0x0,\n  -0x29f6ff, -0xee5ff, -0x29e6ff, -0x2a2b00, -0x2a2800, -0x2a1bff,\n  -0x29fcff, -0x2a1eff, -0x2a1dff, -0x2a3eff, 0x0, -0x1c6000,\n  0x0, 0x101, -0x100, 0xbc0c02, 0x0, 0x101,\n  -0x100, -0xa543ff, 0x3a001, -0x8a03ff, -0xa527ff, 0x3000,\n  -0xa54eff, -0xa54aff, -0xa540ff, -0xa511ff, -0xa529ff, -0xa514ff,\n  -0x2fff, -0xa542ff, -0x8a37ff, 0x0, -0x97d000, -0x3a000,\n  0x0, 0x2001, -0x2000, 0x0, 0x2801, -0x2800,\n  0x0, 0x4001, -0x4000, 0x0, 0x2001, -0x2000,\n  0x0, 0x2001, -0x2000, 0x0, 0x2201, -0x2200\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const RULE_BASES = memory.data<u8>([\n  0, 6, 39, 81, 111, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  124, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 131, 142, 146, 151,\n  0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 196, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 198, 201, 0, 0, 0, 219, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222,\n  0, 0, 0, 0, 225, 0, 0, 0, 0, 0, 0, 0, 228, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 237, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const EXCEPTIONS = memory.data<u8>([\n  48, 12,  49, 13,  120, 14,  127, 15,\n  128, 16,  129, 17,  134, 18,  137, 19,\n  138, 19,  142, 20,  143, 21,  144, 22,\n  147, 19,  148, 23,  149, 24,  150, 25,\n  151, 26,  154, 27,  156, 25,  157, 28,\n  158, 29,  159, 30,  166, 31,  169, 31,\n  174, 31,  177, 32,  178, 32,  183, 33,\n  191, 34,  197, 35,  200, 35,  203, 35,\n  221, 36,  242, 35,  246, 37,  247, 38,\n  32, 45,  58, 46,  61, 47,  62, 48,\n  63, 49,  64, 49,  67, 50,  68, 51,\n  69, 52,  80, 53,  81, 54,  82, 55,\n  83, 56,  84, 57,  89, 58,  91, 59,\n  92, 60,  97, 61,  99, 62,  101, 63,\n  102, 64,  104, 65,  105, 66,  106, 64,\n  107, 67,  108, 68,  111, 66,  113, 69,\n  114, 70,  117, 71,  125, 72,  130, 73,\n  135, 74,  137, 75,  138, 76,  139, 76,\n  140, 77,  146, 78,  157, 79,  158, 80,\n  69, 87,  123, 29,  124, 29,  125, 29,\n  127, 88,  134, 89,  136, 90,  137, 90,\n  138, 90,  140, 91,  142, 92,  143, 92,\n  172, 93,  173, 94,  174, 94,  175, 94,\n  194, 95,  204, 96,  205, 97,  206, 97,\n  207, 98,  208, 99,  209, 100,  213, 101,\n  214, 102,  215, 103,  240, 104,  241, 105,\n  242, 106,  243, 107,  244, 108,  245, 109,\n  249, 110,  253, 45,  254, 45,  255, 45,\n  80, 105,  81, 105,  82, 105,  83, 105,\n  84, 105,  85, 105,  86, 105,  87, 105,\n  88, 105,  89, 105,  90, 105,  91, 105,\n  92, 105,  93, 105,  94, 105,  95, 105,\n  130, 0,  131, 0,  132, 0,  133, 0,\n  134, 0,  135, 0,  136, 0,  137, 0,\n  192, 117,  207, 118,  128, 137,  129, 138,\n  130, 139,  133, 140,  134, 141,  112, 157,\n  113, 157,  118, 158,  119, 158,  120, 159,\n  121, 159,  122, 160,  123, 160,  124, 161,\n  125, 161,  179, 162,  186, 163,  187, 163,\n  188, 164,  190, 165,  195, 162,  204, 164,\n  218, 166,  219, 166,  229, 106,  234, 167,\n  235, 167,  236, 110,  243, 162,  248, 168,\n  249, 168,  250, 169,  251, 169,  252, 164,\n  38, 176,  42, 177,  43, 178,  78,  179,\n  132,  8,  98, 186,  99, 187,  100, 188,\n  101, 189,  102, 190,  109, 191,  110, 192,\n  111, 193,  112, 194,  126, 195,  127, 195,\n  125, 207,  141, 208,  148, 209,  171, 210,\n  172, 211,  173, 212,  176, 213,  177, 214,\n  178, 215,  196, 216,  197, 217,  198, 218\n]);\n\n/* Special Case Mappings\n * See: https://unicode.org/Public/UNIDATA/SpecialCasing.txt\n */\n\n/*\n@lazy @inline\nconst SPECIALS_LOWER: StaticArray<u16> = [\n  0x0130,  0x0069, 0x0307, 0x0000,\n];\n*/\n\n// @ts-ignore: decorator\n@lazy @inlne\nexport const SPECIALS_UPPER: StaticArray<u16> = [\n  // String#toUpperCase needs .length\n  0x00DF,  0x0053, 0x0053, 0x0000,\n  0x0149,  0x02BC, 0x004E, 0x0000,\n  0x01F0,  0x004A, 0x030C, 0x0000,\n  0x0390,  0x0399, 0x0308, 0x0301,\n  0x03B0,  0x03A5, 0x0308, 0x0301,\n  0x0587,  0x0535, 0x0552, 0x0000,\n  0x1E96,  0x0048, 0x0331, 0x0000,\n  0x1E97,  0x0054, 0x0308, 0x0000,\n  0x1E98,  0x0057, 0x030A, 0x0000,\n  0x1E99,  0x0059, 0x030A, 0x0000,\n  0x1E9A,  0x0041, 0x02BE, 0x0000,\n  0x1F50,  0x03A5, 0x0313, 0x0000,\n  0x1F52,  0x03A5, 0x0313, 0x0300,\n  0x1F54,  0x03A5, 0x0313, 0x0301,\n  0x1F56,  0x03A5, 0x0313, 0x0342,\n  0x1F80,  0x1F08, 0x0399, 0x0000,\n  0x1F81,  0x1F09, 0x0399, 0x0000,\n  0x1F82,  0x1F0A, 0x0399, 0x0000,\n  0x1F83,  0x1F0B, 0x0399, 0x0000,\n  0x1F84,  0x1F0C, 0x0399, 0x0000,\n  0x1F85,  0x1F0D, 0x0399, 0x0000,\n  0x1F86,  0x1F0E, 0x0399, 0x0000,\n  0x1F87,  0x1F0F, 0x0399, 0x0000,\n  0x1F88,  0x1F08, 0x0399, 0x0000,\n  0x1F89,  0x1F09, 0x0399, 0x0000,\n  0x1F8A,  0x1F0A, 0x0399, 0x0000,\n  0x1F8B,  0x1F0B, 0x0399, 0x0000,\n  0x1F8C,  0x1F0C, 0x0399, 0x0000,\n  0x1F8D,  0x1F0D, 0x0399, 0x0000,\n  0x1F8E,  0x1F0E, 0x0399, 0x0000,\n  0x1F8F,  0x1F0F, 0x0399, 0x0000,\n  0x1F90,  0x1F28, 0x0399, 0x0000,\n  0x1F91,  0x1F29, 0x0399, 0x0000,\n  0x1F92,  0x1F2A, 0x0399, 0x0000,\n  0x1F93,  0x1F2B, 0x0399, 0x0000,\n  0x1F94,  0x1F2C, 0x0399, 0x0000,\n  0x1F95,  0x1F2D, 0x0399, 0x0000,\n  0x1F96,  0x1F2E, 0x0399, 0x0000,\n  0x1F97,  0x1F2F, 0x0399, 0x0000,\n  0x1F98,  0x1F28, 0x0399, 0x0000,\n  0x1F99,  0x1F29, 0x0399, 0x0000,\n  0x1F9A,  0x1F2A, 0x0399, 0x0000,\n  0x1F9B,  0x1F2B, 0x0399, 0x0000,\n  0x1F9C,  0x1F2C, 0x0399, 0x0000,\n  0x1F9D,  0x1F2D, 0x0399, 0x0000,\n  0x1F9E,  0x1F2E, 0x0399, 0x0000,\n  0x1F9F,  0x1F2F, 0x0399, 0x0000,\n  0x1FA0,  0x1F68, 0x0399, 0x0000,\n  0x1FA1,  0x1F69, 0x0399, 0x0000,\n  0x1FA2,  0x1F6A, 0x0399, 0x0000,\n  0x1FA3,  0x1F6B, 0x0399, 0x0000,\n  0x1FA4,  0x1F6C, 0x0399, 0x0000,\n  0x1FA5,  0x1F6D, 0x0399, 0x0000,\n  0x1FA6,  0x1F6E, 0x0399, 0x0000,\n  0x1FA7,  0x1F6F, 0x0399, 0x0000,\n  0x1FA8,  0x1F68, 0x0399, 0x0000,\n  0x1FA9,  0x1F69, 0x0399, 0x0000,\n  0x1FAA,  0x1F6A, 0x0399, 0x0000,\n  0x1FAB,  0x1F6B, 0x0399, 0x0000,\n  0x1FAC,  0x1F6C, 0x0399, 0x0000,\n  0x1FAD,  0x1F6D, 0x0399, 0x0000,\n  0x1FAE,  0x1F6E, 0x0399, 0x0000,\n  0x1FAF,  0x1F6F, 0x0399, 0x0000,\n  0x1FB2,  0x1FBA, 0x0399, 0x0000,\n  0x1FB3,  0x0391, 0x0399, 0x0000,\n  0x1FB4,  0x0386, 0x0399, 0x0000,\n  0x1FB6,  0x0391, 0x0342, 0x0000,\n  0x1FB7,  0x0391, 0x0342, 0x0399,\n  0x1FBC,  0x0391, 0x0399, 0x0000,\n  0x1FC2,  0x1FCA, 0x0399, 0x0000,\n  0x1FC3,  0x0397, 0x0399, 0x0000,\n  0x1FC4,  0x0389, 0x0399, 0x0000,\n  0x1FC6,  0x0397, 0x0342, 0x0000,\n  0x1FC7,  0x0397, 0x0342, 0x0399,\n  0x1FCC,  0x0397, 0x0399, 0x0000,\n  0x1FD2,  0x0399, 0x0308, 0x0300,\n  0x1FD3,  0x0399, 0x0308, 0x0301,\n  0x1FD6,  0x0399, 0x0342, 0x0000,\n  0x1FD7,  0x0399, 0x0308, 0x0342,\n  0x1FE2,  0x03A5, 0x0308, 0x0300,\n  0x1FE3,  0x03A5, 0x0308, 0x0301,\n  0x1FE4,  0x03A1, 0x0313, 0x0000,\n  0x1FE6,  0x03A5, 0x0342, 0x0000,\n  0x1FE7,  0x03A5, 0x0308, 0x0342,\n  0x1FF2,  0x1FFA, 0x0399, 0x0000,\n  0x1FF3,  0x03A9, 0x0399, 0x0000,\n  0x1FF4,  0x038F, 0x0399, 0x0000,\n  0x1FF6,  0x03A9, 0x0342, 0x0000,\n  0x1FF7,  0x03A9, 0x0342, 0x0399,\n  0x1FFC,  0x03A9, 0x0399, 0x0000,\n  0xFB00,  0x0046, 0x0046, 0x0000,\n  0xFB01,  0x0046, 0x0049, 0x0000,\n  0xFB02,  0x0046, 0x004C, 0x0000,\n  0xFB03,  0x0046, 0x0046, 0x0049,\n  0xFB04,  0x0046, 0x0046, 0x004C,\n  0xFB05,  0x0053, 0x0054, 0x0000,\n  0xFB06,  0x0053, 0x0054, 0x0000,\n  0xFB13,  0x0544, 0x0546, 0x0000,\n  0xFB14,  0x0544, 0x0535, 0x0000,\n  0xFB15,  0x0544, 0x053B, 0x0000,\n  0xFB16,  0x054E, 0x0546, 0x0000,\n  0xFB17,  0x0544, 0x053D, 0x0000\n];\n\n// @ts-ignore: decorator\n@lazy @inline const MT = memory.data<i32>([\n  2048, 342, 57\n]);\n\n// Special binary search routine for Special Casing Tables\n// @ts-ignore: decorator\n@inline\nexport function bsearch(key: u32, ptr: usize, max: i32): i32 {\n  let min = 0;\n  while (min <= max) {\n    let mid = (min + max) >>> 3 << 2;\n    let cmp = load<u16>(ptr + (mid << alignof<u16>())) - key;\n    if (cmp == 0) return mid; // found\n    else if (cmp >>> 31) min = mid + 4; // < 0\n    else max = mid - 4; // > 0\n  }\n  return -1; // not found\n}\n\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/towctrans.c\nexport function casemap(c: u32, dir: i32): i32 {\n  // if (c >= 0x20000) return c;\n  let c0 = c as i32;\n  let b = c >> 8;\n  c &= 255;\n\n  let x = c / 3;\n  let y = c % 3;\n\n  /* lookup entry in two-level base-6 table */\n  // v = tab[(tab[b] as i32) * 86 + x] as u32;\n  let v = <usize>load<u8>(TAB + <usize>load<u8>(TAB + b) * 86 + x);\n  // v = (v * mt[y] >> 11) % 6;\n  v = (v * load<i32>(MT + (y << alignof<i32>())) >> 11) % 6;\n  /* use the bit vector out of the tables as an index into\n   * a block-specific set of rules and decode the rule into\n   * a type and a case-mapping delta. */\n  // r = rules[(ruleBases[b] as u32) + v];\n  let r = load<i32>(RULES + ((<usize>load<u8>(RULE_BASES + b) + v) << alignof<i32>()));\n  let rt: u32 = r & 255;\n  let rd: i32 = r >> 8;\n  /* rules 0/1 are simple lower/upper case with a delta.\n   * apply according to desired mapping direction. */\n  if (rt < 2) return c0 + (rd & -(rt ^ dir));\n  /* binary search. endpoints of the binary search for\n   * this block are stored in the rule delta field. */\n  let xn: u32 = rd & 0xff;\n  let xb: u32 = rd >>> 8;\n  while (xn) {\n    let h = xn >> 1;\n    // let t = exceptions[(xb + h) * 2 + 0] as u32;\n    let t = <u32>load<u8>(EXCEPTIONS + (xb + h) * 2, 0);\n    if (t == c) {\n      // r = rules[exceptions[(xb + h) * 2 + 1]];\n      r = load<i32>(RULES + <usize>(load<u8>(EXCEPTIONS + (xb + h) * 2, 1) << alignof<i32>()));\n      rt = r & 255;\n      rd = r >> 8;\n      if (rt < 2) return c0 + (rd & -(rt ^ dir));\n      /* Hard-coded for the four exceptional titlecase */\n      return c0 + 1 - (dir << 1); // (dir ? -1 : 1);\n    } else if (t > c) {\n      xn = h;\n    } else {\n      xb += h;\n      xn -= h;\n    }\n  }\n  return c0;\n}\n","import { Math as JSMath } from \"./bindings/dom\";\nexport { JSMath };\n\nimport {\n  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,\n  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut\n} from \"./util/math\";\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from \"./builtins\";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy let rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy @inline const PIO2_TABLE = memory.data<u64>([\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\n]);\n\n/** @internal */\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n\n  let p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  let q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  let scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMath.exp(x - kln2) * (sign * scale) * scale;\n}\n\n/** @internal */\n/* Helper function to eventually get bits of /2 * |x|\n *\n * y = /4 * (frac << clz(frac) >> 11)\n * return clz(frac)\n *\n * Right shift 11 bits to make upper half fit in `double`\n */\n// @ts-ignore: decorator\n@inline\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  // Bits of /4\n  const p0: u64 = 0xC4C6628B80DC1CD1;\n  const p1: u64 = 0xC90FDAA22168C234;\n\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\n\n  let shift = clz(q1);\n\n  q1 = q1 << shift | q0 >> (64 - shift);\n  q0 <<= shift;\n\n  let lo = umuldi(p1, q1);\n  let hi = res128_hi;\n\n  let ahi = hi >> 11;\n  let alo = lo >> 11 | hi << 53;\n  let blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\n\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\n\n  return shift;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction umuldi(u: u64, v: u64): u64 {\n  let u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\n\n  u1 = u & 0xFFFFFFFF;\n  v1 = v & 0xFFFFFFFF;\n\n  u >>= 32;\n  v >>= 32;\n\n  t  = u1 * v1;\n  w0 = t & 0xFFFFFFFF;\n  t  = u * v1 + (t >> 32);\n  w1 = t >> 32;\n  t  = u1 * v + (t & 0xFFFFFFFF);\n\n  res128_hi = u * v + w1 + (t >> 32);\n  return (t << 32) + w0;\n}\n\n/** @internal */\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  let magnitude = u & 0x7FFFFFFFFFFFFFFF;\n  let offset = (magnitude >> 52) - 1045;\n  let shift  = offset & 63;\n  let tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);\n  let s0: u64, s1: u64, s2: u64;\n\n  let b0 = load<u64>(tblPtr, 0 << 3);\n  let b1 = load<u64>(tblPtr, 1 << 3);\n  let b2 = load<u64>(tblPtr, 2 << 3);\n\n  // Get 192 bits of 0x1p-31 /  with `offset` bits skipped\n  if (shift) {\n    let rshift = 64 - shift;\n    let b3 = load<u64>(tblPtr, 3 << 3);\n    s0 = b1 >> rshift | b0 << shift;\n    s1 = b2 >> rshift | b1 << shift;\n    s2 = b3 >> rshift | b2 << shift;\n  } else {\n    s0 = b0;\n    s1 = b1;\n    s2 = b2;\n  }\n\n  let significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\n\n  // First 128 bits of fractional part of x/(2)\n  let blo = umuldi(s1, significand);\n  let bhi = res128_hi;\n\n  let ahi = s0 * significand;\n  let clo = (s2 >> 32) * (significand >> 32);\n  let plo = blo + clo;\n  let phi = ahi + bhi + u64(plo < clo);\n\n  // r: u128 = p << 2\n  let rlo = plo << 2;\n  let rhi = phi << 2 | plo >> 62;\n\n  // s: i128 = r >> 127\n  let slo = <i64>rhi >> 63;\n  let shi = slo >> 1;\n  let q   = (<i64>phi >> 62) - slo;\n\n  let shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\n  let signbit = (u ^ rhi) & 0x8000000000000000;\n  let coeff   = reinterpret<f64>(shifter | signbit);\n\n  rempio2_y0 *= coeff;\n  rempio2_y1 *= coeff;\n\n  return <i32>q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\n  const\n    pio2_1  = reinterpret<f64>(0x3FF921FB54400000), // 1.57079632673412561417e+00\n    pio2_1t = reinterpret<f64>(0x3DD0B4611A626331), // 6.07710050650619224932e-11\n    pio2_2  = reinterpret<f64>(0x3DD0B4611A600000), // 6.07710050630396597660e-11\n    pio2_2t = reinterpret<f64>(0x3BA3198A2E037073), // 2.02226624879595063154e-21\n    pio2_3  = reinterpret<f64>(0x3BA3198A2E000000), // 2.02226624871116645580e-21\n    pio2_3t = reinterpret<f64>(0x397B839A252049C1), // 8.47842766036889956997e-32\n    invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  let ix = <u32>(u >> 32) & 0x7FFFFFFF;\n\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1\n      let q = 1, z: f64, y0: f64, y1: f64;\n      if (!sign) {\n        z = x - pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z - pio2_1t;\n          y1 = (z - y0) - pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z -= pio2_2;\n          y0 = z - pio2_2t;\n          y1 = (z - y0) - pio2_2t;\n        }\n      } else { // negative x\n        z = x + pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z + pio2_1t;\n          y1 = (z - y0) + pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z += pio2_2;\n          y0 = z + pio2_2t;\n          y1 = (z - y0) + pio2_2t;\n        }\n        q = -1;\n      }\n      rempio2_y0 = y0;\n      rempio2_y1 = y1;\n      return q;\n    }\n  }\n\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\n    // Use precise Cody Waite scheme\n    let q  = nearest(x * invpio2);\n    let r  = x - q * pio2_1;\n    let w  = q * pio2_1t; // 1st round good to 85 bit\n    let j  = ix >> 20;\n    let y0 = r - w;\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\n    let i  = j - ((hi >> 20) & 0x7FF);\n\n    if (i > 16) { // 2nd iteration needed, good to 118\n      let t = r;\n      w  = q * pio2_2;\n      r  = t - w;\n      w  = q * pio2_2t - ((t - r) - w);\n      y0 = r - w;\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\n      i = j - ((hi >> 20) & 0x7FF);\n      if (i > 49) { // 3rd iteration need, 151 bits acc\n        let t = r;\n        w  = q * pio2_3;\n        r  = t - w;\n        w  = q * pio2_3t - ((t - r) - w);\n        y0 = r - w;\n      }\n    }\n    let y1 = (r - y0) - w;\n    rempio2_y0 = y0;\n    rempio2_y1 = y1;\n    return <i32>q;\n  }\n  let q = pio2_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555555555549), // -1.66666666666666324348e-01\n    S2 = reinterpret<f64>(0x3F8111111110F8A6), //  8.33333333332248946124e-03\n    S3 = reinterpret<f64>(0xBF2A01A019C161D5), // -1.98412698298579493134e-04\n    S4 = reinterpret<f64>(0x3EC71DE357B1FE7D), //  2.75573137070700676789e-06\n    S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB), // -2.50507602534068634195e-08\n    S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\n\n  let z = x * x;\n  let w = z * z;\n  let r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\n  let v = z * x;\n  if (!iy) {\n    return x + v * (S1 + z * r);\n  } else {\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\n  }\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\n  const\n    C1 = reinterpret<f64>(0x3FA555555555554C), //  4.16666666666666019037e-02\n    C2 = reinterpret<f64>(0xBF56C16C16C15177), // -1.38888888888741095749e-03\n    C3 = reinterpret<f64>(0x3EFA01A019CB1590), //  2.48015872894767294178e-05\n    C4 = reinterpret<f64>(0xBE927E4F809C52AD), // -2.75573143513906633035e-07\n    C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4), //  2.08757232129817482790e-09\n    C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\n\n  let z = x * x;\n  let w = z * z;\n  let r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\n  let hz = 0.5 * z;\n  w = 1.0 - hz;\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\n}\n\n/** @internal */\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\n  const\n    T0  = reinterpret<f64>(0x3FD5555555555563), //  3.33333333333334091986e-01\n    T1  = reinterpret<f64>(0x3FC111111110FE7A), //  1.33333333333201242699e-01\n    T2  = reinterpret<f64>(0x3FABA1BA1BB341FE), //  5.39682539762260521377e-02\n    T3  = reinterpret<f64>(0x3F9664F48406D637), //  2.18694882948595424599e-02\n    T4  = reinterpret<f64>(0x3F8226E3E96E8493), //  8.86323982359930005737e-03\n    T5  = reinterpret<f64>(0x3F6D6D22C9560328), //  3.59207910759131235356e-03\n    T6  = reinterpret<f64>(0x3F57DBC8FEE08315), //  1.45620945432529025516e-03\n    T7  = reinterpret<f64>(0x3F4344D8F2F26501), //  5.88041240820264096874e-04\n    T8  = reinterpret<f64>(0x3F3026F71A8D1068), //  2.46463134818469906812e-04\n    T9  = reinterpret<f64>(0x3F147E88A03792A6), //  7.81794442939557092300e-05\n    T10 = reinterpret<f64>(0x3F12B80F32F0A7E9), //  7.14072491382608190305e-05\n    T11 = reinterpret<f64>(0xBEF375CBDB605373), // -1.85586374855275456654e-05\n    T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\n\n  const\n    one    = reinterpret<f64>(0x3FF0000000000000), // 1.00000000000000000000e+00\n    pio4   = reinterpret<f64>(0x3FE921FB54442D18), // 7.85398163397448278999e-01\n    pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\n\n  let z: f64, r: f64, v: f64, w: f64, s: f64;\n  let hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x\n  let ix = hx & 0x7FFFFFFF; // high word of |x|\n  let big = ix >= 0x3FE59428;\n  if (big) { // |x| >= 0.6744\n    if (hx < 0) { x = -x, y = -y; }\n    z = pio4 - x;\n    w = pio4lo - y;\n    x = z + w;\n    y = 0.0;\n  }\n  z = x * x;\n  w = z * z;\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\n  s = z * x;\n  r = y + z * (s * (r + v) + y);\n  r += T0 * s;\n  w = x + r;\n  if (big) {\n    v = iy;\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\n  }\n  if (iy == 1) return w;\n  let a: f64, t: f64;\n  z = w;\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\n  v = r - (z - x);  // z + v = r + x\n  t = a = -one / w; // a = -1.0 / w\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n  s = one + t * z;\n  return t + a * (s + t * v);\n}\n\n/** @internal */\nfunction dtoi32(x: f64): i32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    const inv32 = 1.0 / 4294967296;\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\n  } else {\n    let result = 0;\n    let u = reinterpret<u64>(x);\n    let e = (u >> 52) & 0x7FF;\n    if (e <= 1023 + 30) {\n      result = <i32>x;\n    } else if (e <= 1023 + 30 + 53) {\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\n      v = v << e - 1023 - 52 + 32;\n      result = <i32>(v >> 32);\n      result = select<i32>(-result, result, <i64>u < 0);\n    }\n    return result;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let random_seeded = false;\n\n// @ts-ignore: decorator\n@lazy let random_state0_64: u64, random_state1_64: u64;\n\n// @ts-ignore: decorator\n@lazy let random_state0_32: u32, random_state1_32: u32;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nfunction splitMix32(h: u32): u32 {\n  h += 0x6D2B79F5;\n  h  = (h ^ (h >> 15)) * (h | 1);\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\n  return h ^ (h >> 14);\n}\n\nexport namespace NativeMath {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_sin: f64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_cos: f64 = 0;\n\n  // @ts-ignore: decorator\n  @inline export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (<i32>hx < 0) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    let s: f64, w: f64, z: f64;\n    if (<i32>hx < 0) {\n      // z = (1.0 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1.0 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f64>(z);\n    let df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    let c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    let u = reinterpret<u64>(x);\n    // Prevent propagation for all input values less than 1.0.\n    // Note musl lib didn't fix this yet.\n    if (<i64>u < 0x3FF0000000000000) return (x - x) / 0.0;\n    let e = u >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    // let z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    let z = 0.5 - builtin_abs<f64>(x) * 0.5;\n    let s = builtin_sqrt<f64>(z);\n    let r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    return select(-x, x, <i32>hx < 0);\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    let u = reinterpret<u64>(x);\n    let e = u >> 52 & 0x7FF;\n    let y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\n    if (e >= 0x3FF + 26) y = log(y) + c;\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let ix = <u32>(reinterpret<u64>(x) >> 32);\n    let sx = x;\n    ix &= 0x7FFFFFFF;\n    let z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign<f64>(z, sx);\n    }\n    let id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    let w = z * z;\n    let s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    let s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    let s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign<f64>(z, sx);\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    let u = reinterpret<u64>(x);\n    let e = u >> 52 & 0x7FF;\n    let y = builtin_abs(x);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return builtin_copysign<f64>(y, x);\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    let u = reinterpret<u64>(x);\n    let ix = <u32>(u >> 32);\n    let lx = <u32>u;\n    u = reinterpret<u64>(y);\n    let iy = <u32>(u >> 32);\n    let ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    let m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t = m & 2 ? PI : 0;\n        return m & 1 ? -t : t;\n      }\n    }\n    let z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return PI - (z - pi_lo);\n      case 3: return (z - pi_lo) - PI;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000); //  0x1p54\n\n    let u = reinterpret<u64>(x);\n    let hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    let t = reinterpret<f64>(u);\n    let r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    let s = t * t;\n    r = x / s;\n    r = (r - t) / (2 * t + r);\n    t = t + t * r;\n    return t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  export function clz32(x: f64): f64 {\n    if (!isFinite(x)) return 32;\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    return builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\n    let u  = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)\n        return 1.0;\n      }\n      return cos_kern(x, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    let n  = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\n    return (n + 1) & 2 ? -x : x;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    let u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    let w = <u32>(u >> 32);\n    let t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x, 1);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return exp_lut(x);\n    } else {\n      const\n        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n      let hx = u32(reinterpret<u64>(x) >> 32);\n      let sign = hx >> 31;\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x4086232B) {\n        if (isNaN(x)) return x;\n        if (x > overflow)  return x * Ox1p1023;\n        if (x < underflow) return 0;\n      }\n      let hi: f64, lo: f64 = 0;\n      let k = 0;\n      if (hx > 0x3FD62E42) {\n        if (hx >= 0x3FF0A2B2) {\n          k = i32(invln2 * x + builtin_copysign<f64>(0.5, x));\n        } else {\n          k = 1 - (sign << 1);\n        }\n        hi = x - k * ln2hi;\n        lo = k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x3E300000) {\n        hi = x;\n      } else return 1.0 + x;\n      let xs = x * x;\n      // let c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\n      let xq = xs * xs;\n      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\n      let y = 1.0 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f64): f64 {\n    return exp2_lut(x);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32) & 0x7FFFFFFF;\n    let sign = u32(u >> 63);\n    let k = 0;\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign) return -1;\n      if (x > o_threshold) return x * Ox1p1023;\n    }\n    let c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      k = select<i32>(\n        1 - (sign << 1),\n        i32(invln2 * x + builtin_copysign<f64>(0.5, x)),\n        hx < 0x3FF0A2B2\n      );\n      t = <f64>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    let hfx = 0.5 * x;\n    let hxs = x * hfx;\n    // let r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    let hxq = hxs * hxs;\n    let r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\n    t = 3.0 - r1 * hfx;\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    let twopk = reinterpret<f64>(u);\n    let y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    y = reinterpret<f64>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f64): f64 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    let ex = i32(ux >> 52);\n    let ey = i32(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    let z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    let c = x * SPLIT;\n    let h = x - c + c;\n    let l = x - h;\n    let hx = x * x;\n    let lx = h * h - hx + (2 * h + l) * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    let hy = y * y;\n    let ly = h * h - hy + (2 * h + l) * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return dtoi32(x) * dtoi32(y);\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log_lut(x);\n    } else {\n      const\n        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54 = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = u32(u >> 32);\n      let k = 0;\n      let sign = hx >> 31;\n      if (sign || hx < 0x00100000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = u32(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += (<i32>hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let dk = <f64>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32);\n    let k = 0;\n    let sign = hx >> 31;\n    if (sign || hx < 0x00100000) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (sign) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = u32(u >> 32);\n    } else if (hx >= 0x7FF00000) {\n      return x;\n    } else if (hx == 0x3FF00000 && u << 32 == 0) {\n      return 0;\n    }\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += i32(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    let f = x - 1.0;\n    let hfsq = 0.5 * f * f;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    let r = t2 + t1;\n    let hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    let lo = f - hi - hfsq + s * (hfsq + r);\n    let val_hi = hi * ivln10hi;\n    let dk = <f64>k;\n    let y = dk * log10_2hi;\n    let val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    return val_lo + w;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32);\n    let k = 1;\n    let c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || bool(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = u32(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = i32(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    let hfsq = 0.5 * f * f;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    let r = t2 + t1;\n    let dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54  = reinterpret<f64>(0x4350000000000000); // 1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = u32(u >> 32);\n      let k = 0;\n      let sign = hx >> 31;\n      if (sign || hx < 0x00100000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = u32(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += i32(hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let hi = f - hfsq;\n      u = reinterpret<u64>(hi);\n      u &= 0xFFFFFFFF00000000;\n      hi = reinterpret<f64>(u);\n      let lo = f - hi - hfsq + s * (hfsq + r);\n      let val_hi = hi * ivln2hi;\n      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n      let y = <f64>k;\n      w = y + val_hi;\n      val_lo += (y - w) + val_hi;\n      val_hi = w;\n      return val_lo + val_hi;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f64>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f64>(\n          builtin_abs<f64>(builtin_sqrt<f64>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      return pow_lut(x, y);\n    } else {\n      const\n        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\n        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\n\n      let u_ = reinterpret<u64>(x);\n      let hx = i32(u_ >> 32);\n      let lx = <u32>u_;\n      u_ = reinterpret<u64>(y);\n      let hy = i32(u_ >> 32);\n      let ly = <u32>u_;\n      let ix = hx & 0x7FFFFFFF;\n      let iy = hy & 0x7FFFFFFF;\n      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n      if ( // NaN if either arg is NaN\n        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n      ) return x + y;\n      let yisint = 0, k: i32;\n      if (hx < 0) {\n        if (iy >= 0x43400000) yisint = 2;\n        else if (iy >= 0x3FF00000) {\n          k = (iy >> 20) - 0x3FF;\n          let offset = select<u32>(52, 20, k > 20) - k;\n          let Ly = select<u32>(ly, iy, k > 20);\n          let jj = Ly >> offset;\n          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\n        }\n      }\n      if (ly == 0) {\n        if (iy == 0x7FF00000) { // y is +-inf\n          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n        }\n        if (iy == 0x3FF00000) {\n          if (hy >= 0) return x;\n          return 1 / x;\n        }\n        if (hy == 0x40000000) return x * x;\n        if (hy == 0x3FE00000) {\n          if (hx >= 0) return builtin_sqrt(x);\n        }\n      }\n      let ax = builtin_abs<f64>(x), z: f64;\n      if (lx == 0) {\n        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\n          z = ax;\n          if (hy < 0) z = 1.0 / z;\n          if (hx < 0) {\n            if (((ix - 0x3FF00000) | yisint) == 0) {\n              let d = z - z;\n              z = d / d;\n            } else if (yisint == 1) z = -z;\n          }\n          return z;\n        }\n      }\n      let s = 1.0;\n      if (hx < 0) {\n        if (yisint == 0) {\n          let d = x - x;\n          return d / d;\n        }\n        if (yisint == 1) s = -1.0;\n      }\n      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n      let j: i32, n: i32;\n      if (iy > 0x41E00000) {\n        if (iy > 0x43F00000) {\n          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n        }\n        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n        t = ax - 1.0;\n        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n        u = ivln2_h * t;\n        v = t * ivln2_l - w * ivln2;\n        t1 = u + v;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = v - (t1 - u);\n      } else {\n        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n        n = 0;\n        if (ix < 0x00100000) {\n          ax *= two53;\n          n -= 53;\n          ix = <u32>(reinterpret<u64>(ax) >> 32);\n        }\n        n += (ix >> 20) - 0x3FF;\n        j = ix & 0x000FFFFF;\n        ix = j | 0x3FF00000;\n        if (j <= 0x3988E) k = 0;\n        else if (j < 0xBB67A) k = 1;\n        else {\n          k = 0;\n          n += 1;\n          ix -= 0x00100000;\n        }\n        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\n        u = ax - bp;\n        v = 1.0 / (ax + bp);\n        ss = u * v;\n        s_h = ss;\n        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n        t_h = reinterpret<f64>(u64(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n        t_l = ax - (t_h - bp);\n        s_l = v * ((u - s_h * t_h) - s_h * t_l);\n        s2 = ss * ss;\n        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n        r += s_l * (s_h + ss);\n        s2 = s_h * s_h;\n        t_h = 3.0 + s2 + r;\n        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n        t_l = r - ((t_h - 3.0) - s2);\n        u = s_h * t_h;\n        v = s_l * t_h + t_l * ss;\n        p_h = u + v;\n        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n        p_l = v - (p_h - u);\n        let z_h = cp_h * p_h;\n        let dp_l = select<f64>(dp_l1, 0.0, k);\n        let z_l = cp_l * p_h + p_l * cp + dp_l;\n        t = <f64>n;\n        let dp_h = select<f64>(dp_h1, 0.0, k);\n        t1 = ((z_h + z_l) + dp_h) + t;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = z_l - (((t1 - t) - dp_h) - z_h);\n      }\n      let y1 = y;\n      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n      p_l = (y - y1) * t1 + y * t2;\n      p_h = y1 * t1;\n      z = p_l + p_h;\n      u_ = reinterpret<u64>(z);\n      j = u32(u_ >> 32);\n      let i = <i32>u_;\n      if (j >= 0x40900000) {\n        if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n        if (p_l + ovt > z - p_h) return s * huge * huge;\n      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n        if (p_l <= z - p_h) return s * tiny * tiny;\n      }\n      i = j & 0x7FFFFFFF;\n      k = (i >> 20) - 0x3FF;\n      n = 0;\n      if (i > 0x3FE00000) {\n        n = j + (0x00100000 >> (k + 1));\n        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n        t = 0.0;\n        t = reinterpret<f64>(u64(n & ~(0x000FFFFF >> k)) << 32);\n        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n        if (j < 0) n = -n;\n        p_h -= t;\n      }\n      t = p_l + p_h;\n      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n      u = t * lg2_h;\n      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n      z = u + v;\n      w = v - (z - u);\n      t = z * z;\n      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n      r = (z * t1) / (t1 - 2.0) - (w + z * w);\n      z = 1.0 - (r - z);\n      j = u32(reinterpret<u64>(z) >> 32);\n      j += n << 20;\n      if ((j >> 20) <= 0) z = scalbn(z, n);\n      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n      return s * z;\n    }\n  }\n\n  export function seedRandom(value: i64): void {\n    // Instead zero seed use golden ratio:\n    // phi = (1 + sqrt(5)) / 2\n    // trunc(2^64 / phi) = 0x9e3779b97f4a7c15\n    if (value == 0) value = 0x9e3779b97f4a7c15;\n    random_state0_64 = murmurHash3(value);\n    random_state1_64 = murmurHash3(~random_state0_64);\n    random_state0_32 = splitMix32(<u32>value);\n    random_state1_32 = splitMix32(random_state0_32);\n    random_seeded = true;\n  }\n\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n    let s1 = random_state0_64;\n    let s0 = random_state1_64;\n    random_state0_64 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1_64 = s1;\n    let r = (s0 >> 12) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  export function round(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_ceil<f64>(x) - f64(builtin_ceil<f64>(x) - 0.5 > x);\n    } else {\n      let roundUp = builtin_ceil<f64>(x);\n      return select<f64>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n    }\n  }\n\n  export function sign(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return select<f64>(builtin_copysign<f64>(1, x), x, builtin_abs(x) > 0);\n    } else {\n      return select<f64>(1, select<f64>(-1, x, x < 0), x > 0);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f64): bool {\n    return bool(reinterpret<u64>(x) >>> 63);\n  }\n\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\n    let u  = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E500000) { // |x| < 2**-26\n        return x;\n      }\n      return sin_kern(x, 0.0, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    let n  = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\n    return n & 2 ? -x : x;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    let u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\n    let a = reinterpret<f64>(u);\n    let w = u32(u >> 32);\n    let h = builtin_copysign(0.5, x);\n    if (w < 0x40862E42) {\n      let t = expm1(a);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\n    let u = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >>> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E400000) { // |x| < 2**-27\n        return x;\n      }\n      return tan_kern(x, 0.0, 1);\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    let n = rempio2(x, u, sign);\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    let u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    let y = reinterpret<f64>(u);\n    let w = u32(u >> 32);\n    let t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / y;\n      } else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f64>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\n    const\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n\n    let y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n = builtin_min<i32>(n - 1023, 1023);\n      }\n    } else if (n < -1022) {\n      // make sure final n < -53 to avoid double\n      // rounding in the subnormal range\n      y *= Ox1p_1022 * Ox1p53;\n      n += 1022 - 53;\n      if (n < -1022) {\n        y *= Ox1p_1022 * Ox1p53;\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    if (builtin_abs<f64>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);\n    }\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    let ex = i64(ux >> 52 & 0x7FF);\n    let ey = i64(uy >> 52 & 0x7FF);\n    let sx = ux >> 63;\n    let uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    let ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f64(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<i64>(ux << 12);\n      ux <<= 1 - ex;\n    } else {\n      ux &= u64(-1) >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u64(-1) >> 12;\n      uy |= 1 << 52;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 52); ux <<= 1) --ex;\n    let shift = builtin_clz<i64>(ux << 11);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f64>(ux | (sx << 63));\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    let ex = i64(ux >> 52 & 0x7FF);\n    let ey = i64(uy >> 52 & 0x7FF);\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    if (ux << 1 == 0) return x;\n    let uxi = ux;\n    if (!ex) {\n      ex -= builtin_clz<i64>(uxi << 12);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= u64(-1) >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u64(-1) >> 12;\n      uy |= 1 << 52;\n    }\n    let q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else {\n        let shift = builtin_clz<i64>(uxi << 11);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    y = builtin_abs<f64>(y);\n    let x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // ++q;\n    }\n    return <i64>ux < 0 ? -x : x;\n  }\n\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\n    let u = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3FE921FB) {  // |x| ~<= /4\n      if (ux < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kern(x, 0, 0);\n      sincos_cos = cos_kern(x, 0);\n      return;\n    }\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    let n = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n    let s = sin_kern(y0, y1, 1);\n    let c = cos_kern(y0, y1);\n    let sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let rempio2f_y: f64;\n\n// @ts-ignore: decorator\n@lazy @inline const PIO2F_TABLE = memory.data<u64>([\n  0xA2F9836E4E441529,\n  0xFC2757D1F534DDC0,\n  0xDB6295993C439041,\n  0xFE5163ABDEBBC561\n]);\n\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n\n  let p = z * (pS0 + z * (pS1 + z * pS2));\n  let q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                                // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  let scale = reinterpret<f32>(u32(0x7F + (k >> 1)) << 23);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); //  * 0x1p-65 = 8.51530395021638647334e-20\n\n  let offset = (u >> 23) - 152;\n  let shift  = u64(offset & 63);\n  let tblPtr = PIO2F_TABLE + (offset >> 6 << 3);\n\n  let b0 = load<u64>(tblPtr, 0 << 3);\n  let b1 = load<u64>(tblPtr, 1 << 3);\n  let lo: u64;\n\n  if (shift > 32) {\n    let b2 = load<u64>(tblPtr, 2 << 3);\n    lo  = b2 >> (96 - shift);\n    lo |= b1 << (shift - 32);\n  } else {\n    lo = b1 >> (32 - shift);\n  }\n\n  let hi = (b1 >> (64 - shift)) | (b0 << shift);\n  let mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\n  let product = mantissa * hi + (mantissa * lo >> 32);\n  let r: i64 = product << 2;\n  let q = i32((product >> 62) + (r >>> 63));\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\n  return q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const\n    pi2hi = reinterpret<f64>(0x3FF921FB50000000), // 1.57079631090164184570\n    pi2lo = reinterpret<f64>(0x3E5110B4611A6263), // 1.58932547735281966916e-8\n    _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  if (u < 0x4DC90FDB) { //  * 0x1p28\n    let q = nearest(x * _2_pi);\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\n    return <i32>q;\n  }\n\n  let q = pio2f_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).\n// @ts-ignore: decorator\n@inline\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555554CBAC77), // -0x15555554cbac77.0p-55\n    S2 = reinterpret<f64>(0x3F811110896EFBB2), //  0x111110896efbb2.0p-59\n    S3 = reinterpret<f64>(0xBF2A00F9E2CAE774), // -0x1a00f9e2cae774.0p-65\n    S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\n\n  let z = x * x;\n  let w = z * z;\n  let r = S3 + z * S4;\n  let s = z * x;\n  return f32((x + s * (S1 + z * S2)) + s * w * r);\n}\n\n// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).\n// @ts-ignore: decorator\n@inline\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\n  const\n    C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81), // -0x1ffffffd0c5e81.0p-54\n    C1 = reinterpret<f64>(0x3FA55553E1053A42), //  0x155553e1053a42.0p-57\n    C2 = reinterpret<f64>(0xBF56C087E80F1E27), // -0x16c087e80f1e27.0p-62\n    C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\n\n  let z = x * x;\n  let w = z * z;\n  let r = C2 + z * C3;\n  return f32(((1 + z * C0) + w * C1) + (w * z) * r);\n}\n\n// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).\n// @ts-ignore: decorator\n@inline\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\n  const\n    T0 = reinterpret<f64>(0x3FD5554D3418C99F), // 0x15554d3418c99f.0p-54\n    T1 = reinterpret<f64>(0x3FC112FD38999F72), // 0x1112fd38999f72.0p-55\n    T2 = reinterpret<f64>(0x3FAB54C91D865AFE), // 0x1b54c91d865afe.0p-57\n    T3 = reinterpret<f64>(0x3F991DF3908C33CE), // 0x191df3908c33ce.0p-58\n    T4 = reinterpret<f64>(0x3F685DADFCECF44E), // 0x185dadfcecf44e.0p-61\n    T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59\n\n  let z = x * x;\n  let r = T4 + z * T5;\n  let t = T2 + z * T3;\n  let w = z * z;\n  let s = z * x;\n  let u = T0 + z * T1;\n\n  r = (x + s * u) + (s * w) * (t + w * r);\n  return f32(odd ? -1 / r : r);\n}\n\n// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h\n// @ts-ignore: decorator\n@inline\nfunction log2f(x: f64): f64 {\n  const\n    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736\n    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129\n    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505\n    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375\n    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150\n\n  let i = reinterpret<i64>(x);\n  let exponent = (i - 0x3FE6A09E667F3BCD) >> 52;\n  x = reinterpret<f64>(i - (exponent << 52));\n  x = (x - 1) / (x + 1);\n  let xx = x * x;\n  let y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));\n  return (2 * log2e) * y + <f64>exponent;\n}\n\n// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h\n// @ts-ignore: decorator\n@inline\nfunction exp2f(x: f64): f64 {\n  const\n    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1\n    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1\n    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2\n    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3\n    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3\n    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4\n\n  if (x < -1022) return 0;\n  if (x >= 1024) return Infinity;\n\n  let n = nearest(x);\n  x -= n;\n  let xx = x * x;\n  let y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));\n  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));\n}\n\nexport namespace NativeMathf {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = <f32>NativeMath.E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = <f32>NativeMath.LN2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = <f32>NativeMath.LN10;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = <f32>NativeMath.LOG2E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = <f32>NativeMath.LOG10E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = <f32>NativeMath.PI;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_sin: f32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_cos: f32 = 0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    let hx = reinterpret<u32>(x);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        return select<f32>(2 * pio2_hi + Ox1p_120f, 0, <i32>hx < 0);\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    let z: f32, w: f32, s: f32;\n    if (<i32>hx < 0) {\n      // z = (1 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    let df = reinterpret<f32>(hx & 0xFFFFF000);\n    let c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    let u = reinterpret<u32>(x);\n    let a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) { // |x| < 2, invalid if x < 1\n      let xm1 = x - 1;\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\n    }\n    if (u < 0x3F800000 + (12 << 23)) { // 2 <= x < 0x1p12\n      return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    }\n    // x >= 0x1p12 or x <= -2 or NaN\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    let sx = x;\n    let hx = reinterpret<u32>(x) & 0x7FFFFFFF;\n    if (hx >= 0x3F800000) {\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (hx < 0x3F000000) {\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    // let z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    let z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\n    let s = builtin_sqrt<f64>(z); // sic\n    x = f32(pio2 - 2 * (s + s * Rf(z)));\n    return builtin_copysign(x, sx);\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    let y = reinterpret<f32>(u);\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000); //  0x1p-120f\n\n    let ix = reinterpret<u32>(x);\n    let sx = x;\n    ix &= 0x7FFFFFFF;\n    let z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign(z, sx);\n    }\n    let id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    let w = z * z;\n    let s1 = z * (aT0 + w * (aT2 + w * aT4));\n    let s2 = w * (aT1 + w * aT3);\n    let s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign(z, sx);\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    let u = reinterpret<u32>(x);\n    let y = builtin_abs(x);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n\n    if (isNaN(x) || isNaN(y)) return x + y;\n    let ix = reinterpret<u32>(x);\n    let iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    let m = u32(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t: f32 = m & 2 ? pi : 0.0;\n        return m & 1 ? -t : t;\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    let z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n\n    let u = reinterpret<u32>(x);\n    let hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    let t = <f64>reinterpret<f32>(u);\n    let r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    return <f32>t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  export function clz32(x: f32): f32 {\n    if (!isFinite(x)) return 32;\n    return <f32>builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\n    const\n      c1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      c2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        // raise inexact if x != 0\n        return 1;\n      }\n      return cos_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {  // |x| ~<= 5/4\n        if (ux > 0x4016CBE3) { // |x|  ~> 3/4\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\n        } else {\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\n        }\n      }\n      if (ux <= 0x40E231D5) {  // |x| ~<= 9/4\n        if (ux > 0x40AFEDDF) { // |x|  ~> 7/4\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\n        } else {\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\n        }\n      }\n    }\n\n    // cos(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    // general argument reduction needed\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n\n    let t = n & 1 ? sin_kernf(y) : cos_kernf(y);\n    return (n + 1) & 2 ? -t : t;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    let u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      // return 0.5 * (t + 1 / t);\n      return 0.5 * t + 0.5 / t;\n    }\n    return expo2f(x, 1);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return expf_lut(x);\n    } else {\n      const\n        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n        Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n      let hx = reinterpret<u32>(x);\n      let sign = hx >> 31;\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x42AEAC50) {\n        if (hx > 0x7F800000) return x; // NaN\n        if (hx >= 0x42B17218) {\n          if (!sign) return x * Ox1p127f;\n          else if (hx >= 0x42CFF1B5) return 0;\n        }\n      }\n      let hi: f32, lo: f32;\n      let k: i32;\n      if (hx > 0x3EB17218) {\n        if (hx > 0x3F851592) {\n          k = i32(invln2 * x + builtin_copysign<f32>(0.5, x));\n        } else {\n          k = 1 - (sign << 1);\n        }\n        hi = x - <f32>k * ln2hi;\n        lo = <f32>k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x39000000) {\n        k = 0;\n        hi = x;\n        lo = 0;\n      } else {\n        return 1 + x;\n      }\n      let xx = x * x;\n      let c = x - xx * (P1 + xx * P2);\n      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f32): f32 {\n    return exp2f_lut(x);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi   = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo   = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1       = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2       = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n    let u = reinterpret<u32>(x);\n    let hx = u & 0x7FFFFFFF;\n    let sign = u >> 31;\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign) return -1;\n      if (hx > 0x42B17217) { // x > log(FLT_MAX)\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    let c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      k = select<i32>(\n        1 - (sign << 1),\n        i32(invln2 * x + builtin_copysign<f32>(0.5, x)),\n        hx < 0x3F851592\n      );\n      t = <f32>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    let hfx: f32 = 0.5 * x;\n    let hxs: f32 = x * hfx;\n    let r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    let twopk = reinterpret<f32>(u);\n    let y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    y = reinterpret<f32>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    let z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z  = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z  = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(f32(<f64>x * x + <f64>y * y));\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return <f32>(dtoi32(x) * dtoi32(y));\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return logf_lut(x);\n    } else {\n      const\n        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n        Ox1p25f = reinterpret<f32>(0x4C000000);\n\n      let u = reinterpret<u32>(x);\n      let k = 0;\n      let sign = u >> 31;\n      if (sign || u < 0x00800000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0;\n        k -= 25;\n        x *= Ox1p25f;\n        u = reinterpret<u32>(x);\n      } else if (u >= 0x7F800000) {\n        return x;\n      } else if (u == 0x3F800000) {\n        return 0;\n      }\n      u += 0x3F800000 - 0x3F3504F3;\n      k += i32(u >> 23) - 0x7F;\n      u = (u & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(u);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq = <f32>0.5 * f * f;\n      let dk = <f32>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n    let ux = reinterpret<u32>(x);\n    let k = 0;\n    let sign = ux >> 31;\n    if (sign || ux < 0x00800000) {\n      if (ux << 1 == 0) return -1 / (x * x);\n      if (sign) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ux = reinterpret<u32>(x);\n    } else if (ux >= 0x7F800000) {\n      return x;\n    } else if (ux == 0x3F800000) {\n      return 0;\n    }\n    ux += 0x3F800000 - 0x3F3504F3;\n    k += i32(ux >> 23) - 0x7F;\n    ux = (ux & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ux);\n    let f = x - 1.0;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * Lg4);\n    let t2 = z * (Lg1 + w * Lg3);\n    let r = t2 + t1;\n    let hfsq: f32 = 0.5 * f * f;\n    let hi = f - hfsq;\n    ux = reinterpret<u32>(hi);\n    ux &= 0xFFFFF000;\n    hi = reinterpret<f32>(ux);\n    let lo = f - hi - hfsq + s * (hfsq + r);\n    let dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n\n    let ix = reinterpret<u32>(x);\n    let c: f32 = 0;\n    let f: f32 = 0;\n    let k = 1;\n    if (ix < 0x3ED413D0 || bool(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = i32(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * Lg4);\n    let t2 = z * (Lg1 + w * Lg3);\n    let r = t2 + t1;\n    let hfsq: f32 = 0.5 * f * f;\n    let dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2f_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n        Ox1p25f = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n      let ux = reinterpret<u32>(x);\n      let k = 0;\n      let sign = ux >> 31;\n      if (sign || ux < 0x00800000) {\n        if (ux << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 25;\n        x *= Ox1p25f;\n        ux = reinterpret<u32>(x);\n      } else if (ux >= 0x7F800000) {\n        return x;\n      } else if (ux == 0x3F800000) {\n        return 0;\n      }\n      ux += 0x3F800000 - 0x3F3504F3;\n      k += i32(ux >> 23) - 0x7F;\n      ux = (ux & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(ux);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq: f32 = 0.5 * f * f;\n      let hi = f - hfsq;\n      let u = reinterpret<u32>(hi);\n      u &= 0xFFFFF000;\n      hi = reinterpret<f32>(u);\n      let lo: f32 = f - hi - hfsq + s * (hfsq + r);\n      let dk = <f32>k;\n      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 {\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f32>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f32>(\n          builtin_abs<f32>(builtin_sqrt<f32>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      // see: musl/src/math/powf.c\n      return powf_lut(x, y);\n    } else {\n      // based on:  jdh8/metallic/src/math/float/powf.c\n      if (y == 0) return 1;\n      // @ts-ignore: cast\n      if (isNaN(x) | isNaN(y)) {\n        return NaN;\n      }\n      let sign: u32 = 0;\n      let uy = reinterpret<u32>(y);\n      let ux = reinterpret<u32>(x);\n      let sx = ux >> 31;\n      ux &= 0x7FFFFFFF;\n      if (sx && nearest(y) == y) {\n        x = -x;\n        sx = 0;\n        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;\n      }\n      let m: u32;\n      if (ux == 0x3F800000) { // x == 1\n        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;\n      } else if (ux == 0) {\n        m = <i32>uy < 0 ? 0x7F800000 : 0;\n      } else if (ux == 0x7F800000) {\n        m = <i32>uy < 0 ? 0 : 0x7F800000;\n      } else if (sx) {\n        m = 0x7FC00000;\n      } else {\n        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));\n      }\n      return reinterpret<f32>(m | sign);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n  export function random(): f32 {\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n\n    let s0 = random_state0_32;\n    let s1 = random_state1_32;\n    let r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\n\n    s1 ^= s0;\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\n    random_state1_32 = rotl<u32>(s1, 13);\n\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\n  }\n\n  export function round(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_ceil<f32>(x) - f32(builtin_ceil<f32>(x) - 0.5 > x);\n    } else {\n      let roundUp = builtin_ceil<f32>(x);\n      return select<f32>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n    }\n  }\n\n  export function sign(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return select<f32>(builtin_copysign<f32>(1, x), x, builtin_abs(x) > 0);\n    } else {\n      return select<f32>(1, select<f32>(-1, x, x < 0), x > 0);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f32): bool {\n    return <bool>(reinterpret<u32>(x) >>> 31);\n  }\n\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return sin_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3/4\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\n        }\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\n      }\n\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7/4\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\n        }\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n      }\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n\n    let t = n & 1 ? cos_kernf(y) : sin_kernf(y);\n    return n & 2 ? -t : t;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    let a = reinterpret<f32>(u);\n    let h = builtin_copysign<f32>(0.5, x);\n    if (u < 0x42B17217) {\n      let t = expm1(a);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2f(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\n    const\n      t1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      t2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return tan_kernf(x, 0);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3/4\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\n        }\n      }\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7/4\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\n        }\n      }\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    // argument reduction\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n    return tan_kernf(y, n & 1);\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    let u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    let y = reinterpret<f32>(u);\n    let t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / y;\n      else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f32>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\n    const\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n\n    let y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n = builtin_min<i32>(n - 127, 127);\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f * Ox1p24f;\n      n += 126 - 24;\n      if (n < -126) {\n        y *= Ox1p_126f * Ox1p24f;\n        n = builtin_max<i32>(n + 126 - 24, -126);\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    if (builtin_abs<f32>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);\n    }\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    let ex = i32(ux >> 23 & 0xFF);\n    let ey = i32(uy >> 23 & 0xFF);\n    let sm = ux & 0x80000000;\n    let uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    let ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f32(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<u32>(ux << 9);\n      ux <<= 1 - ex;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u32(-1) >> 9;\n      uy |= 1 << 23;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 23); ux <<= 1) --ex;\n    let shift = <i32>builtin_clz<u32>(ux << 8);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f32>(ux | sm);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    let ex = i32(ux >> 23 & 0xFF);\n    let ey = i32(uy >> 23 & 0xFF);\n    let uxi = ux;\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      ex -= builtin_clz<u32>(uxi << 9);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= u32(-1) >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u32(-1) >> 9;\n      uy |= 1 << 23;\n    }\n    let q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -30;\n      else {\n        let shift = builtin_clz<i32>(uxi << 8);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    y = builtin_abs<f32>(y);\n    let x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && bool(q & 1))))) {\n      x -= y;\n      // q++;\n    }\n    return <i32>ux < 0 ? -x : x;\n  }\n\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kernf(x);\n      sincos_cos = cos_kernf(x);\n      return;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3/4\n          if (sign) {\n            sincos_sin = -cos_kernf(x + s1pio2);\n            sincos_cos =  sin_kernf(x + s1pio2);\n          } else {\n            sincos_sin = cos_kernf(s1pio2 - x);\n            sincos_cos = sin_kernf(s1pio2 - x);\n          }\n          return;\n        }\n        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\n        return;\n      }\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7/4\n          if (sign) {\n            sincos_sin =  cos_kernf(x + s3pio2);\n            sincos_cos = -sin_kernf(x + s3pio2);\n          } else {\n            sincos_sin = -cos_kernf(x - s3pio2);\n            sincos_cos =  sin_kernf(x - s3pio2);\n          }\n          return;\n        }\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\n        return;\n      }\n    }\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n    let s = sin_kernf(y);\n    let c = cos_kernf(y);\n    let sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\nexport function ipow32(x: i32, e: i32): i32 {\n  let out = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i32>(1 << e, 0, <u32>e < 32);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i32>(-1, 1, e & 1);\n      return i32(e == 0) | i32(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 32) {\n      let log = 32 - clz(e);\n      // 32 = 2 ^ 5, so need only five cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow64(x: i64, e: i64): i64 {\n  let out: i64 = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i64>(1 << e, 0, <u64>e < 64);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i64>(-1, 1, e & 1);\n      return i64(e == 0) | i64(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 64) {\n      let log = 64 - <i32>clz(e);\n      // 64 = 2 ^ 6, so need only six cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 6: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\n/*\nTODO:\nIn compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains\nwhich usually faster than exponentiation by squaring\n\nfor ipow32 and e < 32:\n\nlet b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;\nswitch (e) {\n  case  1: return x;\n  case  2: return x * x;\n  case  3: return x * x * x;\n  case  4: return (b = x * x) * b;\n  case  5: return (b = x * x) * b * x;\n  case  6: return (b = x * x) * b * b;\n  case  7: return (b = x * x) * b * b * x;\n  case  8: return (d = (b = x * x) * b) * d;\n  case  9: return (c = x * x * x) * c * c;\n  case 10: return (d = (b = x * x) * b) * d * b;\n  case 11: return (d = (b = x * x) * b) * d * b * x;\n  case 12: return (d = (b = x * x) * b) * d * d;\n  case 13: return (d = (b = x * x) * b) * d * d * x;\n  case 14: return (d = (b = x * x) * b) * d * d * b;\n  case 15: return (k = (b = x * x) * b * x) * k * k;\n  case 16: return (h = (d = (b = x * x) * b) * d) * h;\n  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;\n  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;\n  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;\n  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;\n  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;\n  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;\n  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;\n  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;\n  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;\n  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;\n  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;\n  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;\n  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;\n  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;\n  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;\n}\n\nfor ipow64: TODO\nswitch (e) {\n  case 32:\n  ...\n  case 63:\n}\n*/\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function wait32(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function wait64(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    let index: usize = 0;\n    let total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __data_end: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare let __stack_pointer: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __heap_base: usize;\n\n/** Heap memory interface. */\nexport namespace heap {\n\n  /** Allocates a chunk of memory of at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function alloc(size: usize): usize {\n    return __alloc(size);\n  }\n\n  /** Reallocates a chunk of memory to have at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\n    return __realloc(ptr, size);\n  }\n\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function free(ptr: usize): void {\n    __free(ptr);\n  }\n\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function reset(): void {\n    if (isDefined(__reset)) {\n      __reset();\n    } else {\n      throw new Error(E_NOTIMPLEMENTED);\n    }\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  let w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest == src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src - dest - n <= -(n << 1)) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    let dend = dest + n;\n    store<u8>(dest, c);\n    store<u8>(dend - 1, c);\n    if (n <= 2) return;\n    store<u8>(dest, c, 1);\n    store<u8>(dest, c, 2);\n    store<u8>(dend - 2, c);\n    store<u8>(dend - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest, c, 3);\n    store<u8>(dend - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    dend = dest + n;\n    store<u32>(dest, c32);\n    store<u32>(dend - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest, c32, 4);\n    store<u32>(dest, c32, 8);\n    store<u32>(dend - 12, c32);\n    store<u32>(dend - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest, c32, 12);\n    store<u32>(dest, c32, 16);\n    store<u32>(dest, c32, 20);\n    store<u32>(dest, c32, 24);\n    store<u32>(dend - 28, c32);\n    store<u32>(dend - 24, c32);\n    store<u32>(dend - 20, c32);\n    store<u32>(dend - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest, c64, 8);\n      store<u64>(dest, c64, 16);\n      store<u64>(dest, c64, 24);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n","export namespace rainbow {\n    // COLORS\n    // @ts-ignore\n    @inline\n    export function black(text: string): string {\n        return colorText([30, 39], text)\n    }\n    // @ts-ignore\n    @inline\n    export function red(text: string): string {\n        return colorText([31, 39], text)\n    }\n    // @ts-ignore\n    @inline\n    export function green(text: string): string {\n        return colorText([32, 39], text)\n    }\n    // @ts-ignore\n    @inline\n    export function yellow(text: string): string {\n        return colorText([33, 39], text)\n    }\n    // @ts-ignore\n    @inline\n    export function blue(text: string): string {\n        return colorText([34, 39], text)\n    }\n    // @ts-ignore\n    @inline\n    export function magenta(text: string): string {\n        return colorText([35, 39], text)\n    }\n    // @ts-ignore\n    @inline\n    export function cyan(text: string): string {\n        return colorText([36, 39], text)\n    }\n    // @ts-ignore\n    @inline\n    export function white(text: string): string {\n        return colorText([37, 39], text)\n    }\n    // @ts-ignore\n    @inline\n    export function blackBright(text: string): string {\n        return colorText([90, 39], text)\n    }\n    // @ts-ignore\n    @inline\n    export function redBright(text: string): string {\n        return colorText([91, 39], text)\n    }\n    // @ts-ignore\n    @inline\n    export function greenBright(text: string): string {\n        return colorText([92, 39], text)\n    }\n    // @ts-ignore\n    @inline\n    export function yellowBright(text: string): string {\n        return colorText([92, 39], text)\n    }\n    // @ts-ignore\n    @inline\n    export function blueBright(text: string): string {\n        return colorText([94, 39], text)\n    }\n    // @ts-ignore\n    @inline\n    export function magentaBright(text: string): string {\n        return colorText([95, 39], text)\n    }\n    // @ts-ignore\n    @inline\n    export function cyanBright(text: string): string {\n        return colorText([96, 39], text)\n    }\n    // @ts-ignore\n    @inline\n    export function whiteBright(text: string): string {\n        return colorText([97, 39], text)\n    }\n    // MARKINGS\n    // @ts-ignore\n    @inline\n    export function resetMk(text: string): string {\n        return colorText([0, 0], text)\n    }\n    // @ts-ignore\n    @inline\n    export function boldMk(text: string): string {\n        return colorText([1, 22], text)\n    }\n    // @ts-ignore\n    @inline\n    export function dimMk(text: string): string {\n        return colorText([2, 22], text)\n    }\n    // @ts-ignore\n    @inline\n    export function italicMk(text: string): string {\n        return colorText([3, 23], text)\n    }\n    // @ts-ignore\n    @inline\n    export function underlineMk(text: string): string {\n        return colorText([4, 24], text)\n    }\n    // @ts-ignore\n    @inline\n    export function overlineMk(text: string): string {\n        return colorText([53, 55], text)\n    }\n    // @ts-ignore\n    @inline\n    export function inverseMk(text: string): string {\n        return colorText([7, 27], text)\n    }\n    // @ts-ignore\n    @inline\n    export function hiddenMk(text: string): string {\n        return colorText([8, 28], text)\n    }\n    // @ts-ignore\n    @inline\n    export function strikethroughMk(text: string): string {\n        return colorText([9, 29], text)\n    }\n    // BACKGROUND\n    // @ts-ignore\n    @inline\n    export function bgBlack(text: string): string {\n        return colorText([40, 49], text)\n    }\n    // @ts-ignore\n    @inline\n    export function bgRed(text: string): string {\n        return colorText([41, 49], text)\n    }\n    // @ts-ignore\n    @inline\n    export function bgGreen(text: string): string {\n        return colorText([42, 49], text)\n    }\n    // @ts-ignore\n    @inline\n    export function bgYellow(text: string): string {\n        return colorText([43, 49], text)\n    }\n    // @ts-ignore\n    @inline\n    export function bgBlue(text: string): string {\n        return colorText([44, 49], text)\n    }\n    // @ts-ignore\n    @inline\n    export function bgMagenta(text: string): string {\n        return colorText([45, 49], text)\n    }\n    // @ts-ignore\n    @inline\n    export function bgCyan(text: string): string {\n        return colorText([46, 49], text)\n    }\n    // @ts-ignore\n    @inline\n    export function bgWhite(text: string): string {\n        return colorText([47, 49], text)\n    }\n    // @ts-ignore\n    @inline\n    export function bgBlackBright(text: string): string {\n        return colorText([100, 49], text)\n    }\n    // @ts-ignore\n    @inline\n    export function bgRedBright(text: string): string {\n        return colorText([101, 49], text)\n    }\n    // @ts-ignore\n    @inline\n    export function bgGreenBright(text: string): string {\n        return colorText([102, 49], text)\n    }\n    // @ts-ignore\n    @inline\n    export function bgYellowBright(text: string): string {\n        return colorText([103, 49], text)\n    }\n    // @ts-ignore\n    @inline\n    export function bgBlueBright(text: string): string {\n        return colorText([104, 49], text)\n    }\n    // @ts-ignore\n    @inline\n    export function bgMagentaBright(text: string): string {\n        return colorText([105, 49], text)\n    }\n    // @ts-ignore\n    @inline\n    export function bgCyanBright(text: string): string {\n        return colorText([106, 49], text)\n    }\n    // @ts-ignore\n    @inline\n    export function bgWhiteBright(text: string): string {\n        return colorText([107, 49], text)\n    }\n}\n\n// @ts-ignore\n@inline\nfunction colorText(format: i32[], text: string): string {\n    return `\\u001b[${format[0].toString()}m${text}\\u001b[${format[1].toString()}m`\n}","import {\r\n  args_get,\r\n  args_sizes_get,\r\n  environ_get,\r\n  environ_sizes_get,\r\n  proc_exit,\r\n  fd_write,\r\n  fd_close,\r\n  fd_read,\r\n  clock_time_get,\r\n  clockid,\r\n  errnoToString,\r\n  fd\r\n} from \"./bindings/wasi_snapshot_preview1\";\r\n\r\nimport {\r\n  tempbuf\r\n} from \"./wasi_internal\";\r\n\r\nimport {\r\n  E_INDEXOUTOFRANGE\r\n} from \"util/error\";\r\n\r\nexport namespace wasi_process {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy export const arch = sizeof<usize>() == 4 ? \"wasm32\" : \"wasm64\";\r\n  // @ts-ignore: decorator\r\n  @lazy export const platform = \"wasm\";\r\n  // @ts-ignore: decorator\r\n  @lazy export const argv = lazyArgv();\r\n  // @ts-ignore: decorator\r\n  @lazy export const env = lazyEnv();\r\n  // @ts-ignore: decorator\r\n  @lazy export var exitCode = 0;\r\n\r\n  export function exit(code: i32 = exitCode): void {\r\n    proc_exit(code);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy export const stdin = changetype<ReadableStream>(0);\r\n  // @ts-ignore: decorator\r\n  @lazy export const stdout = changetype<WritableStream>(1);\r\n  // @ts-ignore: decorator\r\n  @lazy export const stderr = changetype<WritableStream>(2);\r\n\r\n  export function time(): i64 {\r\n    let err = clock_time_get(clockid.REALTIME, 1000000, tempbuf);\r\n    if (err) throw new Error(errnoToString(err));\r\n    return load<u64>(tempbuf) / 1000000;\r\n  }\r\n\r\n  export function hrtime(): u64 {\r\n    let err = clock_time_get(clockid.MONOTONIC, 0, tempbuf);\r\n    if (err) throw new Error(errnoToString(err));\r\n    return load<u64>(tempbuf);\r\n  }\r\n}\r\n\r\nfunction lazyArgv(): string[] {\r\n  let err = args_sizes_get(tempbuf, tempbuf + sizeof<usize>());\r\n  if (err) throw new Error(errnoToString(err));\r\n  let count = load<usize>(tempbuf);\r\n  let ptrsSize = count * sizeof<usize>();\r\n  let dataSize = load<usize>(tempbuf, sizeof<usize>());\r\n  let bufSize = ptrsSize + dataSize;\r\n  let buf = __alloc(bufSize);\r\n  err = args_get(buf, buf + ptrsSize);\r\n  if (err) throw new Error(errnoToString(err));\r\n  let count32 = <i32>count;\r\n  let argv = new Array<string>(count32);\r\n  for (let i = 0; i < count32; ++i) {\r\n    let ptr = load<usize>(buf + i * sizeof<usize>());\r\n    let str = String.UTF8.decodeUnsafe(ptr, ptr + bufSize - buf, true);\r\n    argv[i] = str;\r\n  }\r\n  __free(buf);\r\n  return argv;\r\n}\r\n\r\nfunction lazyEnv(): Map<string,string> {\r\n  let err = environ_sizes_get(tempbuf, tempbuf + 4);\r\n  if (err) throw new Error(errnoToString(err));\r\n  let count = load<usize>(tempbuf);\r\n  let ptrsSize = count * sizeof<usize>();\r\n  let dataSize = load<usize>(tempbuf, sizeof<usize>());\r\n  let bufSize = ptrsSize + dataSize;\r\n  let buf = __alloc(bufSize);\r\n  err = environ_get(buf, buf + ptrsSize);\r\n  if (err) throw new Error(errnoToString(err));\r\n  let env = new Map<string,string>();\r\n  for (let i: usize = 0; i < count; ++i) {\r\n    let ptr = load<usize>(buf + i * sizeof<usize>());\r\n    let str = String.UTF8.decodeUnsafe(ptr, ptr + bufSize - buf, true);\r\n    let pos = str.indexOf(\"=\");\r\n    if (~pos) {\r\n      env.set(str.substring(0, pos), str.substring(pos + 1));\r\n      // __dispose(changetype<usize>(str));\r\n    } else {\r\n      env.set(str, \"\");\r\n    }\r\n  }\r\n  __free(buf);\r\n  return env;\r\n}\r\n\r\n@unmanaged\r\nabstract class Stream {\r\n  close(): void {\r\n    var err = fd_close(<u32>changetype<usize>(this));\r\n    if (err) throw new Error(errnoToString(err));\r\n  }\r\n}\r\n\r\n@unmanaged\r\nabstract class WritableStream extends Stream {\r\n  write<T>(data: T): void {\r\n    if (isString<T>()) {\r\n      writeString(<u32>changetype<usize>(this), changetype<string>(data));\r\n    } else if (data instanceof ArrayBuffer) {\r\n      writeBuffer(<u32>changetype<usize>(this), data);\r\n    } else {\r\n      ERROR(\"String or ArrayBuffer expected\");\r\n    }\r\n  }\r\n}\r\n\r\n@unmanaged\r\nabstract class ReadableStream extends Stream {\r\n  read(buffer: ArrayBuffer, offset: isize = 0): i32 {\r\n    var end = <usize>buffer.byteLength;\r\n    if (offset < 0 || <usize>offset > end) {\r\n      throw new Error(E_INDEXOUTOFRANGE);\r\n    }\r\n    store<usize>(tempbuf, changetype<usize>(buffer) + offset);\r\n    store<usize>(tempbuf, end - offset, sizeof<usize>());\r\n    var err = fd_read(<u32>changetype<usize>(this), tempbuf, 1, tempbuf + 2 * sizeof<usize>());\r\n    if (err) throw new Error(errnoToString(err));\r\n    return <i32>load<isize>(tempbuf, 2 * sizeof<usize>());\r\n  }\r\n}\r\n\r\nfunction writeBuffer(fd: fd, data: ArrayBuffer): void {\r\n  store<usize>(tempbuf, changetype<usize>(data));\r\n  store<usize>(tempbuf, data.byteLength, sizeof<usize>());\r\n  var err = fd_write(<u32>fd, tempbuf, 1, tempbuf + 2 * sizeof<usize>());\r\n  if (err) throw new Error(errnoToString(err));\r\n}\r\n\r\nfunction writeString(fd: fd, data: string): void {\r\n  var len = data.length;\r\n  var\r\n    char2: u32 = 0,\r\n    char3: u32 = 0,\r\n    char4: u32 = 0;\r\n  switch (len) {\r\n    case 4: { // \"null\"\r\n      char4 = <u32>load<u16>(changetype<usize>(data), 6);\r\n      if (char4 >= 0x80) break;\r\n    }\r\n    case 3: { // \"ms\\n\"\r\n      char3 = <u32>load<u16>(changetype<usize>(data), 4);\r\n      if (char3 >= 0x80) break;\r\n    }\r\n    case 2: { // \"\\r\\n\"\r\n      char2 = <u32>load<u16>(changetype<usize>(data), 2);\r\n      if (char2 >= 0x80) break;\r\n    }\r\n    case 1: { // \"\\n\"\r\n      let char1 = <u32>load<u16>(changetype<usize>(data));\r\n      if (char1 >= 0x80) break;\r\n      store<usize>(tempbuf, tempbuf + 2 * sizeof<usize>());\r\n      store<usize>(tempbuf, len, sizeof<usize>());\r\n      store<u32>(tempbuf, char1 | char2 << 8 | char3 << 16 | char4 << 24, 2 * sizeof<usize>());\r\n      let err = fd_write(<u32>fd, tempbuf, 1, tempbuf + 3 * sizeof<usize>());\r\n      if (err) throw new Error(errnoToString(err));\r\n    }\r\n    case 0: return;\r\n  }\r\n  var utf8len = <usize>String.UTF8.byteLength(data);\r\n  var utf8buf = __alloc(utf8len);\r\n  assert(String.UTF8.encodeUnsafe(changetype<usize>(data), len, utf8buf) == utf8len);\r\n  store<usize>(tempbuf, utf8buf);\r\n  store<usize>(tempbuf, utf8len, sizeof<usize>());\r\n  var err = fd_write(<u32>fd, tempbuf, 1, tempbuf + 2 * sizeof<usize>());\r\n  __free(utf8buf);\r\n  if (err) throw new Error(errnoToString(err));\r\n}\r\n","import {\r\n  wasi_process\r\n} from \"./wasi_process\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy var timers = new Map<string,u64>();\r\n\r\nexport namespace wasi_console {\r\n\r\n  export function assert<T>(condition: T, message: string = \"\"): void {\r\n    if (!condition) {\r\n      let stderr = wasi_process.stderr;\r\n      stderr.write(\"Assertion failed: \");\r\n      stderr.write(message);\r\n      stderr.write(\"\\n\");\r\n    }\r\n  }\r\n\r\n  export function log(message: string = \"\"): void {\r\n    let stdout = wasi_process.stdout;\r\n    stdout.write(message);\r\n    stdout.write(\"\\n\");\r\n  }\r\n\r\n  export function debug(message: string = \"\"): void {\r\n    let stdout = wasi_process.stdout;\r\n    stdout.write(\"Debug: \");\r\n    stdout.write(message);\r\n    stdout.write(\"\\n\");\r\n  }\r\n\r\n  export function info(message: string = \"\"): void {\r\n    let stdout = wasi_process.stdout;\r\n    stdout.write(\"Info: \");\r\n    stdout.write(message);\r\n    stdout.write(\"\\n\");\r\n  }\r\n\r\n  export function warn(message: string = \"\"): void {\r\n    let stdout = wasi_process.stdout;\r\n    stdout.write(\"Warning: \");\r\n    stdout.write(message);\r\n    stdout.write(\"\\n\");\r\n  }\r\n\r\n  export function error(message: string = \"\"): void {\r\n    let stdout = wasi_process.stdout;\r\n    stdout.write(\"Error: \");\r\n    stdout.write(message);\r\n    stdout.write(\"\\n\");\r\n  }\r\n\r\n  export function time(label: string = \"default\"): void {\r\n    let stdout = wasi_process.stdout;\r\n    if (timers.has(label)) {\r\n      stdout.write(\"Warning: Label '\");\r\n      stdout.write(label);\r\n      stdout.write(\"' already exists for console.time()\\n\");\r\n      return;\r\n    }\r\n    timers.set(label, wasi_process.hrtime());\r\n  }\r\n\r\n  export function timeLog(label: string = \"default\"): void {\r\n    let stdout = wasi_process.stdout;\r\n    if (!timers.has(label)) {\r\n      stdout.write(\"Warning: No such label '\");\r\n      stdout.write(label);\r\n      stdout.write(\"' for console.timeLog()\\n\");\r\n      return;\r\n    }\r\n    timeLogImpl(label);\r\n  }\r\n\r\n  export function timeEnd(label: string = \"default\"): void {\r\n    let stdout = wasi_process.stdout;\r\n    if (!timers.has(label)) {\r\n      stdout.write(\"Warning: No such label '\");\r\n      stdout.write(label);\r\n      stdout.write(\"' for console.timeEnd()\\n\");\r\n      return;\r\n    }\r\n    timeLogImpl(label);\r\n    timers.delete(label);\r\n  }\r\n}\r\n\r\nfunction timeLogImpl(label: string): void {\r\n  var start = changetype<u64>(timers.get(label));\r\n  var end = wasi_process.hrtime();\r\n  var nanos = end - start;\r\n  var millis = nanos / 1000000;\r\n  var millisStr = millis.toString();\r\n  var stdout = wasi_process.stdout;\r\n  stdout.write(label);\r\n  stdout.write(\": \");\r\n  stdout.write(millisStr);\r\n  stdout.write(\"ms\\n\");\r\n}\r\n","import {\r\n  clock_time_get,\r\n  clockid,\r\n  errnoToString\r\n} from \"./bindings/wasi_snapshot_preview1\";\r\n\r\nimport {\r\n  tempbuf\r\n} from \"./wasi_internal\";\r\n\r\nexport namespace wasi_performance {\r\n  export function now(): f64 {\r\n    let err = clock_time_get(clockid.MONOTONIC, 1000, tempbuf); // TODO: more precision?\r\n    if (err) throw new Error(errnoToString(err));\r\n    return <f64>load<u64>(tempbuf) / 1000000;\r\n  }\r\n}\r\n","import { rainbow } from \"as-rainbow\";\n\nexport function visualize<T>(value: T): string {\n    if (isNullable<T>() && changetype<usize>(value) == <usize>0) {\n        return \"null\";\n    } else if (isString<T>()) {\n        return value as string;\n    } else if (isBoolean<T>()) {\n        // @ts-ignore\n        return value.toString();\n    } else if (isInteger<T>() || isFloat<T>()) {\n        // @ts-ignore\n        return value.toString();\n    }\n\n    return unreachable();\n}\n\nexport function isTruthy<T>(value: T): boolean {\n    if (isNullable<T>() && changetype<usize>(value) === <usize>0) {\n        return false;\n    } else if (isString<T>()) {\n        return (value as string).length != 0;\n    } else if (isBoolean<T>()) {\n        return value as boolean;\n        // @ts-ignore\n    } else if ((isInteger<T>() || isFloat<T>()) && isNaN(value)) {\n        return false;\n    }\n    return true;\n}\n\nexport function isFalsy<T>(value: T): boolean {\n    return !isTruthy(value);\n}\n\nclass Diff { left: string; right: string; }\nexport function diff(left: string, right: string, not: boolean = false): Diff {\n    let rDiff = \"\";\n    let lDiff = \"\";\n\n    let i = 0;\n\n    for (; i < min(left.length, right.length); i++) {\n        const lChar = left.charAt(i);\n        const rChar = right.charAt(i);\n        if (not) {\n            if (lChar == rChar) {\n                lDiff += rainbow.bgGreen(rChar);\n                rDiff += rainbow.bgRed(lChar);\n            } else {\n                lDiff += rChar;\n                rDiff += lChar;\n            }\n        } else {\n            if (lChar != rChar) {\n                lDiff += rainbow.bgGreen(rChar);\n                rDiff += rainbow.bgRed(lChar);\n            } else {\n                lDiff += rChar;\n                rDiff += lChar;\n            }\n        }\n    }\n\n    if (!not) {\n        for (; i < left.length; i++) {\n            rDiff += rainbow.bgRed(left.charAt(i));\n        }\n        for (; i < right.length; i++) lDiff += rainbow.bgRed(right.charAt(i));\n    }\n\n    return {\n        left: lDiff,\n        right: rDiff\n    }\n}\n\nclass Unit {\n    name: string;\n    divisor: number;\n}\n\nexport function formatTime(ms: number): string {\n    if (ms < 0) {\n        throw new Error(\"Time should be a non-negative number.\");\n    }\n\n    // Convert milliseconds to microseconds\n    const us = ms * 1000;\n\n    const units: Unit[] = [\n        { name: 's', divisor: 1 },\n        { name: 'ms', divisor: 1000 },\n        { name: 's', divisor: 1000 * 1000 },\n        { name: 'm', divisor: 60 * 1000 * 1000 },\n        { name: 'h', divisor: 60 * 60 * 1000 * 1000 },\n        { name: 'd', divisor: 24 * 60 * 60 * 1000 * 1000 }\n    ];\n\n    for (let i = units.length - 1; i >= 0; i--) {\n        const unit = units[i];\n        if (us >= unit.divisor) {\n            const value = Math.round((us / unit.divisor) * 1000) / 1000;\n            return `${value}${unit.name}`;\n        }\n    }\n\n    return `${us}us`;\n}\n\n// @ts-ignore\n@inline\nexport function colorText(format: i32[], text: string): string {\n    return `\\u001b[${format[0].toString()}m${text}\\u001b[${format[1].toString()}m`\n}","type auto = i32;\n\n@final export abstract class Function<T> {\n  private _index: u32;\n  private _env: usize;\n\n  // @ts-ignore: this on getter\n  get index(this: T): u32 {\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\"_index\"));\n  }\n\n  // @ts-ignore: this on getter\n  get name(this: T): string {\n    return \"\";\n  }\n\n  // @ts-ignore: this on getter\n  get length(this: T): i32 {\n    // @ts-ignore: T is function\n    return lengthof<T>();\n  }\n\n  // @ts-ignore: T is function\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\n    return unreachable();\n  }\n\n  toString(this: T): string {\n    return \"function() { [native code] }\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    // Env is either `null` (nop) or compiler-generated\n    __visit(this._env, cookie);\n  }\n}\n"]}